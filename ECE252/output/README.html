<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Aditya Arora" />
  <title>README.html</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="shortcut icon" href="https://arora-aditya.com/images/A2.png" type="img">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137390799-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-137390799-2');
    window.onload = function(){
      let num = window.location.pathname.slice(window.location.pathname.length-3, window.location.pathname.length-1);
      if(parseInt(num) >= 33){
      document.getElementById('button').parentNode.removeChild(document.getElementById('button'));
      }
    }
  
    function next(){
      var num = window.location.pathname.slice(window.location.pathname.length-7, window.location.pathname.length-5);
      var next= String(parseInt(num)+1);
      if(next.length < 2){
        next = "0" + next
      }
      if(parseInt(num) < 33){
        // string manipulation to handle edge case for L"25" conflicting with "25"2 in header
        window.location.pathname = window.location.pathname.slice(0, window.location.pathname.length-7) + window.location.pathname.slice(window.location.pathname.length-7).replace(num, next);
      }
    }
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">252 Annotated</h1>
<p class="author">Aditya Arora</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#sections">Sections</a><ul>
<li><a href="#general">General</a></li>
<li><a href="#files">Files</a></li>
<li><a href="#process-management">Process Management</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#pipes-and-shared-memory">Pipes and Shared Memory</a></li>
<li><a href="#network">Network</a><ul>
<li><a href="#sockets">Sockets</a></li>
<li><a href="#curl">cURL</a></li>
</ul></li>
<li><a href="#threads-and-concurrency">Threads and Concurrency</a><ul>
<li><a href="#spinlock">Spinlock</a></li>
<li><a href="#atomic-types">Atomic Types</a></li>
</ul></li>
<li><a href="#select-poll-aio-libevent">Select, Poll, AIO, <code>Libevent</code></a></li>
<li><a href="#notes">Notes:</a><ul>
<li><a href="#speedup">Speedup</a></li>
<li><a href="#synchronization-patterns">Synchronization Patterns</a></li>
<li><a href="#conditions-for-deadlock">Conditions for Deadlock</a></li>
<li><a href="#valgrind">Valgrind</a></li>
<li><a href="#helgrind">Helgrind</a></li>
<li><a href="#consistency-journalling">Consistency: Journalling</a><ul>
<li><a href="#zfs-sunoracle-file-system">ZFS (Sun/Oracle File System)</a></li>
<li><a href="#apfs-apple-file-system">APFS (Apple File System)</a></li>
<li><a href="#ntfs-windows-file-system">NTFS (Windows File System)</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="sections">Sections</h1>
<ul>
<li><a href="#general">General</a></li>
<li><a href="#files">Files</a></li>
<li><a href="#process-management">Process Management</a></li>
<li><a href="#signals">Signals</a></li>
<li><a href="#pipes-and-shared-memory">Pipes and Shared Memory</a></li>
<li><a href="#network">Network</a>
<ul>
<li><a href="#sockets">Sockets</a></li>
<li><a href="#curl">cURL</a></li>
</ul></li>
<li><a href="#threads-and-concurrency">Threads and Concurrency</a>
<ul>
<li><a href="#spinlock">Spinlock</a></li>
<li><a href="#atomic-types">Atomic Types</a></li>
</ul></li>
<li><a href="#select-poll-aio-libevent">Select, Poll, AIO, Libevent</a></li>
<li><a href="#notes">Notes</a>
<ul>
<li><a href="#speedup">Speedup</a></li>
<li><a href="#synchronization-patterns">Synchronization Patterns</a></li>
<li><a href="#conditions-for-deadlock">Conditions for Deadlock</a></li>
<li><a href="#valgrind">Valgrind</a></li>
<li><a href="#helgrind">Helgrind</a></li>
<li><a href="#consistency-journalling">Consistency: Journalling</a>
<ul>
<li><a href="#zfs-sunoracle-file-system">ZFS (Sun/Oracle File System)</a></li>
<li><a href="#apfs-apple-file-system">APFS (Apple File System)</a></li>
<li><a href="#ntfs-windows-file-system">NTFS (Windows File System)</a></li>
</ul></li>
</ul></li>
</ul>
<h2 id="general">General</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">F: allocate num_bytes memory in the heap</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co">A: num_bytes of memory wanted to allocate</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co">R: void* pointer to the memory block in heap</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="dt">void</span>* malloc( <span class="dt">int</span> num_bytes );</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">F: allocate (count * size) bytes memory in the heap</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co"> : AND memory is initialized to ZERO</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">A: &quot;count&quot; number of objects, &quot;size&quot; of each object wanted to allocate</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">R: void* pointer to the memory block in heap</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="dt">void</span>* calloc( <span class="dt">size_t</span> count, <span class="dt">size_t</span> size );</a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">F: allocate new_size bytes memory in the heap AND deallocates</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co"> : the old ptr space (if required)</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co">A: ptr to old memory (NULL allowed, new memory initialized), new_size</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co">R: void* pointer to the updated memory block in heap</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="co">E: errno is set on failure, input pointer is still valid if realloc fails</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="dt">void</span> *realloc( <span class="dt">void</span> *ptr, <span class="dt">size_t</span> new_size );</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">F: free the memory space in heap</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">A: ptr to memory</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="dt">void</span> free( <span class="dt">void</span>* p );</a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">F: Convert string s to int</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">A: string s</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="dt">int</span> atoi( <span class="dt">const</span> <span class="dt">char</span> *s );</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co">F: Prints format string with given arguments</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">A: fmt: format string and corresponding parameters</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">      : d: signed decimal</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">      : lu: unsigned long</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">      : f: double</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">      : x: unsigned hex</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">      : s: string</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">      : n$: allows reordering of arguments as required</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="co">R: &gt;0 for error</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb6-13" title="13"><span class="dt">int</span> printf( <span class="dt">const</span> <span class="dt">char</span> * fmt, ... );</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="co">F: Copies num_bytes over from source to destination</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="co">A: source, destination pointer, size num_bytes to be transferred</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="co">R: original value of destination</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="co">H: &lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="dt">void</span>* memcpy( <span class="dt">void</span> *destination, <span class="dt">const</span> <span class="dt">void</span> *source, <span class="dt">size_t</span> num_bytes );</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">F: Writes num_bytes of (unsigned char) value to mem</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">A: mem pointer, value, num of bytes to be written</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="co">R: original value of destination</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">H: &lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="dt">void</span> *memset( <span class="dt">void</span> *mem, <span class="dt">int</span> value, <span class="dt">size_t</span> num_bytes );</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">F: returns size of string not counting null terminator</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co">A: string</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="co">R: length of string</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">H: &lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="dt">size_t</span> strlen( <span class="dt">const</span> <span class="dt">char</span> * string );</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">F: compares string str1, str2 up to max_size character</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">A: str1, str2, max_size to be compared</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">R: &gt;0 iff s1 &gt; s2, 0 iff s1 == s2, 0&lt; if s1 &lt; s2</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">H: &lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="dt">int</span> strncmp ( <span class="dt">const</span> <span class="dt">char</span> * str1, <span class="dt">const</span> <span class="dt">char</span> * str2, <span class="dt">size_t</span> max_size );</a></code></pre></div>
<h2 id="files">Files</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co">/*</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">F: opens the file for consumption using given flags</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co">A: pathname ie path to file,</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co"> : flags: one of O_RDONLY, O_WRONLY, or O_RDWR</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co">        : O_CREAT: if pathname does not exist, create it</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co">        : O_APPEND: append mode</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co">        : O_TRUNC: file will be truncated iff exists</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="co">        : O_ASYNC: generate signal when file available</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="co">        : O_DIRECTORY: if pathname is not a directory, open fails</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="co">        : O_EXCL: with O_CREAT, FILE has to be created, or else EEXIST</span></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="co">        : O_NOFOLLOW: do not follow symlinks</span></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="co">        : O_NONBLOCK: when possible, open non-blocking-ly</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="co">R: file_descriptor OR -1 on error</span></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="co">H: &lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb11-16" title="16"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb11-17" title="17"><span class="co">*/</span></a>
<a class="sourceLine" id="cb11-18" title="18"><span class="dt">int</span> open( <span class="dt">const</span> <span class="dt">char</span> *pathname, <span class="dt">int</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">F: attempts to read count bytes into buffer</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">A: file_descriptor to read, buffer to read into, count bytes</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">R: number of bytes actually read OR -1 on error</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="dt">ssize_t</span> read( <span class="dt">int</span> file_descriptor, <span class="dt">void</span> *buffer, <span class="dt">size_t</span> count );</a></code></pre></div>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co">F: writes upto count bytes from buffer to file represented by file_descriptor</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">A: file_descriptor to write to, buffer to read from, count bytes to write</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co">R: number of bytes actually written OR -1 on error</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="dt">ssize_t</span> write( <span class="dt">int</span> file_descriptor, <span class="dt">const</span> <span class="dt">void</span> *buffer, <span class="dt">size_t</span> count );</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co">F: renames the file, moving between directories if required</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co">A: old_pathname and new_pathname to rename</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="dt">int</span> rename( <span class="dt">const</span> <span class="dt">char</span> *old_pathname, <span class="dt">const</span> <span class="dt">char</span> *new_pathname );</a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co">F: closes the file, any record locks are removed</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="co">A: file_descriptor to close</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="dt">int</span> close( <span class="dt">int</span> file_descriptor );</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co">F: opens the file for consumption (with mode) associates a stream with it.</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">A: pathname ie path to file,</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co"> : mode:</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co">        : r : read from beginning</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co">        : r+: R/W from beginning</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="co">        : w : truncate to 0 length OR create file for write from beginning</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="co">        : w+: RW from beginning, create if not exist, truncate iff exist</span></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="co">        : a : write at end of file, create if not exist</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="co">        : a+: append for RW from end of file</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="co">        : b : binary file</span></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="co">R: FILE stream or NULL on error</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb16-15" title="15"><span class="co">*/</span></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="dt">FILE</span>* fopen( <span class="dt">const</span> <span class="dt">char</span> *pathname, <span class="dt">const</span> <span class="dt">char</span> *mode );</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="co">F: close stream f</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co">A: f stream</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co">R: 0 on success or EOF on error</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="dt">int</span> fclose( <span class="dt">FILE</span>* f );</a></code></pre></div>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="co">F: read nmemb items of data, each of size size from file into ptr</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="co">A: f stream, number of members nmemb, size of each object, and destination pointer buffer</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="co">R: number of bytes read</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb18-8" title="8"><span class="dt">size_t</span> fread( <span class="dt">void</span>* buffer, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nmemb, <span class="dt">FILE</span>* f );</a></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="co">F: write nmemb items of data, each of size size from ptr into file</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="co">A: f stream, number of members nmemb, size of each object, and source pointer</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="co">R: number of bytes written</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="dt">size_t</span> fwrite( <span class="dt">const</span> <span class="dt">void</span> *ptr, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nmemb, <span class="dt">FILE</span>* f);</a></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="co">F: Identical to printf but accepts file f to write to</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="co">A: File pointer f</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="co"> : fmt - format string and corresponding parameters</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">   : d: signed decimal</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">   : lu: unsigned long</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="co">   : f: double</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="co">   : x: unsigned hex</span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="co">   : s: string</span></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="co">   : n$: allows reordering of arguments as required</span></a>
<a class="sourceLine" id="cb20-11" title="11"><span class="co">R: &gt;0 for error</span></a>
<a class="sourceLine" id="cb20-12" title="12"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="co">*/</span></a>
<a class="sourceLine" id="cb20-14" title="14"><span class="dt">int</span> fprintf( <span class="dt">FILE</span>* f, <span class="dt">const</span> <span class="dt">char</span>* format, ... );</a></code></pre></div>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="co">F: Scans file for format string</span></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">A: File pointer f</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="co"> : fmt - format string and corresponding parameters</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="co">   : d: signed decimal</span></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="co">   : lu: unsigned long</span></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="co">   : f: double</span></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="co">   : x: unsigned hex</span></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="co">   : s: string</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="co">   : n$: allows reordering of arguments as required</span></a>
<a class="sourceLine" id="cb21-11" title="11"><span class="co">R: return the number of input items successfully matched and assigned or EOF on error</span></a>
<a class="sourceLine" id="cb21-12" title="12"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb21-13" title="13"><span class="co">*/</span></a>
<a class="sourceLine" id="cb21-14" title="14"><span class="dt">int</span> fscanf( <span class="dt">FILE</span>* f, <span class="dt">const</span> <span class="dt">char</span>* format, ... );</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="co">F: Convert File ptr to file descriptor</span></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="co">A: File pointer f</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="co">R: returns file descriptor for corresponding file</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="co">N: file still owned by File stream so call fclose still</span></a>
<a class="sourceLine" id="cb22-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="dt">int</span> fileno( <span class="dt">FILE</span>* f );</a></code></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="co">F: Seeks file pointer to designated location</span></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="co">A: File pointer f, relative offset from origin</span></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="co"> : origin:</span></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="co">    : SEEK_SET: start</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="co">    : SEEK_CUR: current</span></a>
<a class="sourceLine" id="cb23-7" title="7"><span class="co">    : SEEK_</span><span class="re">END</span><span class="co">: end</span></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="co">R: returns file descriptor for corresponding file</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb23-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="dt">int</span> fseek ( <span class="dt">FILE</span> * f, <span class="dt">long</span> <span class="dt">int</span> offset, <span class="dt">int</span> origin );</a></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="co">F: Deletes a pathname from filesystem</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">A: pathname of file or directory to be removed</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="co">H: &lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb24-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb24-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb24-8" title="8"><span class="dt">int</span> remove( <span class="dt">const</span> <span class="dt">char</span>* pathname );</a></code></pre></div>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="co">/*</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="co">F: Apply/remove &quot;advisory&quot; lock on fd</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co">A: file_descriptor</span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co"> : type:</span></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="co">    : LOCK_SH: shared lock to share between processes</span></a>
<a class="sourceLine" id="cb25-7" title="7"><span class="co">    : LOCK_EX: one process at a time</span></a>
<a class="sourceLine" id="cb25-8" title="8"><span class="co">    : LOCK_UN: remove an existing lock held by process</span></a>
<a class="sourceLine" id="cb25-9" title="9"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb25-10" title="10"><span class="co">H: &lt;sys/file.h&gt;</span></a>
<a class="sourceLine" id="cb25-11" title="11"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb25-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb25-13" title="13"><span class="dt">int</span> flock( <span class="dt">int</span> file_descriptor, <span class="dt">int</span> type );</a></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb26-2" title="2"><span class="co">F: Apply the command (OR flock) on file</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="co">A: file_descriptor</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="co"> : command:</span></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">    : F_GETLK: determine if lock described by flockptr is blocked</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="co">    : F_SETLK: set the lock described by flockptr</span></a>
<a class="sourceLine" id="cb26-7" title="7"><span class="co">    : F_SETLKW: blocking F_SETLK</span></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">R: 0 on success or ENUM, -1 on error</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">H: &lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="co">N: do not mix lockf and fcntl</span></a>
<a class="sourceLine" id="cb26-12" title="12"><span class="co"> : this can also be used to make sockets non-blocking as follows</span></a>
<a class="sourceLine" id="cb26-13" title="13"><span class="co">U: sockfd = socket( PF_INET, SOCK_STREAM, 0 );</span></a>
<a class="sourceLine" id="cb26-14" title="14"><span class="co"> : fcntl( sockfd, F_SETFL, O_NONBLOCK );</span></a>
<a class="sourceLine" id="cb26-15" title="15"><span class="co">*/</span></a>
<a class="sourceLine" id="cb26-16" title="16"><span class="dt">int</span> fcntl( <span class="dt">int</span> file_descriptor, <span class="dt">int</span> command, ... <span class="co">/* struct flock * flockptr */</span>);</a>
<a class="sourceLine" id="cb26-17" title="17"></a>
<a class="sourceLine" id="cb26-18" title="18"><span class="kw">struct</span> flock {</a>
<a class="sourceLine" id="cb26-19" title="19">  <span class="dt">short</span> l_type; <span class="co">// F_RDLCK, F_WRLCK, or F_UNLCK</span></a>
<a class="sourceLine" id="cb26-20" title="20">  <span class="dt">short</span> l_whence; <span class="co">// SEEK_SET, SEEK_CUR, or SEEK_</span><span class="re">END</span></a>
<a class="sourceLine" id="cb26-21" title="21">  off_t l_start; <span class="co">// offset in bytes, relative to l_whence</span></a>
<a class="sourceLine" id="cb26-22" title="22">  off_t l_len; <span class="co">// length, in bytes; 0 means lock to EOF</span></a>
<a class="sourceLine" id="cb26-23" title="23">  pid_t l_pid; <span class="co">// returned with F_GETLK</span></a>
<a class="sourceLine" id="cb26-24" title="24">};</a></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="co">F: apply, test or remove a POSIX lock on an open file</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">A: file_descriptor fd</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="co"> : len: can be positive or negative relative to current location</span></a>
<a class="sourceLine" id="cb27-5" title="5"><span class="co"> : command:</span></a>
<a class="sourceLine" id="cb27-6" title="6"><span class="co">    : F_LOCK: acquire exclusive lock on fd</span></a>
<a class="sourceLine" id="cb27-7" title="7"><span class="co">    : F_TLOCK: try-lock for F_LOCK</span></a>
<a class="sourceLine" id="cb27-8" title="8"><span class="co">    : F_ULOCK: unlock</span></a>
<a class="sourceLine" id="cb27-9" title="9"><span class="co">    : F_TEST: check if unlocked, 0 if unlocked, else -1</span></a>
<a class="sourceLine" id="cb27-10" title="10"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb27-11" title="11"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb27-12" title="12"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb27-13" title="13"><span class="co">N: do not mix lockf and fcntl</span></a>
<a class="sourceLine" id="cb27-14" title="14"><span class="co">*/</span></a>
<a class="sourceLine" id="cb27-15" title="15"><span class="dt">int</span> lockf( <span class="dt">int</span> file_descriptor, <span class="dt">int</span> command, off_t length );</a></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="co">Inotify API provides a mechanism for monitoring filesystem events, at file or directory level.</span></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb28-4" title="4"></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="co">/*</span></a>
<a class="sourceLine" id="cb28-6" title="6"><span class="co">F: creates an inotify instance</span></a>
<a class="sourceLine" id="cb28-7" title="7"><span class="co">A: NOTHING</span></a>
<a class="sourceLine" id="cb28-8" title="8"><span class="co">R: inotify_instance&#39;s file_descriptor</span></a>
<a class="sourceLine" id="cb28-9" title="9"><span class="co">H: &lt;sys/inotify.h&gt;</span></a>
<a class="sourceLine" id="cb28-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb28-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb28-12" title="12"><span class="dt">int</span> inotify_init( );</a></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="co">F: Adds a path to the &quot;watch list&quot; of an inotify fd</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co">A: inotify fd, pathname of file or directory</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="co">  : mask</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="co">    : IN_ACCESS:    File accessed (read/execute)</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="co">    : IN_ATTRIB:    Metadata changed, such as permissions</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="co">    : IN_CLOSE_WRITE:   File opened for writing was closed</span></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="co">    : IN_CLOSE_NOWRITE: File not opened for writing was closed</span></a>
<a class="sourceLine" id="cb29-9" title="9"><span class="co">    : IN_CREATE:    File or directory created in watched directory</span></a>
<a class="sourceLine" id="cb29-10" title="10"><span class="co">    : IN_DELETE:    File or directory deleted from watched directory</span></a>
<a class="sourceLine" id="cb29-11" title="11"><span class="co">    : IN_DELETE_SELF:   Watched file or directory deleted</span></a>
<a class="sourceLine" id="cb29-12" title="12"><span class="co">    : IN_MODIFY:    File modified (write, for example)</span></a>
<a class="sourceLine" id="cb29-13" title="13"><span class="co">    : IN_OPEN:  File opened</span></a>
<a class="sourceLine" id="cb29-14" title="14"><span class="co">    : IN_ALL_EVENTS:    Watch for all of the above (and a few more)</span></a>
<a class="sourceLine" id="cb29-15" title="15"><span class="co">R: non negative watch descriptor wd OR -1 on error</span></a>
<a class="sourceLine" id="cb29-16" title="16"><span class="co">H: &lt;sys/inotify.h&gt;</span></a>
<a class="sourceLine" id="cb29-17" title="17"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb29-18" title="18"><span class="co">*/</span></a>
<a class="sourceLine" id="cb29-19" title="19"><span class="dt">int</span> inotify_add_watch( <span class="dt">int</span> fd, <span class="dt">const</span> <span class="dt">char</span>* pathname, <span class="dt">uint32_t</span> mask );</a></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co">F: Removes an item from the &quot;watch list&quot; of an inotify fd</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co">A: inotify fd, watch descriptor wd</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="co">R: non negative watch descriptor OR -1 on error</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="co">H: &lt;sys/inotify.h&gt;</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb30-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="dt">int</span> inotify_rm_watch( <span class="dt">int</span> fd, <span class="dt">uint32_t</span> wd );</a></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">struct</span> inotify_event {</a>
<a class="sourceLine" id="cb31-2" title="2">  <span class="co">// Structure returned when you read inotify fd</span></a>
<a class="sourceLine" id="cb31-3" title="3">  <span class="dt">int</span> wd; <span class="co">// watch descriptor</span></a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5">  <span class="dt">uint32_t</span> mask; <span class="co">// mask describing event</span></a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7">  <span class="co">// Unique cookie associating related events</span></a>
<a class="sourceLine" id="cb31-8" title="8">  <span class="co">// rename shows up as 2 events</span></a>
<a class="sourceLine" id="cb31-9" title="9">  <span class="dt">uint32_t</span> cookie;</a>
<a class="sourceLine" id="cb31-10" title="10"></a>
<a class="sourceLine" id="cb31-11" title="11">  <span class="dt">uint32_t</span> len; <span class="co">// describes len of name</span></a>
<a class="sourceLine" id="cb31-12" title="12"></a>
<a class="sourceLine" id="cb31-13" title="13">  <span class="dt">char</span> name[]; <span class="co">// optional name</span></a>
<a class="sourceLine" id="cb31-14" title="14"></a>
<a class="sourceLine" id="cb31-15" title="15">  <span class="co">// note: we don&#39;t actually don&#39;t know the size of the struct</span></a>
<a class="sourceLine" id="cb31-16" title="16">  <span class="co">// because of the name parameter, use ioctl as shown below</span></a>
<a class="sourceLine" id="cb31-17" title="17">};</a></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb32-2" title="2"><span class="co">F: used to get size of inotify event before actually reading</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="co">A: inotify fd, FIONREAD for param2, value to be changed &amp;numbytes</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="co">R: non negative watch descriptor OR -1 on error</span></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="co">H: &lt;sys/inotify.h&gt;</span></a>
<a class="sourceLine" id="cb32-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb32-7" title="7"><span class="co">U: ioctl( fd, FIONREAD, &amp;numbytes )</span></a>
<a class="sourceLine" id="cb32-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb32-9" title="9"><span class="dt">int</span> ioctl(<span class="dt">int</span> fd, <span class="dt">unsigned</span> <span class="dt">long</span> request, ...);</a></code></pre></div>
<h2 id="process-management">Process Management</h2>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="co">F: creates new process by duplicating the calling process</span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="co">A: NOTHING</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="co">R: pid of child process returned in parent, 0 in child OR -1 on error</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb33-8" title="8">pid_t fork( );</a></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb34-2" title="2"><span class="co">F: waits for state change in child</span></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="co">A: *status stores information, can be NULL</span></a>
<a class="sourceLine" id="cb34-4" title="4"><span class="co">R: pid of terminated child returned in parent OR -1 on error</span></a>
<a class="sourceLine" id="cb34-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb34-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb34-7" title="7"><span class="co">U: wait(&amp;childStatus);</span></a>
<a class="sourceLine" id="cb34-8" title="8"><span class="co">N: if parent does not wait, then child resources are not deallocated and</span></a>
<a class="sourceLine" id="cb34-9" title="9"><span class="co"> : it becomes a zombie, which don&#39;t die until parent dies when they are</span></a>
<a class="sourceLine" id="cb34-10" title="10"><span class="co"> : inherited by the &quot;init&quot; which waits and kills them</span></a>
<a class="sourceLine" id="cb34-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb34-12" title="12">pid_t wait( <span class="dt">int</span>* status );</a></code></pre></div>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="co">F: waits for state change in pid</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co">A: *status stores information, can be NULL</span></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="co"> : pid:</span></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="co">    :-1: wait for any child</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="co">    :&gt;0: wait for pid</span></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="co"> : options: 0 is fine - notes</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="co">R: pid of terminated child returned in parent OR -1 on error</span></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb35-11" title="11"><span class="co">U: waitpid( pid, NULL, 0 );</span></a>
<a class="sourceLine" id="cb35-12" title="12"><span class="co">N: if parent does not wait, then child resources are not deallocated and</span></a>
<a class="sourceLine" id="cb35-13" title="13"><span class="co"> : it becomes a zombie, which don&#39;t die until parent dies when they are</span></a>
<a class="sourceLine" id="cb35-14" title="14"><span class="co"> : inherited by the &quot;init&quot; which waits and kills them</span></a>
<a class="sourceLine" id="cb35-15" title="15"><span class="co">*/</span></a>
<a class="sourceLine" id="cb35-16" title="16">pid_t waitpid( pid_t pid, <span class="dt">int</span> status, <span class="dt">int</span> options );</a></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">F: causes normal process termination</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">A: status to be returned to parent: EXIT_SUCCESS or EXIT_FAILURE</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">R: status &amp; 0377 is returned to parent, but does not truly &quot;return&quot;</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">H: &lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="dt">void</span> exit( <span class="dt">int</span> status );</a></code></pre></div>
<h2 id="signals">Signals</h2>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 40%" />
<col style="width: 14%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Signal</strong></th>
<th style="text-align: left;"><strong>Comment</strong></th>
<th style="text-align: left;"><strong>Value</strong></th>
<th style="text-align: left;"><strong>Default Action</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>SIGHUP</code></td>
<td style="text-align: left;">Hangup detected</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGINT</code></td>
<td style="text-align: left;">Keyboard interrupt (<code>Ctrl-C</code>)</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGQUIT</code></td>
<td style="text-align: left;">Quit from keyboard</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGILL</code></td>
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGKILL</code></td>
<td style="text-align: left;">Kill signal</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGSEGV</code></td>
<td style="text-align: left;">Segmentation fault (invalid memory reference)</td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGTERM</code></td>
<td style="text-align: left;">Termination signal</td>
<td style="text-align: left;">15</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGCHLD</code></td>
<td style="text-align: left;">Child stopped or terminated</td>
<td style="text-align: left;">20,17,18</td>
<td style="text-align: left;">Ignore</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGCONT</code></td>
<td style="text-align: left;">Continue if stopped</td>
<td style="text-align: left;">19,18,25</td>
<td style="text-align: left;">Continue the process if stopped</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGSTOP</code></td>
<td style="text-align: left;">Stop process</td>
<td style="text-align: left;">18,20,24</td>
<td style="text-align: left;">Stop process</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="co">F: send ANY signal to process</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="co">A: signal to send</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="co"> : pid:</span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="co">    :  &gt;0: send signal to process with process ID pid</span></a>
<a class="sourceLine" id="cb37-6" title="6"><span class="co">    :   0: send signal to process in same group as caller</span></a>
<a class="sourceLine" id="cb37-7" title="7"><span class="co">    :  -1: broadcast to all that it can</span></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="co">    : &lt;-1: send signal to process with absolute process ID pid</span></a>
<a class="sourceLine" id="cb37-9" title="9"><span class="co">R: 0 if signal sent, -1 on error</span></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb37-11" title="11"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb37-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb37-13" title="13"><span class="dt">int</span> kill( pid_t pid, <span class="dt">int</span> signal );</a></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="co">F: sends a signal to the calling process/thread</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="co">A: signal to send</span></a>
<a class="sourceLine" id="cb38-4" title="4"><span class="co">R: 0 if signal sent, -1 on error</span></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb38-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb38-8" title="8"><span class="dt">int</span> raise( <span class="dt">int</span> signal ); <span class="co">/* Send signal to the current process */</span></a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="co">F: basic usage of a singla handler</span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="co">A: signal to handle, signal handler passed</span></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="co">U: void sig_handler( int signal_num ); signal( SIGINT, sig_handler );</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb39-7" title="7"><span class="dt">void</span> ( *signal(<span class="dt">int</span> signum, <span class="dt">void</span> (*handler)(<span class="dt">int</span>)) ) (<span class="dt">int</span>);<span class="co">//*```</span></a></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb40-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="co">F: wait until terminating signal arrives or one that triggers handler</span></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="co">A: NOTHING</span></a>
<a class="sourceLine" id="cb40-4" title="4"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb40-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb40-6" title="6"><span class="dt">int</span> pause(<span class="dt">void</span>)</a></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb41-2" title="2"><span class="co">F: Initialize an empty sigset_t</span></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="co">A: accepts signal_set set</span></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb41-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb41-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb41-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb41-8" title="8"><span class="dt">int</span> sigemptyset( sigset_t set );</a></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb42-2" title="2"><span class="co">F: Add signal to signal set</span></a>
<a class="sourceLine" id="cb42-3" title="3"><span class="co">A: sigset_t to add signal to</span></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb42-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb42-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb42-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb42-8" title="8"><span class="dt">int</span> sigaddset( sigset_t set, <span class="dt">int</span> signal );</a></code></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb43-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="co">F: Add all SIGNALs from current POSIX to signal set</span></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="co">A: sigset_t to add signals to</span></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb43-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb43-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb43-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb43-8" title="8"><span class="dt">int</span> sigfillset( sigset_t set );</a></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb44-2" title="2"><span class="co">F: Deletes signal from signal set</span></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="co">A: sigset_t to remove signal from</span></a>
<a class="sourceLine" id="cb44-4" title="4"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb44-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb44-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb44-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb44-8" title="8"><span class="dt">int</span> sigdelset( sigset_t set, <span class="dt">int</span> signal );</a></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb45-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb45-2" title="2"><span class="co">F: Checks if signal is in signal set</span></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="co">A: sigset_t to check signal presence</span></a>
<a class="sourceLine" id="cb45-4" title="4"><span class="co">R: 1 if member, 0 if not, -1 on error</span></a>
<a class="sourceLine" id="cb45-5" title="5"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb45-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb45-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb45-8" title="8"><span class="dt">int</span> sigismember( sigset_t set, <span class="dt">int</span> signal );</a></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb46-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="co">F: examine and change blocked signals</span></a>
<a class="sourceLine" id="cb46-3" title="3"><span class="co">A: sigset_t * set to change, old_set OPTIONAL to get the old value</span></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="co"> : how:</span></a>
<a class="sourceLine" id="cb46-5" title="5"><span class="co">    : SIG_BLOCK: signals in set are added to block list</span></a>
<a class="sourceLine" id="cb46-6" title="6"><span class="co">    : SIG_SETMASK: signals in set are used to overwrite over the existing block list</span></a>
<a class="sourceLine" id="cb46-7" title="7"><span class="co">    : SIG_UNBLOCK: signals in set are removed from block list</span></a>
<a class="sourceLine" id="cb46-8" title="8"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb46-9" title="9"><span class="co">H: &lt;signal.h&gt;</span></a>
<a class="sourceLine" id="cb46-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb46-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb46-12" title="12"><span class="dt">int</span> sigprocmask( <span class="dt">int</span> how, <span class="dt">const</span> sigset_t * set, sigset_t * old_set );</a></code></pre></div>
<h2 id="pipes-and-shared-memory">Pipes and Shared Memory</h2>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">F: creates a unidirectional data channel for IPC</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">A: array of exactly 2 file descriptors</span></a>
<a class="sourceLine" id="cb47-4" title="4"><span class="co">R: 0 on completion, -1 on error</span></a>
<a class="sourceLine" id="cb47-5" title="5"><span class="co">H: &lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb47-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="co">U: use pipe before forking to get the same fd&#39;s b/w child and parent</span></a>
<a class="sourceLine" id="cb47-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb47-9" title="9"><span class="dt">int</span> pipe( <span class="dt">int</span> file_descriptors[] );</a></code></pre></div>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb48-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="co">F: create new shared memory segment</span></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">A: key: IPC_PRIVATE - notes</span></a>
<a class="sourceLine" id="cb48-4" title="4"><span class="co"> : size: size of shared memory needed</span></a>
<a class="sourceLine" id="cb48-5" title="5"><span class="co"> : shmflg:</span></a>
<a class="sourceLine" id="cb48-6" title="6"><span class="co">    : IPC_CREAT: create new segment</span></a>
<a class="sourceLine" id="cb48-7" title="7"><span class="co">    : IPC_EXCL: exclusive create segment</span></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="co">    : can also be OR&#39;ed with UNIX type permissions</span></a>
<a class="sourceLine" id="cb48-9" title="9"><span class="co">R: integer identifier of shared memory segment, -1 on error</span></a>
<a class="sourceLine" id="cb48-10" title="10"><span class="co">H: &lt;sys/shm.h&gt; &amp; &lt;sys/ipc.h&gt;</span></a>
<a class="sourceLine" id="cb48-11" title="11"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb48-12" title="12"><span class="co">U: int shmid = shmget( IPC_PRIVATE, 32, IPC_CREAT | 0666  );</span></a>
<a class="sourceLine" id="cb48-13" title="13"><span class="co">*/</span></a>
<a class="sourceLine" id="cb48-14" title="14"><span class="dt">int</span> shmget( key_t key, <span class="dt">size_t</span> size, <span class="dt">int</span> shmflg );</a></code></pre></div>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="co">F: attach a shared memory segment to current process&#39;s address space</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">A: shmid: shared memory segment&#39;s id returned by shmget</span></a>
<a class="sourceLine" id="cb49-4" title="4"><span class="co"> : shmaddr: NULL - notes, auto selects</span></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="co"> : shmflg: 0 - notes</span></a>
<a class="sourceLine" id="cb49-6" title="6"><span class="co">    : SHM_RDONLY: only READ</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="co">    : other flags exist, but we don&#39;t need to care</span></a>
<a class="sourceLine" id="cb49-8" title="8"><span class="co">R: void pointer to shared memory segment, -1 on error</span></a>
<a class="sourceLine" id="cb49-9" title="9"><span class="co">H: &lt;sys/shm.h&gt; &amp; &lt;sys/ipc.h&gt;</span></a>
<a class="sourceLine" id="cb49-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb49-11" title="11"><span class="co">U: void* mem = shmat( shmid, NULL, 0 );</span></a>
<a class="sourceLine" id="cb49-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb49-13" title="13"><span class="dt">void</span>* shmat( <span class="dt">int</span> shmid, <span class="dt">const</span> <span class="dt">void</span>* shmaddr, <span class="dt">int</span> shmflg );</a></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb50-2" title="2"><span class="co">F: detaches the shared memory segment from current process&#39;s address space</span></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="co">A: shmaddr: memory address to detach</span></a>
<a class="sourceLine" id="cb50-4" title="4"><span class="co">R: 0 on sucess, -1 on error</span></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="co">H: &lt;sys/shm.h&gt; &amp; &lt;sys/ipc.h&gt;</span></a>
<a class="sourceLine" id="cb50-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb50-7" title="7"><span class="co">U: shmdt( mem );</span></a>
<a class="sourceLine" id="cb50-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb50-9" title="9"><span class="dt">int</span> shmdt( <span class="dt">const</span> <span class="dt">void</span>* shmaddr );</a></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb51-2" title="2"><span class="co">F: ONLY to delete the shared memory segment</span></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="co">A: shmid: shared memory id</span></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="co"> : cmd: IPC_RMID for deleting</span></a>
<a class="sourceLine" id="cb51-5" title="5"><span class="co"> : buf: NULL - notes for DELETE</span></a>
<a class="sourceLine" id="cb51-6" title="6"><span class="co">R: 0 on sucess, -1 on error</span></a>
<a class="sourceLine" id="cb51-7" title="7"><span class="co">H: &lt;sys/shm.h&gt; &amp; &lt;sys/ipc.h&gt;</span></a>
<a class="sourceLine" id="cb51-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb51-9" title="9"><span class="co">U: shmctl( shmid, IPC_RMID, NULL );</span></a>
<a class="sourceLine" id="cb51-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb51-11" title="11"><span class="dt">int</span> shmctl( <span class="dt">int</span> shmid, <span class="dt">int</span> cmd, <span class="kw">struct</span> shmid_ds *buf );</a></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb52-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb52-2" title="2"><span class="co">F: ALTERNATE to create shared memory segment</span></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="co">A: address: NULL - notes</span></a>
<a class="sourceLine" id="cb52-4" title="4"><span class="co"> : length: length of the mapping</span></a>
<a class="sourceLine" id="cb52-5" title="5"><span class="co"> : protection:</span></a>
<a class="sourceLine" id="cb52-6" title="6"><span class="co">      : PROT_READ: Pages may be read</span></a>
<a class="sourceLine" id="cb52-7" title="7"><span class="co">      : PROT_WRITE: Pages may be written</span></a>
<a class="sourceLine" id="cb52-8" title="8"><span class="co">      : PROT_EXECUTE: Pages may be executed</span></a>
<a class="sourceLine" id="cb52-9" title="9"><span class="co">      : PROT_NONE: Pages may not be accessed</span></a>
<a class="sourceLine" id="cb52-10" title="10"><span class="co"> : flag: MAP_SHARED for shared</span></a>
<a class="sourceLine" id="cb52-11" title="11"><span class="co"> : fd: file descriptor of the file we wish to map</span></a>
<a class="sourceLine" id="cb52-12" title="12"><span class="co"> : offset: offset from the start of the file</span></a>
<a class="sourceLine" id="cb52-13" title="13"><span class="co">R: pointer to starting address of memory mapped to file OR (void *) -1 on error</span></a>
<a class="sourceLine" id="cb52-14" title="14"><span class="co">H: &lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb52-15" title="15"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb52-16" title="16"><span class="co">N: PROT_NONE is used when you want to restrict the memory, and put &quot;guards&quot;</span></a>
<a class="sourceLine" id="cb52-17" title="17"><span class="co"> : on the memory range.</span></a>
<a class="sourceLine" id="cb52-18" title="18"><span class="co">*/</span></a>
<a class="sourceLine" id="cb52-19" title="19"><span class="dt">void</span>* mmap( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> protection, <span class="dt">int</span> flag, <span class="dt">int</span> fd, off_t offset );</a></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb53-2" title="2"><span class="co">F: ALTERNATE update permissions for memory segment</span></a>
<a class="sourceLine" id="cb53-3" title="3"><span class="co">A: address: NULL - notes</span></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="co"> : length: length of the mapping</span></a>
<a class="sourceLine" id="cb53-5" title="5"><span class="co"> : prot: updated protection rules</span></a>
<a class="sourceLine" id="cb53-6" title="6"><span class="co">      : PROT_READ: Pages may be read</span></a>
<a class="sourceLine" id="cb53-7" title="7"><span class="co">      : PROT_WRITE: Pages may be written</span></a>
<a class="sourceLine" id="cb53-8" title="8"><span class="co">      : PROT_EXECUTE: Pages may be executed</span></a>
<a class="sourceLine" id="cb53-9" title="9"><span class="co">      : PROT_NONE: Pages may not be accessed</span></a>
<a class="sourceLine" id="cb53-10" title="10"><span class="co">R: 0 on success OR -1 on error</span></a>
<a class="sourceLine" id="cb53-11" title="11"><span class="co">H: &lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb53-12" title="12"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb53-13" title="13"><span class="co">*/</span></a>
<a class="sourceLine" id="cb53-14" title="14"><span class="dt">int</span> mprotect( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> prot );</a></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb54-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="co">F: Flushes out changes in memory directly back to file</span></a>
<a class="sourceLine" id="cb54-3" title="3"><span class="co">A: address: NULL - notes</span></a>
<a class="sourceLine" id="cb54-4" title="4"><span class="co"> : length: length of the mapping</span></a>
<a class="sourceLine" id="cb54-5" title="5"><span class="co"> : flags: MS_SYNC - notes</span></a>
<a class="sourceLine" id="cb54-6" title="6"><span class="co">R: 0 on success OR -1 on error</span></a>
<a class="sourceLine" id="cb54-7" title="7"><span class="co">H: &lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb54-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb54-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb54-10" title="10"><span class="dt">int</span> msync( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb55-2" title="2"><span class="co">F: Unmap segment</span></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="co">A: address: NULL - notes</span></a>
<a class="sourceLine" id="cb55-4" title="4"><span class="co"> : length: length of the mapping</span></a>
<a class="sourceLine" id="cb55-5" title="5"><span class="co">R: 0 on success OR -1 on error</span></a>
<a class="sourceLine" id="cb55-6" title="6"><span class="co">H: &lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb55-7" title="7"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb55-8" title="8"><span class="co">N: segment is generally automatically unmapped when process ends</span></a>
<a class="sourceLine" id="cb55-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb55-10" title="10"><span class="dt">int</span> munmap( <span class="dt">void</span>* address, <span class="dt">size_t</span> length );</a></code></pre></div>
<h2 id="network">Network</h2>
<h3 id="sockets">Sockets</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb56-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="co">F: Creates an endpoint for communication</span></a>
<a class="sourceLine" id="cb56-3" title="3"><span class="co">A: domain: AF_INET - notes</span></a>
<a class="sourceLine" id="cb56-4" title="4"><span class="co"> : type: specifies communication semantics</span></a>
<a class="sourceLine" id="cb56-5" title="5"><span class="co">    : SOCK_STREAM: bidirectional byte stream</span></a>
<a class="sourceLine" id="cb56-6" title="6"><span class="co">    : SOCK_DGRAM: datagrams</span></a>
<a class="sourceLine" id="cb56-7" title="7"><span class="co"> : protocol: 0 - notes</span></a>
<a class="sourceLine" id="cb56-8" title="8"><span class="co">R: file descriptor for new socket OR -1 on error</span></a>
<a class="sourceLine" id="cb56-9" title="9"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb56-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb56-11" title="11"><span class="co">N: you can just close the socket with `close`</span></a>
<a class="sourceLine" id="cb56-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb56-13" title="13"><span class="dt">int</span> socket( <span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol );</a></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb57-2" title="2"><span class="co">F: Byte order from host to network order</span></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="co">A: hostint32: 4byte argument</span></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="co">R: returns &quot;network&quot; byte-reordered argument</span></a>
<a class="sourceLine" id="cb57-5" title="5"><span class="co">H: &lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb57-7" title="7"><span class="dt">uint32_t</span> htonl( <span class="dt">uint32_t</span> hostint32 );</a></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb58-2" title="2"><span class="co">F: Byte order from host to network order</span></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="co">A: hostint16: 2byte argument</span></a>
<a class="sourceLine" id="cb58-4" title="4"><span class="co">R: returns &quot;network&quot; byte-reordered argument</span></a>
<a class="sourceLine" id="cb58-5" title="5"><span class="co">H: &lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb58-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb58-7" title="7"><span class="dt">uint16_t</span> htons( <span class="dt">uint16_t</span> hostint16 );</a></code></pre></div>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb59-2" title="2"><span class="co">F: Byte order from network to host order</span></a>
<a class="sourceLine" id="cb59-3" title="3"><span class="co">A: netint32: 4byte argument</span></a>
<a class="sourceLine" id="cb59-4" title="4"><span class="co">R: returns &quot;host&quot; byte-reordered argument</span></a>
<a class="sourceLine" id="cb59-5" title="5"><span class="co">H: &lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb59-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb59-7" title="7"><span class="dt">uint32_t</span> ntohl( <span class="dt">uint32_t</span> netint32 );</a></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb60-2" title="2"><span class="co">F: Byte order from network to host order</span></a>
<a class="sourceLine" id="cb60-3" title="3"><span class="co">A: netint32: 2byte argument</span></a>
<a class="sourceLine" id="cb60-4" title="4"><span class="co">R: returns &quot;host&quot; byte-reordered argument</span></a>
<a class="sourceLine" id="cb60-5" title="5"><span class="co">H: &lt;arpa/inet.h&gt;</span></a>
<a class="sourceLine" id="cb60-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb60-7" title="7"><span class="dt">uint16_t</span> ntohs( <span class="dt">uint16_t</span> netint16 );</a></code></pre></div>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb61-2" title="2"><span class="co">U: addr.sin_addr.s_addr = htonl( INADDR_ANY );</span></a>
<a class="sourceLine" id="cb61-3" title="3"><span class="co"> : use above to select any IP of the device</span></a>
<a class="sourceLine" id="cb61-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb61-5" title="5"><span class="kw">struct</span> sockaddr_in {</a>
<a class="sourceLine" id="cb61-6" title="6">  sa_family_t sin_family; <span class="co">// AF_INET</span></a>
<a class="sourceLine" id="cb61-7" title="7">  in_port_t sin_port; <span class="co">// port in network byte order</span></a>
<a class="sourceLine" id="cb61-8" title="8">  <span class="kw">struct</span> in_addr sin_addr; <span class="co">// IPv4 address</span></a>
<a class="sourceLine" id="cb61-9" title="9">};</a></code></pre></div>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb62-2" title="2"><span class="co">U: struct addrinfo hints;</span></a>
<a class="sourceLine" id="cb62-3" title="3"><span class="co"> : memset(&amp;hints, 0, sizeof hints);</span></a>
<a class="sourceLine" id="cb62-4" title="4"><span class="co"> : after that set each of the parameters below to the required value</span></a>
<a class="sourceLine" id="cb62-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb62-6" title="6"><span class="kw">struct</span> addrinfo {</a>
<a class="sourceLine" id="cb62-7" title="7">  ...</a>
<a class="sourceLine" id="cb62-8" title="8">  sa_family_t ai_family; <span class="co">// AF_INET</span></a>
<a class="sourceLine" id="cb62-9" title="9">  <span class="dt">int</span> ai_socktype; <span class="co">// SOCK_STREAM or SOCK_DGRAM</span></a>
<a class="sourceLine" id="cb62-10" title="10">  <span class="dt">int</span> ai_socktype; <span class="co">// AF_INET for IPv4</span></a>
<a class="sourceLine" id="cb62-11" title="11">  ...</a>
<a class="sourceLine" id="cb62-12" title="12">}</a></code></pre></div>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb63-2" title="2"><span class="co">F: Creates an endpoint for communication</span></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="co">A: node: &quot;url&quot; or IP</span></a>
<a class="sourceLine" id="cb63-4" title="4"><span class="co"> : service: port</span></a>
<a class="sourceLine" id="cb63-5" title="5"><span class="co"> : hints: struct declared as above, using the default parameters</span></a>
<a class="sourceLine" id="cb63-6" title="6"><span class="co"> : res: the complete addrinfo is stored in res, also declared as above</span></a>
<a class="sourceLine" id="cb63-7" title="7"><span class="co">      : but without any of the default parameters</span></a>
<a class="sourceLine" id="cb63-8" title="8"><span class="co">R: 0 on sucess OR NON_ZERO error code on error</span></a>
<a class="sourceLine" id="cb63-9" title="9"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt; AND &lt;netdb.h&gt;</span></a>
<a class="sourceLine" id="cb63-10" title="10"><span class="co">U: int result = getaddrinfo(&quot;www.example.com&quot;, &quot;2520&quot;, &amp;hints, &amp;serverinfo);</span></a>
<a class="sourceLine" id="cb63-11" title="11"><span class="co"> : struct sockaddr_in * sain = (struct sockaddr_in*) serverinfo-&gt;ai_addr;</span></a>
<a class="sourceLine" id="cb63-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb63-13" title="13"><span class="dt">int</span> getaddrinfo( <span class="dt">const</span> <span class="dt">char</span> *node, <span class="dt">const</span> <span class="dt">char</span> *service,</a>
<a class="sourceLine" id="cb63-14" title="14">                  <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints, <span class="kw">struct</span> addrinfo **res );</a></code></pre></div>
<div class="sourceCode" id="cb64"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb64-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb64-2" title="2"><span class="co">F: Used on client side of things to connect to socket</span></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="co">A: sockfd: file descriptor from socket</span></a>
<a class="sourceLine" id="cb64-4" title="4"><span class="co"> : addr: sockaddr returned from getaddrinfo</span></a>
<a class="sourceLine" id="cb64-5" title="5"><span class="co"> : len: if self created: sizeof(addr) else res-&gt;ai_addrlen from prev step</span></a>
<a class="sourceLine" id="cb64-6" title="6"><span class="co">R: 0 on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb64-7" title="7"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb64-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb64-9" title="9"><span class="co">U: int status = connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</span></a>
<a class="sourceLine" id="cb64-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb64-11" title="11"><span class="dt">int</span> connect( <span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t len );</a></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb65-2" title="2"><span class="co">F: Used on server side of things to &quot;create&quot; a socket</span></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="co">A: sockfd: file descriptor from socket</span></a>
<a class="sourceLine" id="cb65-4" title="4"><span class="co"> : addr: sockaddr_in to be cast using default params</span></a>
<a class="sourceLine" id="cb65-5" title="5"><span class="co"> : len: sizeof(addr)</span></a>
<a class="sourceLine" id="cb65-6" title="6"><span class="co">R: 0 on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb65-7" title="7"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb65-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb65-9" title="9"><span class="co">U: bind( socketfd, (struct sockaddr*) &amp;addr, sizeof( addr ));</span></a>
<a class="sourceLine" id="cb65-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb65-11" title="11"><span class="dt">int</span> bind( <span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="kw">struct</span> sockaddr *addr, socklen_t addrlen );</a></code></pre></div>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb66-2" title="2"><span class="co">F: Actually used to listen on server side</span></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="co">A: sockfd: file descriptor from socket, that was binded</span></a>
<a class="sourceLine" id="cb66-4" title="4"><span class="co"> : backlog: maximum number of pending connections in queue</span></a>
<a class="sourceLine" id="cb66-5" title="5"><span class="co">R: 0 on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb66-6" title="6"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb66-7" title="7"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb66-8" title="8"><span class="co">U: listen( socketfd, 5 );</span></a>
<a class="sourceLine" id="cb66-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb66-10" title="10"><span class="dt">int</span> listen( <span class="dt">int</span> sockfd, <span class="dt">int</span> backlog );</a></code></pre></div>
<div class="sourceCode" id="cb67"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb67-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb67-2" title="2"><span class="co">F: Declares secondary socket for correspondence</span></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="co">A: sockfd: socket file descriptor that we are listening on</span></a>
<a class="sourceLine" id="cb67-4" title="4"><span class="co"> : addr: client addr that gets updated by function, simply allocate sockaddr_in and pass</span></a>
<a class="sourceLine" id="cb67-5" title="5"><span class="co"> : len: client addr size that gets updated by function, simply allocate int and pass</span></a>
<a class="sourceLine" id="cb67-6" title="6"><span class="co">R: addr and len are changed, 0 on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb67-7" title="7"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb67-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb67-9" title="9"><span class="co">U: newsockfd = accept( socktfd, (struct sockaddr*) &amp;client_addr, &amp;client_addr_size );</span></a>
<a class="sourceLine" id="cb67-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb67-11" title="11"><span class="dt">int</span> accept( <span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t *len );</a></code></pre></div>
<div class="sourceCode" id="cb68"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb68-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb68-2" title="2"><span class="co">F: Sends data to server side</span></a>
<a class="sourceLine" id="cb68-3" title="3"><span class="co">Equivalent to: sendto(sockfd, buf, len, flags, NULL, 0);</span></a>
<a class="sourceLine" id="cb68-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb68-5" title="5"><span class="dt">int</span> send( <span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span>* msg, <span class="dt">int</span> length, <span class="dt">int</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb69"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb69-2" title="2"><span class="co">F: Sends data from client side</span></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="co">Equivalent to: recvfrom(sockfd, buf, len, flags, NULL, NULL);</span></a>
<a class="sourceLine" id="cb69-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb69-5" title="5"><span class="dt">int</span> recv( <span class="dt">int</span> sockfd, <span class="dt">void</span> * buffer, <span class="dt">int</span> length, <span class="dt">int</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb70"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb70-2" title="2"><span class="co">F: Declares secondary socket for correspondence</span></a>
<a class="sourceLine" id="cb70-3" title="3"><span class="co">A: sockfd: file descriptor of sending socket</span></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="co"> : msg: message that we want to send</span></a>
<a class="sourceLine" id="cb70-5" title="5"><span class="co"> : len: (string) length of message</span></a>
<a class="sourceLine" id="cb70-6" title="6"><span class="co"> : flags: 0 - notes</span></a>
<a class="sourceLine" id="cb70-7" title="7"><span class="co"> : to: sockaddr of recieving socket</span></a>
<a class="sourceLine" id="cb70-8" title="8"><span class="co"> : token: sizeof(to) or res-&gt;ai_addrlen</span></a>
<a class="sourceLine" id="cb70-9" title="9"><span class="co">R: number of bytes sent on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb70-10" title="10"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb70-11" title="11"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb70-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb70-13" title="13"><span class="dt">int</span> sendto( <span class="dt">int</span> sfd, <span class="dt">const</span> <span class="dt">void</span>* msg, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags, <span class="dt">const</span> <span class="kw">struct</span> sockaddr* to, socklen_t token );</a></code></pre></div>
<div class="sourceCode" id="cb71"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb71-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb71-2" title="2"><span class="co">F: Declares secondary socket for correspondence</span></a>
<a class="sourceLine" id="cb71-3" title="3"><span class="co">A: sockfd: file descriptor of socket want to recieve from</span></a>
<a class="sourceLine" id="cb71-4" title="4"><span class="co"> : buffer: message that we recieved is updated here</span></a>
<a class="sourceLine" id="cb71-5" title="5"><span class="co"> : len: max length of buffer we are accpeting</span></a>
<a class="sourceLine" id="cb71-6" title="6"><span class="co"> : flags: 0 - notes</span></a>
<a class="sourceLine" id="cb71-7" title="7"><span class="co"> : from: sockaddr of source</span></a>
<a class="sourceLine" id="cb71-8" title="8"><span class="co"> : fromlength: sizeof(from) or res-&gt;ai_addrlen</span></a>
<a class="sourceLine" id="cb71-9" title="9"><span class="co">R: length of message recieved on sucess OR -1 on error</span></a>
<a class="sourceLine" id="cb71-10" title="10"><span class="co">H: &lt;sys/socket.h&gt; AND &lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb71-11" title="11"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb71-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb71-13" title="13"><span class="dt">int</span> recvfrom( <span class="dt">int</span> sfd, <span class="dt">void</span>* buffer, <span class="dt">int</span> len, <span class="dt">unsigned</span> <span class="dt">int</span> flags, <span class="kw">struct</span> sockaddr* from, <span class="dt">int</span>* fromlength );</a></code></pre></div>
<h3 id="curl">cURL</h3>
<div class="sourceCode" id="cb72"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb72-2" title="2"><span class="co">F: global init for everything curl</span></a>
<a class="sourceLine" id="cb72-3" title="3"><span class="co">A: flags: CURL_GLOBAL_DEFAULT - notes</span></a>
<a class="sourceLine" id="cb72-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb72-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb72-6" title="6"><span class="co">N: Not thread safe, call EXACTLY ONCE</span></a>
<a class="sourceLine" id="cb72-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb72-8" title="8">CURLcode curl_global_init( <span class="dt">long</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb73"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb73-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb73-2" title="2"><span class="co">F: start a libcurl easy session</span></a>
<a class="sourceLine" id="cb73-3" title="3"><span class="co">A: NOTHING</span></a>
<a class="sourceLine" id="cb73-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb73-5" title="5"><span class="co">R: NON-NULL CURL handle on success, NULL on error</span></a>
<a class="sourceLine" id="cb73-6" title="6"><span class="co">N: If you did not already call curl_global_init,</span></a>
<a class="sourceLine" id="cb73-7" title="7"><span class="co"> : curl_easy_init does it automatically.</span></a>
<a class="sourceLine" id="cb73-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb73-9" title="9">CURL* curl_easy_init( <span class="dt">void</span> );</a></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb74-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb74-2" title="2"><span class="co">F: finish a libcurl easy session</span></a>
<a class="sourceLine" id="cb74-3" title="3"><span class="co">A: handle: CURL handle from easy_init</span></a>
<a class="sourceLine" id="cb74-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb74-5" title="5"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb74-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb74-7" title="7"><span class="dt">void</span> curl_easy_cleanup( CURL* handle );</a></code></pre></div>
<div class="sourceCode" id="cb75"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb75-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb75-2" title="2"><span class="co">F: Allows to actually configure the curl call</span></a>
<a class="sourceLine" id="cb75-3" title="3"><span class="co">A: handle: CURL handle from easy_init</span></a>
<a class="sourceLine" id="cb75-4" title="4"><span class="co"> : option:</span></a>
<a class="sourceLine" id="cb75-5" title="5"><span class="co">      : CURLOPT_URL: url to connect, character array</span></a>
<a class="sourceLine" id="cb75-6" title="6"><span class="co">      : CURLOPT_WRITEFUNCTION: set write callback function, function pointer</span></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="co">      : CURLOPT_WRITEDATA: set write callback data, void *</span></a>
<a class="sourceLine" id="cb75-8" title="8"><span class="co">      : CURLOPT_READFUNCTION: set read callback function, function pointer</span></a>
<a class="sourceLine" id="cb75-9" title="9"><span class="co">      : CURLOPT_READDATA: set read callback data, void *</span></a>
<a class="sourceLine" id="cb75-10" title="10"><span class="co">      : CURLOPT_PUT: Issue PUT request, 1L - notes</span></a>
<a class="sourceLine" id="cb75-11" title="11"><span class="co">      : CURLOPT_POST: Issue POST request, 1L - notes</span></a>
<a class="sourceLine" id="cb75-12" title="12"><span class="co">      : CURLOPT_HTTPGET: Issue GET request, 1L - notes</span></a>
<a class="sourceLine" id="cb75-13" title="13"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb75-14" title="14"><span class="co">R: CURLE_OK(0), non-zero for error</span></a>
<a class="sourceLine" id="cb75-15" title="15"><span class="co">U: curl_easy_setopt( curl, CURLOPT_URL, &quot;https://example.com/&quot; );</span></a>
<a class="sourceLine" id="cb75-16" title="16"><span class="co">*/</span></a>
<a class="sourceLine" id="cb75-17" title="17">CURLcode curl_easy_setopt( CURL *handle, CURLoption option, parameter );</a></code></pre></div>
<div class="sourceCode" id="cb76"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb76-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb76-2" title="2"><span class="co">F: Perform the configured curl call</span></a>
<a class="sourceLine" id="cb76-3" title="3"><span class="co">A: handle: CURL handle from easy_init</span></a>
<a class="sourceLine" id="cb76-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb76-5" title="5"><span class="co">R: 0 on success, non-zero for error</span></a>
<a class="sourceLine" id="cb76-6" title="6"><span class="co">U: res = curl_easy_perform(curl);</span></a>
<a class="sourceLine" id="cb76-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb76-8" title="8">CURLcode curl_easy_perform( CURL * easy_handle );</a></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb77-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb77-2" title="2"><span class="co">F: Allows to request internal information from the curl session</span></a>
<a class="sourceLine" id="cb77-3" title="3"><span class="co">A: handle: CURL handle from easy_init</span></a>
<a class="sourceLine" id="cb77-4" title="4"><span class="co"> : info: address of parameters passed to allow them to be updated</span></a>
<a class="sourceLine" id="cb77-5" title="5"><span class="co">    : CURLINFO_EFFECTIVE_URL: last used effective url, char * redirect_url;</span></a>
<a class="sourceLine" id="cb77-6" title="6"><span class="co">    : CURLINFO_RESPONSE_CODE: http response code, int http_response_code;</span></a>
<a class="sourceLine" id="cb77-7" title="7"><span class="co">    : CURLINFO_PRIVATE: get private data from request, const char *szUrl;</span></a>
<a class="sourceLine" id="cb77-8" title="8"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb77-9" title="9"><span class="co">R: 0 on success, non-zero for error</span></a>
<a class="sourceLine" id="cb77-10" title="10"><span class="co">U: res = curl_easy_perform(curl);</span></a>
<a class="sourceLine" id="cb77-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb77-12" title="12">CURLcode curl_easy_getinfo( CURL *curl, CURLINFO info, ... );</a></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb78-2" title="2"><span class="co">F: global cleanup for everything curl</span></a>
<a class="sourceLine" id="cb78-3" title="3"><span class="co">A: void</span></a>
<a class="sourceLine" id="cb78-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb78-5" title="5"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb78-6" title="6"><span class="co">N: also not thread safe</span></a>
<a class="sourceLine" id="cb78-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb78-8" title="8"><span class="dt">void</span> curl_global_cleanup( <span class="dt">void</span> );</a></code></pre></div>
<div class="sourceCode" id="cb79"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb79-2" title="2"><span class="co">F: starts a libcurl MULTI session</span></a>
<a class="sourceLine" id="cb79-3" title="3"><span class="co">A: NOTHING</span></a>
<a class="sourceLine" id="cb79-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb79-5" title="5"><span class="co">R: NON-NULL CURLM handle on success, NULL on error</span></a>
<a class="sourceLine" id="cb79-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb79-7" title="7">CURLM *curl_multi_init( <span class="dt">void</span> );</a></code></pre></div>
<div class="sourceCode" id="cb80"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb80-2" title="2"><span class="co">F: Adds easy_handle to MULTI stack</span></a>
<a class="sourceLine" id="cb80-3" title="3"><span class="co">A: multi_handle from multi_init and easy_handle from easy_init</span></a>
<a class="sourceLine" id="cb80-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb80-5" title="5"><span class="co">R: CURLMcode type</span></a>
<a class="sourceLine" id="cb80-6" title="6"><span class="co">N: CURLMcode for `curl_multi_add_handle` not discussed in notes</span></a>
<a class="sourceLine" id="cb80-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb80-8" title="8">CURLMcode curl_multi_add_handle( CURLM *multi_handle, CURL *easy_handle );</a></code></pre></div>
<div class="sourceCode" id="cb81"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb81-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb81-2" title="2"><span class="co">F: Removes easy_handle to MULTI stack</span></a>
<a class="sourceLine" id="cb81-3" title="3"><span class="co">A: multi_handle from multi_init and easy_handle from easy_init</span></a>
<a class="sourceLine" id="cb81-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb81-5" title="5"><span class="co">R: CURLMcode type</span></a>
<a class="sourceLine" id="cb81-6" title="6"><span class="co">N: can be removed while performing, but will halt the actual &quot;perform&quot;</span></a>
<a class="sourceLine" id="cb81-7" title="7"><span class="co"> : CURLMcode for `curl_multi_add_handle` not discussed in notes</span></a>
<a class="sourceLine" id="cb81-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb81-9" title="9">CURLMcode curl_multi_remove_handle( CURLM *multi_handle, CURL *easy_handle );</a></code></pre></div>
<div class="sourceCode" id="cb82"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb82-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb82-2" title="2"><span class="co">F: Perform or check if data available from each easy_handle</span></a>
<a class="sourceLine" id="cb82-3" title="3"><span class="co">A: pre-configured multi_handle</span></a>
<a class="sourceLine" id="cb82-4" title="4"><span class="co"> : running_handles as an int that gets updated by reference, if 0 all done</span></a>
<a class="sourceLine" id="cb82-5" title="5"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb82-6" title="6"><span class="co">R: CURLMcode type</span></a>
<a class="sourceLine" id="cb82-7" title="7"><span class="co">N: can be called multiple times, without any restart behaviour</span></a>
<a class="sourceLine" id="cb82-8" title="8"><span class="co"> : CURLMcode for `curl_multi_perform` not discussed in notes</span></a>
<a class="sourceLine" id="cb82-9" title="9"></a>
<a class="sourceLine" id="cb82-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb82-11" title="11">CURLMcode curl_multi_perform( CURLM *multi_handle, <span class="dt">int</span> *running_handles );</a></code></pre></div>
<div class="sourceCode" id="cb83"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb83-2" title="2"><span class="co">F: Block current thread until an &quot;event&quot; occurs</span></a>
<a class="sourceLine" id="cb83-3" title="3"><span class="co">A: multi_handle: already running MULTI handle</span></a>
<a class="sourceLine" id="cb83-4" title="4"><span class="co"> : extra_fds: NULL - notes</span></a>
<a class="sourceLine" id="cb83-5" title="5"><span class="co"> : extra_nfds: 0 - notes</span></a>
<a class="sourceLine" id="cb83-6" title="6"><span class="co"> : timeout_ms: max time to wait in milliseconds</span></a>
<a class="sourceLine" id="cb83-7" title="7"><span class="co"> : numfds: gets updated by function as the number of &quot;interesting events&quot;</span></a>
<a class="sourceLine" id="cb83-8" title="8"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb83-9" title="9"><span class="co">R: Does not return until event occurs, CURLMcode type</span></a>
<a class="sourceLine" id="cb83-10" title="10"><span class="co">N: all callbacks still get executed</span></a>
<a class="sourceLine" id="cb83-11" title="11"><span class="co"> : &quot;you can ignore most of the parameters and just wait for something to happen&quot;</span></a>
<a class="sourceLine" id="cb83-12" title="12"><span class="co"> : CURLMcode for `curl_multi_wait` not discussed in notes</span></a>
<a class="sourceLine" id="cb83-13" title="13"><span class="co">*/</span></a>
<a class="sourceLine" id="cb83-14" title="14">CURLMcode curl_multi_wait(CURLM *multi_handle, <span class="kw">struct</span> curl_waitfd extra_fds[], <span class="dt">unsigned</span> <span class="dt">int</span> extra_nfds, <span class="dt">int</span> timeout_ms, <span class="dt">int</span> *numfds );</a></code></pre></div>
<div class="sourceCode" id="cb84"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb84-2" title="2"><span class="co">F: Allows to query status of easy handle</span></a>
<a class="sourceLine" id="cb84-3" title="3"><span class="co">A: multi_handle: already running MULTI handle</span></a>
<a class="sourceLine" id="cb84-4" title="4"><span class="co"> : msgs_in_queue: updated to the number of unread messages</span></a>
<a class="sourceLine" id="cb84-5" title="5"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb84-6" title="6"><span class="co">R: Does not return until event occurs, CURLMcode type</span></a>
<a class="sourceLine" id="cb84-7" title="7"><span class="co">N: Each easy handle has an associated status message as</span></a>
<a class="sourceLine" id="cb84-8" title="8"><span class="co"> : well as a return code **Why both**? Well - one is about what the status</span></a>
<a class="sourceLine" id="cb84-9" title="9"><span class="co"> : of the request is. The message could be, for example “done”, but does</span></a>
<a class="sourceLine" id="cb84-10" title="10"><span class="co"> : that mean finished with success or finished with an error?</span></a>
<a class="sourceLine" id="cb84-11" title="11"><span class="co"> : CURLMsg:</span></a>
<a class="sourceLine" id="cb84-12" title="12"><span class="co">    : CURLMSG msg: CURLMSG_DONE - request completed</span></a>
<a class="sourceLine" id="cb84-13" title="13"><span class="co">    : CURLCODE data.result: CURLE_OK if all good</span></a>
<a class="sourceLine" id="cb84-14" title="14"><span class="co">    : first check m-&gt;msg for CURLMSG_DONE, then m-&gt;data.result for all good</span></a>
<a class="sourceLine" id="cb84-15" title="15"><span class="co">*/</span></a>
<a class="sourceLine" id="cb84-16" title="16">CURLMsg *curl_multi_info_read( CURLM *multi_handle, <span class="dt">int</span> *msgs_in_queue );</a></code></pre></div>
<div class="sourceCode" id="cb85"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb85-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb85-2" title="2"><span class="co">F: Setup CURLM for select</span></a>
<a class="sourceLine" id="cb85-3" title="3"><span class="co">A: mh: that we want to select</span></a>
<a class="sourceLine" id="cb85-4" title="4"><span class="co"> : rd_fd_set: that gets modified in place with the read watch fdset</span></a>
<a class="sourceLine" id="cb85-5" title="5"><span class="co"> : wr_fd_set: that gets modified in place with the write watch fdset</span></a>
<a class="sourceLine" id="cb85-6" title="6"><span class="co"> : ex_fd_set: that gets modified in place with the exception watch fdset</span></a>
<a class="sourceLine" id="cb85-7" title="7"><span class="co"> : max_fd: that gets modified in place with the maximum file descriptor</span></a>
<a class="sourceLine" id="cb85-8" title="8"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb85-9" title="9"><span class="co">R: CURLMcode type</span></a>
<a class="sourceLine" id="cb85-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb85-11" title="11">CURLMcode curl_multi_fdset( CURLM *mh, fd_set *rd_fd_set, fd_set *wr_fd_set, fd_set *ex_fd_set, <span class="dt">int</span> *max_fd );</a></code></pre></div>
<div class="sourceCode" id="cb86"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb86-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb86-2" title="2"><span class="co">F: Return timeout from CURLM for select</span></a>
<a class="sourceLine" id="cb86-3" title="3"><span class="co">A: mh: that we want to select</span></a>
<a class="sourceLine" id="cb86-4" title="4"><span class="co"> : timeout: that we want to get the value that gets modified in place</span></a>
<a class="sourceLine" id="cb86-5" title="5"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb86-6" title="6"><span class="co">R: CURLMcode type</span></a>
<a class="sourceLine" id="cb86-7" title="7"><span class="co">U: struct timeval timeout;</span></a>
<a class="sourceLine" id="cb86-8" title="8"><span class="co"> : long timeo;</span></a>
<a class="sourceLine" id="cb86-9" title="9"><span class="co"> :</span></a>
<a class="sourceLine" id="cb86-10" title="10"><span class="co"> : curl_multi_timeout( cm, &amp;timeo );</span></a>
<a class="sourceLine" id="cb86-11" title="11"><span class="co"> : if(timeo &lt; 0) {</span></a>
<a class="sourceLine" id="cb86-12" title="12"><span class="co"> :   // no set timeout, use a default</span></a>
<a class="sourceLine" id="cb86-13" title="13"><span class="co"> :   timeo = 980;</span></a>
<a class="sourceLine" id="cb86-14" title="14"><span class="co"> : }</span></a>
<a class="sourceLine" id="cb86-15" title="15"><span class="co"> :</span></a>
<a class="sourceLine" id="cb86-16" title="16"><span class="co"> : timeout.tv_sec = timeo / 1000;</span></a>
<a class="sourceLine" id="cb86-17" title="17"><span class="co"> : timeout.tv_usec = (timeo % 1000) * 1000;</span></a>
<a class="sourceLine" id="cb86-18" title="18"><span class="co">*/</span></a>
<a class="sourceLine" id="cb86-19" title="19">CURLMcode curl_multi_timeout( CURLM *multi_handle, <span class="dt">long</span> *timeout );</a></code></pre></div>
<div class="sourceCode" id="cb87"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb87-2" title="2"><span class="co">F: Cleans up and removes a whole MULTI stack</span></a>
<a class="sourceLine" id="cb87-3" title="3"><span class="co">A: multi_handle from multi_init</span></a>
<a class="sourceLine" id="cb87-4" title="4"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb87-5" title="5"><span class="co">R: CURLMcode return value, libcurl error otherwise</span></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="co">N: handles must be removed and cleaned up before calling multi_cleanup</span></a>
<a class="sourceLine" id="cb87-7" title="7"><span class="co"> : CURLMcode for `curl_multi_cleanup` not discussed in notes</span></a>
<a class="sourceLine" id="cb87-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb87-9" title="9">CURLMcode curl_multi_cleanup( CURLM *multi_handle );</a></code></pre></div>
<div class="sourceCode" id="cb88"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb88-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb88-2" title="2"><span class="co">F: Write callback for a curl request</span></a>
<a class="sourceLine" id="cb88-3" title="3"><span class="co">A: ptr: points to whatever data we recieved</span></a>
<a class="sourceLine" id="cb88-4" title="4"><span class="co"> : size: ALWAYS 1</span></a>
<a class="sourceLine" id="cb88-5" title="5"><span class="co"> : nmemb: size of the data we recieved</span></a>
<a class="sourceLine" id="cb88-6" title="6"><span class="co"> : userdata: we can pass in some of our own data here</span></a>
<a class="sourceLine" id="cb88-7" title="7"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb88-8" title="8"><span class="co">R: the spec requires that size_t returns equal the number of bytes</span></a>
<a class="sourceLine" id="cb88-9" title="9"><span class="co"> : processed, otherwise its considered an error</span></a>
<a class="sourceLine" id="cb88-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb88-11" title="11"><span class="dt">size_t</span> write_callback( <span class="dt">char</span> *ptr, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nmemb, <span class="dt">void</span> *userdata );</a></code></pre></div>
<div class="sourceCode" id="cb89"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb89-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb89-2" title="2"><span class="co">F: Read callback for a curl request</span></a>
<a class="sourceLine" id="cb89-3" title="3"><span class="co">A: buffer: area where you put the data to send</span></a>
<a class="sourceLine" id="cb89-4" title="4"><span class="co"> : size: size of each item</span></a>
<a class="sourceLine" id="cb89-5" title="5"><span class="co"> : nitems: number of items</span></a>
<a class="sourceLine" id="cb89-6" title="6"><span class="co"> : inputdata: we can pass in some of our own data here</span></a>
<a class="sourceLine" id="cb89-7" title="7"><span class="co">H: &lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb89-8" title="8"><span class="co">R: number of bytes sucessfully put,</span></a>
<a class="sourceLine" id="cb89-9" title="9"><span class="co"> : 0 signals EOF, and no more uploads will occur</span></a>
<a class="sourceLine" id="cb89-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb89-11" title="11"><span class="dt">size_t</span> read_callback( <span class="dt">char</span> *buffer, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nitems, <span class="dt">void</span> *inputdata );</a></code></pre></div>
<h2 id="threads-and-concurrency">Threads and Concurrency</h2>
<div class="sourceCode" id="cb90"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb90-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb90-2" title="2"><span class="co">F: Create a new thread</span></a>
<a class="sourceLine" id="cb90-3" title="3"><span class="co">A: thread: pthread identifier for the new thread</span></a>
<a class="sourceLine" id="cb90-4" title="4"><span class="co"> : attr: NULL - notes</span></a>
<a class="sourceLine" id="cb90-5" title="5"><span class="co"> : start_routine: function that is called</span></a>
<a class="sourceLine" id="cb90-6" title="6"><span class="co"> : arg: argument for start_routine</span></a>
<a class="sourceLine" id="cb90-7" title="7"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb90-8" title="8"><span class="co">R: 0 on error, some error code on error and *thread is undefined</span></a>
<a class="sourceLine" id="cb90-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb90-10" title="10">pthread_create( pthread_t *thread, <span class="dt">const</span> pthread_attr_t *attr, <span class="dt">void</span> *(*start_routine)( <span class="dt">void</span> * ), <span class="dt">void</span> *arg );</a></code></pre></div>
<div class="sourceCode" id="cb91"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb91-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb91-2" title="2"><span class="co">F: Thread functions - start_routine</span></a>
<a class="sourceLine" id="cb91-3" title="3"><span class="co">A: start_params: void pointer to the arguments</span></a>
<a class="sourceLine" id="cb91-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb91-5" title="5"><span class="co">R: untyped pointer, can be anything</span></a>
<a class="sourceLine" id="cb91-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb91-7" title="7"><span class="dt">void</span>* do_something( <span class="dt">void</span>* start_params )</a></code></pre></div>
<div class="sourceCode" id="cb92"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb92-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb92-2" title="2"><span class="co">F: Initialise attributes</span></a>
<a class="sourceLine" id="cb92-3" title="3"><span class="co">A: attr: address of pthread_attr_t to be setup with default values</span></a>
<a class="sourceLine" id="cb92-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb92-5" title="5"><span class="co">R: attr is setup by reference, 0 on error, non-zero on error</span></a>
<a class="sourceLine" id="cb92-6" title="6"><span class="co">N: Can be passed on to pthread_create as attr</span></a>
<a class="sourceLine" id="cb92-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb92-8" title="8"><span class="dt">int</span> pthread_attr_init(pthread_attr_t *attr);</a></code></pre></div>
<div class="sourceCode" id="cb93"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb93-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb93-2" title="2"><span class="co">F: Destroy attributes and free up memory</span></a>
<a class="sourceLine" id="cb93-3" title="3"><span class="co">A: attr: to be destroyed</span></a>
<a class="sourceLine" id="cb93-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb93-5" title="5"><span class="co">R: attr is destroyed by reference, 0 on error, non-zero on error</span></a>
<a class="sourceLine" id="cb93-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb93-7" title="7"><span class="dt">int</span> pthread_attr_destroy(pthread_attr_t *attr);</a></code></pre></div>
<div class="sourceCode" id="cb94"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb94-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb94-2" title="2"><span class="co">F: Wait until thread finishes</span></a>
<a class="sourceLine" id="cb94-3" title="3"><span class="co">A: thread: to wait for</span></a>
<a class="sourceLine" id="cb94-4" title="4"><span class="co"> : returnValue: we are going to supply a pointer that the join function  </span></a>
<a class="sourceLine" id="cb94-5" title="5"><span class="co"> :              will update</span></a>
<a class="sourceLine" id="cb94-6" title="6"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb94-7" title="7"><span class="co">R: UNKNOWN</span></a>
<a class="sourceLine" id="cb94-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb94-9" title="9">pthread_join( pthread_t thread, <span class="dt">void</span> **returnValue );</a></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb95-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb95-2" title="2"><span class="co">F: Detach thread from creating parent such that it cannot be joined on</span></a>
<a class="sourceLine" id="cb95-3" title="3"><span class="co">A: thread: to detach</span></a>
<a class="sourceLine" id="cb95-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb95-5" title="5"><span class="co">R: UNKNOWN</span></a>
<a class="sourceLine" id="cb95-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb95-7" title="7">pthread_detach( pthread_t thread );</a></code></pre></div>
<div class="sourceCode" id="cb96"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb96-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb96-2" title="2"><span class="co">F: Send a cancellation request to thread</span></a>
<a class="sourceLine" id="cb96-3" title="3"><span class="co">A: thread: to cancel</span></a>
<a class="sourceLine" id="cb96-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb96-5" title="5"><span class="co">R: UNKNOWN</span></a>
<a class="sourceLine" id="cb96-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb96-7" title="7">pthread_cancel( pthread_t thread );</a></code></pre></div>
<div class="sourceCode" id="cb97"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb97-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb97-2" title="2"><span class="co">F: Set cancellation type on calling thread</span></a>
<a class="sourceLine" id="cb97-3" title="3"><span class="co">A: type: new type that we want to set to</span></a>
<a class="sourceLine" id="cb97-4" title="4"><span class="co">       : PTHREAD_CANCEL_DEFERRED: default, acted on immediately</span></a>
<a class="sourceLine" id="cb97-5" title="5"><span class="co">       : PTHREAD_CANCEL_ASYNCHRONOUS: thread responsible for checking</span></a>
<a class="sourceLine" id="cb97-6" title="6"><span class="co"> : oldtype: argument updated with old type, we might not care</span></a>
<a class="sourceLine" id="cb97-7" title="7"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb97-8" title="8"><span class="co">R: int: 0 on sucess, on error: non zero error number</span></a>
<a class="sourceLine" id="cb97-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb97-10" title="10">pthread_setcanceltype( <span class="dt">int</span> type, <span class="dt">int</span> *oldtype );</a></code></pre></div>
<div class="sourceCode" id="cb98"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb98-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb98-2" title="2"><span class="co">F: Test to see if calling thread is cancelled by parent</span></a>
<a class="sourceLine" id="cb98-3" title="3"><span class="co">A: void</span></a>
<a class="sourceLine" id="cb98-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb98-5" title="5"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb98-6" title="6"><span class="co">N: If it is indeed cancelled, the thread will quit then,</span></a>
<a class="sourceLine" id="cb98-7" title="7"><span class="co"> : calling any cleanup handlers if necessary</span></a>
<a class="sourceLine" id="cb98-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb98-9" title="9">pthread_testcancel( );</a></code></pre></div>
<div class="sourceCode" id="cb99"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb99-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb99-2" title="2"><span class="co">F: Add cleanup handler to top of cleanup stack</span></a>
<a class="sourceLine" id="cb99-3" title="3"><span class="co">A: routine: called when thread is cancelled, or pthread_exit (not return)</span></a>
<a class="sourceLine" id="cb99-4" title="4"><span class="co"> : arg: arguments to be passed to routine when called</span></a>
<a class="sourceLine" id="cb99-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb99-6" title="6"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb99-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb99-8" title="8">pthread_cleanup_push( <span class="dt">void</span> (*routine)(<span class="dt">void</span>*), <span class="dt">void</span> *argument );</a></code></pre></div>
<div class="sourceCode" id="cb100"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb100-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb100-2" title="2"><span class="co">F: Remove cleanup handler from top of stack</span></a>
<a class="sourceLine" id="cb100-3" title="3"><span class="co">A: execute: if execute is non zero, routine is executed and popped</span></a>
<a class="sourceLine" id="cb100-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb100-5" title="5"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb100-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb100-7" title="7">pthread_cleanup_pop( <span class="dt">int</span> execute );</a></code></pre></div>
<div class="sourceCode" id="cb101"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb101-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb101-2" title="2"><span class="co">F: Terminate calling thread with value</span></a>
<a class="sourceLine" id="cb101-3" title="3"><span class="co">A: Value will be sent back to the parent thread</span></a>
<a class="sourceLine" id="cb101-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb101-5" title="5"><span class="co">R: UNKNOWN</span></a>
<a class="sourceLine" id="cb101-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb101-7" title="7">pthread_exit( <span class="dt">void</span> *value );</a></code></pre></div>
<div class="sourceCode" id="cb102"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb102-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb102-2" title="2"><span class="co">F: Initialies mutex with attributes</span></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="co">A: mutex: to initialize</span></a>
<a class="sourceLine" id="cb102-4" title="4"><span class="co"> : attr: NULL - notes</span></a>
<a class="sourceLine" id="cb102-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb102-6" title="6"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb102-7" title="7"><span class="co">N: `pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;`</span></a>
<a class="sourceLine" id="cb102-8" title="8"><span class="co"> : If attributes were initialised with pthread_mutexattr_init</span></a>
<a class="sourceLine" id="cb102-9" title="9"><span class="co"> : then they have to be destroyed with pthread_mutexattr_destroy</span></a>
<a class="sourceLine" id="cb102-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb102-11" title="11">pthread_mutex_init( pthread_mutex_t *mutex, pthread_mutexattr_t *attributes );</a></code></pre></div>
<div class="sourceCode" id="cb103"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb103-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb103-2" title="2"><span class="co">F: Lock mutex for no other thread to use</span></a>
<a class="sourceLine" id="cb103-3" title="3"><span class="co">A: mutex: to lock</span></a>
<a class="sourceLine" id="cb103-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb103-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb103-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb103-7" title="7">pthread_mutex_lock( pthread_mutex_t *mutex );</a></code></pre></div>
<div class="sourceCode" id="cb104"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb104-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb104-2" title="2"><span class="co">F: Non-blocking mutex locking</span></a>
<a class="sourceLine" id="cb104-3" title="3"><span class="co">A: mutex: to try locking</span></a>
<a class="sourceLine" id="cb104-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb104-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb104-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb104-7" title="7">pthread_mutex_trylock( pthread_mutex_t *mutex );</a></code></pre></div>
<div class="sourceCode" id="cb105"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb105-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb105-2" title="2"><span class="co">F: Unlock mutex for another thread to use</span></a>
<a class="sourceLine" id="cb105-3" title="3"><span class="co">A: mutex: to unlock</span></a>
<a class="sourceLine" id="cb105-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb105-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb105-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb105-7" title="7">pthread_mutex_unlock( pthread_mutex_t *mutex );</a></code></pre></div>
<div class="sourceCode" id="cb106"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb106-1" title="1">```C</a>
<a class="sourceLine" id="cb106-2" title="2"><span class="co">/*</span></a>
<a class="sourceLine" id="cb106-3" title="3"><span class="co">F: Destroy mutex</span></a>
<a class="sourceLine" id="cb106-4" title="4"><span class="co">A: mutex: to destroy</span></a>
<a class="sourceLine" id="cb106-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb106-6" title="6"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb106-7" title="7"><span class="co">N: destroying a locked mutex is undefined behaviour</span></a>
<a class="sourceLine" id="cb106-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb106-9" title="9">pthread_mutex_destroy( pthread_mutex_t *mutex );</a></code></pre></div>
<div class="sourceCode" id="cb107"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb107-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb107-2" title="2"><span class="co">F: Initialies rwlock with attributes</span></a>
<a class="sourceLine" id="cb107-3" title="3"><span class="co">A: rwlock: to initialize</span></a>
<a class="sourceLine" id="cb107-4" title="4"><span class="co"> : attr: NULL - notes</span></a>
<a class="sourceLine" id="cb107-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb107-6" title="6"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb107-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb107-8" title="8">pthread_rwlock_init( pthread_rwlock_t * rwlock, pthread_rwlockattr_t * attr );</a></code></pre></div>
<div class="sourceCode" id="cb108"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb108-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb108-2" title="2"><span class="co">F: Apply a read lock</span></a>
<a class="sourceLine" id="cb108-3" title="3"><span class="co">A: rwlock: to lock for read</span></a>
<a class="sourceLine" id="cb108-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb108-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb108-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb108-7" title="7">pthread_rwlock_rdlock( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb109"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb109-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb109-2" title="2"><span class="co">F: lock a read-write lock for reading</span></a>
<a class="sourceLine" id="cb109-3" title="3"><span class="co">A: rwlock: to lock for read</span></a>
<a class="sourceLine" id="cb109-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb109-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb109-6" title="6"><span class="co">N: function will fail if the equivalent call would have</span></a>
<a class="sourceLine" id="cb109-7" title="7"><span class="co"> : blocked the calling thread</span></a>
<a class="sourceLine" id="cb109-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb109-9" title="9">pthread_rwlock_tryrdlock( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb110"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb110-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb110-2" title="2"><span class="co">F: lock a read-write lock object for writing</span></a>
<a class="sourceLine" id="cb110-3" title="3"><span class="co">A: rwlock: to lock for write</span></a>
<a class="sourceLine" id="cb110-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb110-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb110-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb110-7" title="7">pthread_rwlock_wrlock( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb111"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb111-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb111-2" title="2"><span class="co">F: lock a read-write lock object for writing</span></a>
<a class="sourceLine" id="cb111-3" title="3"><span class="co">A: rwlock: to lock for write</span></a>
<a class="sourceLine" id="cb111-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb111-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb111-6" title="6"><span class="co">N: function will fail if the equivalent call would have</span></a>
<a class="sourceLine" id="cb111-7" title="7"><span class="co"> : blocked the calling thread</span></a>
<a class="sourceLine" id="cb111-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb111-9" title="9">pthread_rwlock_trywrlock( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb112"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb112-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb112-2" title="2"><span class="co">F: unlock a read-write lock</span></a>
<a class="sourceLine" id="cb112-3" title="3"><span class="co">A: rwlock: to unlock</span></a>
<a class="sourceLine" id="cb112-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb112-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb112-6" title="6"><span class="co">N: Results are undefined if the read-write lock rwlock</span></a>
<a class="sourceLine" id="cb112-7" title="7"><span class="co"> : is not held by the calling thread</span></a>
<a class="sourceLine" id="cb112-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb112-9" title="9">pthread_rwlock_unlock( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb113"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb113-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb113-2" title="2"><span class="co">F: Destroy rwlock and release any resources</span></a>
<a class="sourceLine" id="cb113-3" title="3"><span class="co">A: rwlock: to destroy</span></a>
<a class="sourceLine" id="cb113-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb113-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb113-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb113-7" title="7">pthread_rwlock_destroy( pthread_rwlock_t * rwlock );</a></code></pre></div>
<div class="sourceCode" id="cb114"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb114-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb114-2" title="2"><span class="co">F: Initialise a semaphore</span></a>
<a class="sourceLine" id="cb114-3" title="3"><span class="co">A: semaphore: to be initalised</span></a>
<a class="sourceLine" id="cb114-4" title="4"><span class="co"> : shared: 1 for shared b/w processes</span></a>
<a class="sourceLine" id="cb114-5" title="5"><span class="co"> : initial_value: number of threads that can be unblocked at the same time</span></a>
<a class="sourceLine" id="cb114-6" title="6"><span class="co">H: &lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb114-7" title="7"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb114-8" title="8"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb114-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb114-10" title="10">sem_init( sem_t* semaphore, <span class="dt">int</span> shared, <span class="dt">int</span> initial_value);</a></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb115-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb115-2" title="2"><span class="co">F: Initialise a semaphore</span></a>
<a class="sourceLine" id="cb115-3" title="3"><span class="co">A: semaphore: to be destroyed</span></a>
<a class="sourceLine" id="cb115-4" title="4"><span class="co">H: &lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb115-5" title="5"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb115-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb115-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb115-8" title="8">sem_destroy( sem_t* semaphore );</a></code></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb116-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb116-2" title="2"><span class="co">F: Decrements the semaphore</span></a>
<a class="sourceLine" id="cb116-3" title="3"><span class="co">A: semaphore: to be waited on</span></a>
<a class="sourceLine" id="cb116-4" title="4"><span class="co">H: &lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb116-5" title="5"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb116-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb116-7" title="7"><span class="co">N: if the semaphore&#39;s value is greater than zero then the decrement</span></a>
<a class="sourceLine" id="cb116-8" title="8"><span class="co"> : proceeds and the function returns, otherwise it blocks</span></a>
<a class="sourceLine" id="cb116-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb116-10" title="10">sem_wait( sem_t* semaphore );</a></code></pre></div>
<div class="sourceCode" id="cb117"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb117-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb117-2" title="2"><span class="co">F: Same as sem_wait except it returns error if decrement cannot be done</span></a>
<a class="sourceLine" id="cb117-3" title="3"><span class="co">A: semaphore: to be tried to wait on</span></a>
<a class="sourceLine" id="cb117-4" title="4"><span class="co">H: &lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb117-5" title="5"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb117-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb117-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb117-8" title="8">sem_trywait( semt_t* semaphore );</a></code></pre></div>
<div class="sourceCode" id="cb118"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb118-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb118-2" title="2"><span class="co">F: Increments the semaphore</span></a>
<a class="sourceLine" id="cb118-3" title="3"><span class="co">A: semaphore: to be incremented</span></a>
<a class="sourceLine" id="cb118-4" title="4"><span class="co">H: &lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb118-5" title="5"><span class="co">R: 0 on success, -1 on error</span></a>
<a class="sourceLine" id="cb118-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb118-7" title="7"><span class="co">N: If the semaphore&#39;s value becomes greater than zero, then</span></a>
<a class="sourceLine" id="cb118-8" title="8"><span class="co"> : another process or thread blocked in a sem_wait call will be woken</span></a>
<a class="sourceLine" id="cb118-9" title="9"><span class="co"> : up and proceed to lock the semaphore.</span></a>
<a class="sourceLine" id="cb118-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb118-11" title="11">sem_post( sem_t* semaphore );</a></code></pre></div>
<div class="sourceCode" id="cb119"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb119-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb119-2" title="2"><span class="co">F: Initialies cv with attributes</span></a>
<a class="sourceLine" id="cb119-3" title="3"><span class="co">A: cv: to initialize</span></a>
<a class="sourceLine" id="cb119-4" title="4"><span class="co"> : attr: NULL - notes</span></a>
<a class="sourceLine" id="cb119-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb119-6" title="6"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb119-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb119-8" title="8">pthread_cond_init( pthread_cond_t *cv, pthread_condattr_t *attr );</a></code></pre></div>
<div class="sourceCode" id="cb120"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb120-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb120-2" title="2"><span class="co">F: Wait on condition</span></a>
<a class="sourceLine" id="cb120-3" title="3"><span class="co">A: cv: to initialize</span></a>
<a class="sourceLine" id="cb120-4" title="4"><span class="co"> : mutex: mutex to be used for waiting</span></a>
<a class="sourceLine" id="cb120-5" title="5"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb120-6" title="6"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb120-7" title="7"><span class="co">N: routine should be called only while the mutex is locked</span></a>
<a class="sourceLine" id="cb120-8" title="8"><span class="co"> : mutex is unlocked while condition is not satisfied</span></a>
<a class="sourceLine" id="cb120-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb120-10" title="10">pthread_cond_wait( pthread_cond_t *cv, pthread_mutex_t *mutex );</a></code></pre></div>
<div class="sourceCode" id="cb121"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb121-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb121-2" title="2"><span class="co">F: Signal on condition variable</span></a>
<a class="sourceLine" id="cb121-3" title="3"><span class="co">A: cv: to initialize</span></a>
<a class="sourceLine" id="cb121-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb121-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb121-6" title="6"><span class="co">N: routine should be called only while the mutex is locked</span></a>
<a class="sourceLine" id="cb121-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb121-8" title="8">pthread_cond_signal( pthread_cond_t *cv );</a></code></pre></div>
<div class="sourceCode" id="cb122"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb122-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb122-2" title="2"><span class="co">F: Signal on ALL waiting threads</span></a>
<a class="sourceLine" id="cb122-3" title="3"><span class="co">A: cv: to initialize</span></a>
<a class="sourceLine" id="cb122-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb122-5" title="5"><span class="co">R: 0 on success, non-zero error code on error</span></a>
<a class="sourceLine" id="cb122-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb122-7" title="7">pthread_cond_broadcast( pthread_cond_t *cv );</a></code></pre></div>
<div class="sourceCode" id="cb123"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb123-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb123-2" title="2"><span class="co">F: Destroy condition variable and release any resources</span></a>
<a class="sourceLine" id="cb123-3" title="3"><span class="co">A: cv: to destroy</span></a>
<a class="sourceLine" id="cb123-4" title="4"><span class="co">H: &lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb123-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb123-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb123-7" title="7">pthread_cond_destroy( pthread_cond_t *cv );</a></code></pre></div>
<h4 id="spinlock">Spinlock</h4>
<p>Another common technique for protecting a critical section in Linux is the spinlock. This is a handy way to implement constant checking to acquire a lock. Unlike semaphores where the process is blocked if it fails to acquire the lock, a thread will constantly try to acquire the lock.</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb124-1" title="1">spin_lock( &amp;lock )</a>
<a class="sourceLine" id="cb124-2" title="2"><span class="co">/* Critical Section */</span></a>
<a class="sourceLine" id="cb124-3" title="3">spin_unlock( &amp;lock )</a></code></pre></div>
<h3 id="atomic-types">Atomic Types</h3>
<p>Atomic operations are defined on integral or pointer types of length 1, 2, 4, or 8; replace type with that type.</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb125-1" title="1">type __sync_lock_test_and_set( type *ptr, type value );</a>
<a class="sourceLine" id="cb125-2" title="2"></a>
<a class="sourceLine" id="cb125-3" title="3"><span class="dt">bool</span> __sync_bool_compare_and_swap( type *ptr, type oldval, type newval );</a></code></pre></div>
<div class="sourceCode" id="cb126"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb126-1" title="1">type __sync_val_compare_and_swap( type *ptr, type oldval, type newval );</a></code></pre></div>
<p>The following functions perform the operation and return the old value:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb127-1" title="1">type __sync_fetch_and_add( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb128"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb128-1" title="1">type __sync_fetch_and_sub( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb129"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb129-1" title="1">type __sync_fetch_and_or( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb130"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb130-1" title="1">type __sync_fetch_and_and( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb131-1" title="1">type __sync_fetch_and_xor( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb132"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb132-1" title="1">type __sync_fetch_and_nand( type *ptr, type value );</a></code></pre></div>
<p>The following functions perform the operation and return the new value:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb133-1" title="1">type __sync_add_and_fetch( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb134"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb134-1" title="1">type __sync_sub_and_fetch( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb135"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb135-1" title="1">type __sync_or_and_fetch( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb136"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb136-1" title="1">type __sync_and_and_fetch( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb137"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb137-1" title="1">type __sync_xor_and_fetch( type *ptr, type value );</a></code></pre></div>
<div class="sourceCode" id="cb138"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb138-1" title="1">type __sync_nand_and_fetch( type *ptr, type value );</a></code></pre></div>
<h2 id="select-poll-aio-libevent">Select, Poll, AIO, <code>Libevent</code></h2>
<div class="sourceCode" id="cb139"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb139-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb139-2" title="2"><span class="co">F: Efficiently monitor multiple file descriptors</span></a>
<a class="sourceLine" id="cb139-3" title="3"><span class="co">A: nfds: maximum file descriptor + 1</span></a>
<a class="sourceLine" id="cb139-4" title="4"><span class="co"> : readfds: watched to see if any of fds are ready to read</span></a>
<a class="sourceLine" id="cb139-5" title="5"><span class="co"> : writefds: watched to see if any of fds are ready to write to</span></a>
<a class="sourceLine" id="cb139-6" title="6"><span class="co"> : exceptfds: watched to see for &quot;exceptional conditions&quot;</span></a>
<a class="sourceLine" id="cb139-7" title="7"><span class="co"> : timeout: longest time select waits before returning</span></a>
<a class="sourceLine" id="cb139-8" title="8"><span class="co">H: &lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb139-9" title="9"><span class="co">R: when select returns, all readfds not ready will be cleared, all  </span></a>
<a class="sourceLine" id="cb139-10" title="10"><span class="co"> : writefds not ready will be cleared</span></a>
<a class="sourceLine" id="cb139-11" title="11"><span class="co"> : on return, you have to go through all of the fd&#39;s to check if they&#39;re</span></a>
<a class="sourceLine" id="cb139-12" title="12"><span class="co"> : ready, using FD_ISSET</span></a>
<a class="sourceLine" id="cb139-13" title="13"><span class="co"> : -1 on ERROR, and</span></a>
<a class="sourceLine" id="cb139-14" title="14"><span class="co">E: errno is set</span></a>
<a class="sourceLine" id="cb139-15" title="15"><span class="co">N: can be used to create a fairly accurate timer by giving null to all</span></a>
<a class="sourceLine" id="cb139-16" title="16"><span class="co"> : the parameters and setting just a timeout</span></a>
<a class="sourceLine" id="cb139-17" title="17"><span class="co">*/</span></a>
<a class="sourceLine" id="cb139-18" title="18"><span class="dt">int</span> select( <span class="dt">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="kw">struct</span> timeval *timeout );</a></code></pre></div>
<div class="sourceCode" id="cb140"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb140-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb140-2" title="2"><span class="co">F: Initialise and clear the set</span></a>
<a class="sourceLine" id="cb140-3" title="3"><span class="co">A: set: to clear</span></a>
<a class="sourceLine" id="cb140-4" title="4"><span class="co">H: &lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb140-5" title="5"><span class="co">R: 0 on success, non-zero on error</span></a>
<a class="sourceLine" id="cb140-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb140-7" title="7"><span class="dt">void</span> FD_ZERO( fd_set *set );</a></code></pre></div>
<div class="sourceCode" id="cb141"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb141-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb141-2" title="2"><span class="co">F: Add file descriptor to set</span></a>
<a class="sourceLine" id="cb141-3" title="3"><span class="co">A: set: to add to</span></a>
<a class="sourceLine" id="cb141-4" title="4"><span class="co"> :  fd: to add</span></a>
<a class="sourceLine" id="cb141-5" title="5"><span class="co">H: &lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb141-6" title="6"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb141-7" title="7"><span class="co">N: An fd_set can have up to 1024 file descriptors</span></a>
<a class="sourceLine" id="cb141-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb141-9" title="9"><span class="dt">void</span> FD_SET( <span class="dt">int</span> fd, fd_set *set );</a></code></pre></div>
<div class="sourceCode" id="cb142"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb142-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb142-2" title="2"><span class="co">F: Remove file descriptor from set</span></a>
<a class="sourceLine" id="cb142-3" title="3"><span class="co">A: set: to add to</span></a>
<a class="sourceLine" id="cb142-4" title="4"><span class="co"> :  fd: to remove</span></a>
<a class="sourceLine" id="cb142-5" title="5"><span class="co">H: &lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb142-6" title="6"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb142-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb142-8" title="8"><span class="dt">void</span> FD_CLR( <span class="dt">int</span> fd, fd_set *set );</a></code></pre></div>
<div class="sourceCode" id="cb143"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb143-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb143-2" title="2"><span class="co">F: Test if file descriptor in set</span></a>
<a class="sourceLine" id="cb143-3" title="3"><span class="co">A: set: to add to</span></a>
<a class="sourceLine" id="cb143-4" title="4"><span class="co"> :  fd: to check</span></a>
<a class="sourceLine" id="cb143-5" title="5"><span class="co">H: &lt;sys/select.h&gt;</span></a>
<a class="sourceLine" id="cb143-6" title="6"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb143-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb143-8" title="8"><span class="dt">int</span> FD_ISSET( <span class="dt">int</span> fd, fd_set *set ); <span class="co">/* Tests if fd is a part of the set */</span></a></code></pre></div>
<div class="sourceCode" id="cb144"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb144-1" title="1"><span class="kw">struct</span> timeval {</a>
<a class="sourceLine" id="cb144-2" title="2">  <span class="dt">long</span> tv_sec; <span class="co">// seconds</span></a>
<a class="sourceLine" id="cb144-3" title="3">  <span class="dt">long</span> tv_usec; <span class="co">// microseconds</span></a>
<a class="sourceLine" id="cb144-4" title="4">};</a></code></pre></div>
<div class="sourceCode" id="cb145"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb145-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb145-2" title="2"><span class="co">F: Literally select but with a different timeout paramter in nanoseconds insteaf of microseconds</span></a>
<a class="sourceLine" id="cb145-3" title="3"><span class="co">A: mask: to atomically set the signal mask when we are also waiting for signals.</span></a>
<a class="sourceLine" id="cb145-4" title="4"><span class="co">       : mask can be NULL and no change will be made to the signal mask</span></a>
<a class="sourceLine" id="cb145-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb145-6" title="6"><span class="dt">int</span> pselect( <span class="dt">int</span> nfds, fd_set *rd, fd_set *wr, fd_set *ex, <span class="dt">const</span> <span class="kw">struct</span> timespec *to, <span class="dt">const</span> sigset_t *mask );</a></code></pre></div>
<div class="sourceCode" id="cb146"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb146-1" title="1"><span class="kw">struct</span> timespec {</a>
<a class="sourceLine" id="cb146-2" title="2">  <span class="dt">long</span> tv_sec; <span class="co">// seconds</span></a>
<a class="sourceLine" id="cb146-3" title="3">  <span class="dt">long</span> tv_nsec; <span class="co">// nanoseconds</span></a>
<a class="sourceLine" id="cb146-4" title="4">};</a></code></pre></div>
<div class="sourceCode" id="cb147"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb147-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb147-2" title="2"><span class="co">F: Efficiently monitor multiple sockets</span></a>
<a class="sourceLine" id="cb147-3" title="3"><span class="co">A: fds: array of sockets we want to monitor</span></a>
<a class="sourceLine" id="cb147-4" title="4"><span class="co"> : nfds: number of items in the array</span></a>
<a class="sourceLine" id="cb147-5" title="5"><span class="co"> : timeout: in milliseconds</span></a>
<a class="sourceLine" id="cb147-6" title="6"><span class="co">H: &lt;poll.h&gt;</span></a>
<a class="sourceLine" id="cb147-7" title="7"><span class="co">R: when poll returns, we will have to check each of the sockets to see if</span></a>
<a class="sourceLine" id="cb147-8" title="8"><span class="co"> : their corresponding revents are ready by doing a logical &quot;AND&quot;:</span></a>
<a class="sourceLine" id="cb147-9" title="9"><span class="co"> : fds[0].revents &amp; POLLIN</span></a>
<a class="sourceLine" id="cb147-10" title="10"><span class="co"> : number of structures with revents, -1 on error with errno</span></a>
<a class="sourceLine" id="cb147-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb147-12" title="12"><span class="dt">int</span> poll( <span class="kw">struct</span> pollfd *fds, nfds_t nfds, <span class="dt">int</span> timeout );</a></code></pre></div>
<div class="sourceCode" id="cb148"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb148-1" title="1"><span class="kw">struct</span> pollfd {</a>
<a class="sourceLine" id="cb148-2" title="2">  <span class="dt">int</span> fd; <span class="co">// file descriptor</span></a>
<a class="sourceLine" id="cb148-3" title="3">  <span class="dt">short</span> events; <span class="co">// requested events</span></a>
<a class="sourceLine" id="cb148-4" title="4">  <span class="dt">short</span> revents; <span class="co">// returned events</span></a>
<a class="sourceLine" id="cb148-5" title="5">};</a></code></pre></div>
<div class="sourceCode" id="cb149"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb149-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb149-2" title="2"><span class="co">H: &lt;aiocb.h&gt;</span></a>
<a class="sourceLine" id="cb149-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb149-4" title="4"><span class="kw">struct</span> aiocb {</a>
<a class="sourceLine" id="cb149-5" title="5">  <span class="dt">int</span> aio_fildes; <span class="co">// file descriptor</span></a>
<a class="sourceLine" id="cb149-6" title="6">  off_t aio_offset; <span class="co">// offset for I/O</span></a>
<a class="sourceLine" id="cb149-7" title="7">  <span class="dt">volatile</span> <span class="dt">void</span>* aio_buf; <span class="co">// Buffer</span></a>
<a class="sourceLine" id="cb149-8" title="8">  <span class="dt">size_t</span> aio_nbytes; <span class="co">// Number of bytes to transfer</span></a>
<a class="sourceLine" id="cb149-9" title="9">  <span class="dt">int</span> aio_reqprio; <span class="co">// Request priority</span></a>
<a class="sourceLine" id="cb149-10" title="10">  <span class="kw">struct</span> sigevent aio_sigevent; <span class="co">// Signal Info</span></a>
<a class="sourceLine" id="cb149-11" title="11">  <span class="dt">int</span> aio_lio_opcode; <span class="co">// Operation for List I/O</span></a>
<a class="sourceLine" id="cb149-12" title="12">};</a></code></pre></div>
<div class="sourceCode" id="cb150"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb150-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb150-2" title="2"><span class="co">A: sigev_notify can be one of:</span></a>
<a class="sourceLine" id="cb150-3" title="3"><span class="co">                : SIGEV_NONE: Don’t do anything</span></a>
<a class="sourceLine" id="cb150-4" title="4"><span class="co">                : SIGEV_SIGNAL: sigev_signo is gnerated</span></a>
<a class="sourceLine" id="cb150-5" title="5"><span class="co">                : SIGEV_THREAD: sigev_notify_function starts with sigev_notify_attributes and uses the sigval signal_ptr as arguments</span></a>
<a class="sourceLine" id="cb150-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb150-7" title="7"><span class="kw">struct</span> sigevent {</a>
<a class="sourceLine" id="cb150-8" title="8">  <span class="dt">int</span> sigev_notify; <span class="co">// Notify Type</span></a>
<a class="sourceLine" id="cb150-9" title="9">  <span class="dt">int</span> sigev_signo; <span class="co">// Signal number</span></a>
<a class="sourceLine" id="cb150-10" title="10">  <span class="kw">union</span> sigval sigev_value; <span class="co">// Notify argument</span></a>
<a class="sourceLine" id="cb150-11" title="11">  <span class="dt">void</span>* (* sigev_notify_function) (<span class="kw">union</span> sigval); <span class="co">// Notify Function</span></a>
<a class="sourceLine" id="cb150-12" title="12">  pthread_attr_t * sigev_notify_attributes; <span class="co">// Notify attributes</span></a>
<a class="sourceLine" id="cb150-13" title="13">};</a></code></pre></div>
<div class="sourceCode" id="cb151"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb151-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb151-2" title="2"><span class="co">A union just means one or the other</span></a>
<a class="sourceLine" id="cb151-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb151-4" title="4"><span class="kw">union</span> sigval {</a>
<a class="sourceLine" id="cb151-5" title="5">  <span class="dt">int</span> sival_int;</a>
<a class="sourceLine" id="cb151-6" title="6">  <span class="dt">void</span>* sival_ptr;</a>
<a class="sourceLine" id="cb151-7" title="7">};</a></code></pre></div>
<div class="sourceCode" id="cb152"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb152-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb152-2" title="2"><span class="co">F: Asynchronously enqueue read</span></a>
<a class="sourceLine" id="cb152-3" title="3"><span class="co">A: aiocb is the aio callback struct defined as above</span></a>
<a class="sourceLine" id="cb152-4" title="4"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb152-5" title="5"><span class="co">R: 0 returned, -1 on error</span></a>
<a class="sourceLine" id="cb152-6" title="6"><span class="co">E: errno is set on error</span></a>
<a class="sourceLine" id="cb152-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb152-8" title="8"><span class="dt">int</span> aio_read( <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<div class="sourceCode" id="cb153"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb153-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb153-2" title="2"><span class="co">F: Asynchronously enqueue write</span></a>
<a class="sourceLine" id="cb153-3" title="3"><span class="co">A: aiocb is the aio callback struct defined as above</span></a>
<a class="sourceLine" id="cb153-4" title="4"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb153-5" title="5"><span class="co">R: 0 returned, -1 on error</span></a>
<a class="sourceLine" id="cb153-6" title="6"><span class="co">E: errno is set on error</span></a>
<a class="sourceLine" id="cb153-7" title="7"><span class="co">*/</span></a>
<a class="sourceLine" id="cb153-8" title="8"><span class="dt">int</span> aio_write( <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<div class="sourceCode" id="cb154"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb154-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb154-2" title="2"><span class="co">F: Check status of aiocb</span></a>
<a class="sourceLine" id="cb154-3" title="3"><span class="co">A: aiocb to check status of</span></a>
<a class="sourceLine" id="cb154-4" title="4"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb154-5" title="5"><span class="co">R: 0 when done, EINPROGRESS when in progress, -1 on error,</span></a>
<a class="sourceLine" id="cb154-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb154-7" title="7"><span class="co">N: should probably really be called aio_status instead</span></a>
<a class="sourceLine" id="cb154-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb154-9" title="9"><span class="dt">int</span> aio_error( <span class="dt">const</span> <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<div class="sourceCode" id="cb155"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb155-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb155-2" title="2"><span class="co">F: Check return value from aio read/write</span></a>
<a class="sourceLine" id="cb155-3" title="3"><span class="co">A: aiocb to check for</span></a>
<a class="sourceLine" id="cb155-4" title="4"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb155-5" title="5"><span class="co">R: return value when done, -1 on error,</span></a>
<a class="sourceLine" id="cb155-6" title="6"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb155-7" title="7"><span class="co">N: can only be called once aio is done, and once per every aio</span></a>
<a class="sourceLine" id="cb155-8" title="8"><span class="co"> : polite to call so internal data structures can be freed</span></a>
<a class="sourceLine" id="cb155-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb155-10" title="10"><span class="dt">ssize_t</span> aio_return( <span class="dt">const</span> <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<div class="sourceCode" id="cb156"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb156-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb156-2" title="2"><span class="co">F: Suspend until atleast 1 of a specified set of I/O requests completes.</span></a>
<a class="sourceLine" id="cb156-3" title="3"><span class="co">A: list: array of aio control blocks</span></a>
<a class="sourceLine" id="cb156-4" title="4"><span class="co"> : nent: number of entries</span></a>
<a class="sourceLine" id="cb156-5" title="5"><span class="co"> : timespec: timeout</span></a>
<a class="sourceLine" id="cb156-6" title="6"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb156-7" title="7"><span class="co">R: 0 when success, -1 on timeout</span></a>
<a class="sourceLine" id="cb156-8" title="8"><span class="co">*/</span></a>
<a class="sourceLine" id="cb156-9" title="9"><span class="dt">int</span> aio_suspend( <span class="dt">const</span> <span class="kw">struct</span> aiocb *<span class="dt">const</span> list[], <span class="dt">int</span> nent, <span class="dt">const</span> <span class="kw">struct</span> timespec* timeout );</a></code></pre></div>
<div class="sourceCode" id="cb157"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb157-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb157-2" title="2"><span class="co">F: Cancel AIO request for file_descriptor</span></a>
<a class="sourceLine" id="cb157-3" title="3"><span class="co">A: fd: file to cancel for</span></a>
<a class="sourceLine" id="cb157-4" title="4"><span class="co"> : aiocb: to cancel, NULL to try to cancel all</span></a>
<a class="sourceLine" id="cb157-5" title="5"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb157-6" title="6"><span class="co">R: AIO_CANCELLED: The requested operation(s) have been cancelled.</span></a>
<a class="sourceLine" id="cb157-7" title="7"><span class="co"> : AIO_NOTCANCELLED: At least one operation could not be cancelled.</span></a>
<a class="sourceLine" id="cb157-8" title="8"><span class="co"> : -1: Something went wrong in cancelling; errno set.</span></a>
<a class="sourceLine" id="cb157-9" title="9"><span class="co"> : AIO_ALLDONE: All operations finished before they could be cancelled.</span></a>
<a class="sourceLine" id="cb157-10" title="10"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb157-11" title="11"><span class="co">*/</span></a>
<a class="sourceLine" id="cb157-12" title="12"><span class="dt">int</span> aio_cancel( <span class="dt">int</span> fd, <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<div class="sourceCode" id="cb158"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb158-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb158-2" title="2"><span class="co">F: Allows us to enqueue a list of aio requests in one go</span></a>
<a class="sourceLine" id="cb158-3" title="3"><span class="co">A: mode: LIO_WAIT (wait for all) or LIO_NOWAIT</span></a>
<a class="sourceLine" id="cb158-4" title="4"><span class="co"> : list: list of aio control blocks</span></a>
<a class="sourceLine" id="cb158-5" title="5"><span class="co">       : aio_lio_opcode needs to be set to either of the following</span></a>
<a class="sourceLine" id="cb158-6" title="6"><span class="co">       : LIO_READ, LIO_WRITE, or LIO_NOP</span></a>
<a class="sourceLine" id="cb158-7" title="7"><span class="co"> : nent: number of entries</span></a>
<a class="sourceLine" id="cb158-8" title="8"><span class="co"> : siegev: event that will fire once all requests are complete</span></a>
<a class="sourceLine" id="cb158-9" title="9"><span class="co">H: &lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb158-10" title="10"><span class="co">R: AIO_CANCELLED: The requested operation(s) have been cancelled.</span></a>
<a class="sourceLine" id="cb158-11" title="11"><span class="co"> : AIO_NOTCANCELLED: At least one operation could not be cancelled.</span></a>
<a class="sourceLine" id="cb158-12" title="12"><span class="co"> : -1: Something went wrong in cancelling; errno set.</span></a>
<a class="sourceLine" id="cb158-13" title="13"><span class="co"> : AIO_ALLDONE: All operations finished before they could be cancelled.</span></a>
<a class="sourceLine" id="cb158-14" title="14"><span class="co">E: errno is set on failure</span></a>
<a class="sourceLine" id="cb158-15" title="15"><span class="co">*/</span></a>
<a class="sourceLine" id="cb158-16" title="16"><span class="dt">int</span> lio_listio( <span class="dt">int</span> mode, <span class="kw">struct</span> aiocb * <span class="dt">const</span> list[ ], <span class="dt">int</span> nent, <span class="kw">struct</span> sigevent* sigev );</a></code></pre></div>
<div class="sourceCode" id="cb159"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb159-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb159-2" title="2"><span class="co">F: Configure libevent to use pthreads library and functions</span></a>
<a class="sourceLine" id="cb159-3" title="3"><span class="co">R: 0 on sucess and -1 on error</span></a>
<a class="sourceLine" id="cb159-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb159-5" title="5"><span class="dt">int</span> evthread_use_pthreads( );</a></code></pre></div>
<div class="sourceCode" id="cb160"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb160-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb160-2" title="2"><span class="co">F: Create an event_base with default settings</span></a>
<a class="sourceLine" id="cb160-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb160-4" title="4"><span class="kw">struct</span> event_base* event_base_new( );</a></code></pre></div>
<div class="sourceCode" id="cb161"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb161-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb161-2" title="2"><span class="co">F: Create an event_base with configuration cfg</span></a>
<a class="sourceLine" id="cb161-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb161-4" title="4"><span class="kw">struct</span> event_base* event_base_new_with_config( <span class="dt">const</span> <span class="kw">struct</span> event_config* cfg );</a></code></pre></div>
<div class="sourceCode" id="cb162"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb162-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb162-2" title="2"><span class="co">F: Create a new event base config</span></a>
<a class="sourceLine" id="cb162-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb162-4" title="4"><span class="kw">struct</span> event_config* event_config_new( );</a></code></pre></div>
<div class="sourceCode" id="cb163"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb163-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb163-2" title="2"><span class="co">F: Free an event base config</span></a>
<a class="sourceLine" id="cb163-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb163-4" title="4"><span class="dt">void</span> event_config_free( <span class="kw">struct</span> event_config* cfg );</a></code></pre></div>
<div class="sourceCode" id="cb164"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb164-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb164-2" title="2"><span class="co">F: Free an event base</span></a>
<a class="sourceLine" id="cb164-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb164-4" title="4"><span class="dt">void</span> event_base_free( <span class="kw">struct</span> event_base* base );</a></code></pre></div>
<div class="sourceCode" id="cb165"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb165-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb165-2" title="2"><span class="co">F: format for an event callback function</span></a>
<a class="sourceLine" id="cb165-3" title="3"><span class="co"> : void return type</span></a>
<a class="sourceLine" id="cb165-4" title="4"><span class="co"> : what is basically what we were looking for</span></a>
<a class="sourceLine" id="cb165-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb165-6" title="6"><span class="kw">typedef</span> <span class="dt">void</span> (*event_callback_fn)( evutil_socket_t fd, <span class="dt">short</span> what, <span class="dt">void</span>* arg );</a></code></pre></div>
<div class="sourceCode" id="cb166"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb166-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb166-2" title="2"><span class="co">F: Declare new event</span></a>
<a class="sourceLine" id="cb166-3" title="3"><span class="co">A: event_base: that this event will be associated with</span></a>
<a class="sourceLine" id="cb166-4" title="4"><span class="co"> : fd: regular file descriptor</span></a>
<a class="sourceLine" id="cb166-5" title="5"><span class="co"> : what: what type of event we want to be notified of</span></a>
<a class="sourceLine" id="cb166-6" title="6"><span class="co">       : #define EV_TIMEOUT      0x01</span></a>
<a class="sourceLine" id="cb166-7" title="7"><span class="co">       : #define EV_READ         0x02</span></a>
<a class="sourceLine" id="cb166-8" title="8"><span class="co">       : #define EV_WRITE        0x04</span></a>
<a class="sourceLine" id="cb166-9" title="9"><span class="co">       : #define EV_SIGNAL       0x08</span></a>
<a class="sourceLine" id="cb166-10" title="10"><span class="co">       : #define EV_PERSIST      0x10</span></a>
<a class="sourceLine" id="cb166-11" title="11"><span class="co">       : #define EV_ET           0x20 - EDGE TRIGGERED</span></a>
<a class="sourceLine" id="cb166-12" title="12"><span class="co">       : these can be logically OR&#39;ed</span></a>
<a class="sourceLine" id="cb166-13" title="13"><span class="co"> : cb, arg are for callback</span></a>
<a class="sourceLine" id="cb166-14" title="14"><span class="co">*/</span></a>
<a class="sourceLine" id="cb166-15" title="15"><span class="kw">struct</span> event* event_new( <span class="kw">struct</span> event_base* b, evutil_socket_t fd, <span class="dt">short</span> what, event_callback_fn cb, <span class="dt">void</span>* arg );</a></code></pre></div>
<div class="sourceCode" id="cb167"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb167-1" title="1"><span class="dt">void</span> event_free( <span class="kw">struct</span> event* event );</a></code></pre></div>
<div class="sourceCode" id="cb168"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb168-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb168-2" title="2"><span class="co">F: When we&#39;re ready to start watching we can add the event</span></a>
<a class="sourceLine" id="cb168-3" title="3"><span class="co">A: timeval for timeout?</span></a>
<a class="sourceLine" id="cb168-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb168-5" title="5"><span class="dt">int</span> event_add( <span class="kw">struct</span> event* ev, <span class="dt">const</span> <span class="kw">struct</span> timeval* tv );</a></code></pre></div>
<div class="sourceCode" id="cb169"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb169-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb169-2" title="2"><span class="co">F: Remove even when we&#39;re done with it</span></a>
<a class="sourceLine" id="cb169-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb169-4" title="4"><span class="dt">int</span> event_del( <span class="kw">struct</span> event* ev );</a></code></pre></div>
<div class="sourceCode" id="cb170"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb170-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb170-2" title="2"><span class="co">F: Dispatch an event</span></a>
<a class="sourceLine" id="cb170-3" title="3"><span class="co">A: base to dispatch</span></a>
<a class="sourceLine" id="cb170-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb170-5" title="5"><span class="dt">int</span> event_base_dispatch( <span class="kw">struct</span> event_base* base );</a></code></pre></div>
<div class="sourceCode" id="cb171"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb171-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb171-2" title="2"><span class="co">F: Dispatch an event with flags</span></a>
<a class="sourceLine" id="cb171-3" title="3"><span class="co">A: base to dispatch</span></a>
<a class="sourceLine" id="cb171-4" title="4"><span class="co"> : flags:</span></a>
<a class="sourceLine" id="cb171-5" title="5"><span class="co">        : #define EVLOOP_ONCE             0x01 - wait for atleast 1</span></a>
<a class="sourceLine" id="cb171-6" title="6"><span class="co">        : #define EVLOOP_NONBLOCK         0x02 - skip if not ready</span></a>
<a class="sourceLine" id="cb171-7" title="7"><span class="co">        : #define EVLOOP_NO_EXIT_ON_EMPTY 0x04 - don&#39;t exit when done</span></a>
<a class="sourceLine" id="cb171-8" title="8"><span class="co">N: Normal behaviour is to exit from the lopp when there are no more</span></a>
<a class="sourceLine" id="cb171-9" title="9"><span class="co"> : events pending or active</span></a>
<a class="sourceLine" id="cb171-10" title="10"><span class="co">*/</span></a>
<a class="sourceLine" id="cb171-11" title="11"><span class="dt">int</span> event_base_loop( <span class="kw">struct</span> event_base *base, <span class="dt">int</span> flags );</a></code></pre></div>
<div class="sourceCode" id="cb172"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb172-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb172-2" title="2"><span class="co">F: If we use #define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></a>
<a class="sourceLine" id="cb172-3" title="3"><span class="co"> : then we need a way to timeout</span></a>
<a class="sourceLine" id="cb172-4" title="4"><span class="co">A: base to timeout, timeval with timeout stored</span></a>
<a class="sourceLine" id="cb172-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb172-6" title="6"><span class="dt">int</span> event_base_loopexit( <span class="kw">struct</span> event_base* base, <span class="dt">const</span> <span class="kw">struct</span> timeval* tv );</a></code></pre></div>
<div class="sourceCode" id="cb173"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb173-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb173-2" title="2"><span class="co">F: Allows us to break the event base loop</span></a>
<a class="sourceLine" id="cb173-3" title="3"><span class="co">N: stop as soon as we’ve finished the</span></a>
<a class="sourceLine" id="cb173-4" title="4"><span class="co"> : currently-being-processed active event</span></a>
<a class="sourceLine" id="cb173-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb173-6" title="6"><span class="dt">int</span> event_base_loopbreak( <span class="kw">struct</span> event_base* base );</a></code></pre></div>
<div class="sourceCode" id="cb174"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb174-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb174-2" title="2"><span class="co">F: global cleanup</span></a>
<a class="sourceLine" id="cb174-3" title="3"><span class="co">*/</span></a>
<a class="sourceLine" id="cb174-4" title="4"><span class="dt">void</span> libevent_global_shutdown( );</a></code></pre></div>
<div class="sourceCode" id="cb175"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb175-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb175-2" title="2"><span class="co">F: setup a buffer of events on an event base</span></a>
<a class="sourceLine" id="cb175-3" title="3"><span class="co">A: base to setup buffered events on</span></a>
<a class="sourceLine" id="cb175-4" title="4"><span class="co"> : fd of socket</span></a>
<a class="sourceLine" id="cb175-5" title="5"><span class="co"> : options:</span></a>
<a class="sourceLine" id="cb175-6" title="6"><span class="co">          : BEV_OPT_CLOSE_ON_FREE: close the socket when the</span></a>
<a class="sourceLine" id="cb175-7" title="7"><span class="co">                                 : buffer event is deallocated</span></a>
<a class="sourceLine" id="cb175-8" title="8"><span class="co">          : BEV_OPT_THREADSAFE: configure the buffer event to use locks,</span></a>
<a class="sourceLine" id="cb175-9" title="9"><span class="co">                              : so it can be accessed concurrently</span></a>
<a class="sourceLine" id="cb175-10" title="10"><span class="co">                              : from multiple threads.</span></a>
<a class="sourceLine" id="cb175-11" title="11"><span class="co">R: Bufferent event struct pointer</span></a>
<a class="sourceLine" id="cb175-12" title="12"><span class="co">*/</span></a>
<a class="sourceLine" id="cb175-13" title="13"><span class="kw">struct</span> bufferevent* bufferevent_socket_new( <span class="kw">struct</span> event_base* base, evutil_socket_t fd, <span class="kw">enum</span> bufferevent_options options );</a></code></pre></div>
<div class="sourceCode" id="cb176"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb176-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb176-2" title="2"><span class="co">F: free buffer event struct</span></a>
<a class="sourceLine" id="cb176-3" title="3"><span class="co">A: bev to deallocate/destruct</span></a>
<a class="sourceLine" id="cb176-4" title="4"><span class="co">*/</span></a>
<a class="sourceLine" id="cb176-5" title="5"><span class="dt">void</span> bufferevent_free( <span class="kw">struct</span> bufferevent* bev );</a></code></pre></div>
<div class="sourceCode" id="cb177"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb177-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb177-2" title="2"><span class="co">F: Data callback</span></a>
<a class="sourceLine" id="cb177-3" title="3"><span class="co">A: bev to accept</span></a>
<a class="sourceLine" id="cb177-4" title="4"><span class="co"> : ctx provided in cbarg</span></a>
<a class="sourceLine" id="cb177-5" title="5"><span class="co">*/</span></a>
<a class="sourceLine" id="cb177-6" title="6"><span class="kw">typedef</span> <span class="dt">void</span> ( *bufferevent_data_cb )( <span class="kw">struct</span> bufferevent* bev, <span class="dt">void</span>* ctx );</a></code></pre></div>
<div class="sourceCode" id="cb178"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb178-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb178-2" title="2"><span class="co">F: Event callback</span></a>
<a class="sourceLine" id="cb178-3" title="3"><span class="co">A: bev to accept</span></a>
<a class="sourceLine" id="cb178-4" title="4"><span class="co"> : events that we are interested in</span></a>
<a class="sourceLine" id="cb178-5" title="5"><span class="co"> : ctx provided in cbarg</span></a>
<a class="sourceLine" id="cb178-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb178-7" title="7"><span class="kw">typedef</span> <span class="dt">void</span> ( *bufferevent_event_cb )( <span class="kw">struct</span> bufferevent* bev, <span class="dt">short</span> events, <span class="dt">void</span>* ctx );</a></code></pre></div>
<div class="sourceCode" id="cb179"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb179-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb179-2" title="2"><span class="co">F: Setup callbacks</span></a>
<a class="sourceLine" id="cb179-3" title="3"><span class="co">A: bev to setup callbacks for</span></a>
<a class="sourceLine" id="cb179-4" title="4"><span class="co"> : readcb: read callback</span></a>
<a class="sourceLine" id="cb179-5" title="5"><span class="co"> : writecb: write callback</span></a>
<a class="sourceLine" id="cb179-6" title="6"><span class="co"> : eventcb: event callback</span></a>
<a class="sourceLine" id="cb179-7" title="7"><span class="co"> : cbarg: shared between all callbacks, can be NULL</span></a>
<a class="sourceLine" id="cb179-8" title="8"><span class="co">R: void</span></a>
<a class="sourceLine" id="cb179-9" title="9"><span class="co">*/</span></a>
<a class="sourceLine" id="cb179-10" title="10"><span class="dt">void</span> bufferevent_setcb( <span class="kw">struct</span> bufferevent* bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, <span class="dt">void</span>* cbarg );</a></code></pre></div>
<div class="sourceCode" id="cb180"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb180-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb180-2" title="2"><span class="co">F: Connect</span></a>
<a class="sourceLine" id="cb180-3" title="3"><span class="co">A: bev to configure</span></a>
<a class="sourceLine" id="cb180-4" title="4"><span class="co"> : address to connect to</span></a>
<a class="sourceLine" id="cb180-5" title="5"><span class="co"> : addrlen: sizeof address</span></a>
<a class="sourceLine" id="cb180-6" title="6"><span class="co">*/</span></a>
<a class="sourceLine" id="cb180-7" title="7"><span class="dt">int</span> bufferevent_socket_connect( <span class="kw">struct</span> bufferevent* bev, <span class="kw">struct</span> sockaddr* address, <span class="dt">int</span> addrlen );</a></code></pre></div>
<h2 id="notes">Notes:</h2>
<h3 id="speedup">Speedup</h3>
<p><span class="math inline">\text{speedup} \leq \frac{1}{S+\frac{1-S}{N}}</span></p>
<h3 id="synchronization-patterns">Synchronization Patterns</h3>
<ol type="1">
<li>Signalling
<ul>
<li>One thread signals the other to continue</li>
</ul></li>
<li>Rendezvous
<ul>
<li>All processes have to run in the same order simultaneously <code>A1+B1</code>, <code>A2+B2</code></li>
</ul></li>
<li>Mutual Exclusion
<ul>
<li>Only one thread in a critical section at a time</li>
</ul></li>
<li>Multiplex
<ul>
<li>Up to <code>n</code> threads in a critical section at a time</li>
</ul></li>
<li>Barrier
<ul>
<li>Generalized rezendevous - more than 2 threads meetup at a point before proceeding</li>
<li>Turnstile</li>
</ul></li>
<li>Reusable Barrier
<ul>
<li>Repeatedly have threads rezendevous to some common point</li>
<li>Two Phase Barrier</li>
</ul></li>
</ol>
<h3 id="conditions-for-deadlock">Conditions for Deadlock</h3>
<ol type="1">
<li><strong>Mutual Exclusion</strong>: A resource belongs to, at most, one process at a time.</li>
<li><strong>Hold-and-Wait</strong>: A process that is currently holding some resources may request additional resources and may be forced to wait for them.</li>
<li><strong>No Preemption</strong>: A resource cannot be “taken” from the process that holds it; only the process currently holding that resource may release it.</li>
<li><strong>Circular-Wait</strong>: A cycle in the resource allocation graph.</li>
</ol>
<h3 id="valgrind">Valgrind</h3>
<ul>
<li><strong>Definitely lost</strong>: a clear memory leak. Fix it.</li>
<li><strong>Indirectly lost</strong>: a problem with a pointer based structure. Generally, fixing the definitely lost items should be enough to clear up the indirectly lost stuff. eg: head of linked list is lost, but you still rest of list is still indirectly accessible</li>
<li><strong>Possibly lost</strong>: the program is leaking memory unless weird things are going on with pointers where you’re pointing them to the middle of an allocated block.</li>
<li><strong>Still reachable</strong>: this is memory that was still allocated that might otherwise have been freed, but references to it exist so it at least wasn’t lost.</li>
<li><strong>Suppressed</strong>: you can configure the tool to ignore things and those will appear in the suppressed category.</li>
</ul>
<h3 id="helgrind">Helgrind</h3>
<ol type="1">
<li>Misuses of the pthreads API
<ul>
<li>unlocked a non-locked lock</li>
</ul></li>
<li>Lock ordering problems</li>
<li>Data races</li>
</ol>
<h3 id="consistency-journalling">Consistency: Journalling</h3>
<p>Tool to check for inconsistent disk state: Unix: <code>fsck</code>, Windows: <code>chkdsk</code></p>
<h4 id="zfs-sunoracle-file-system">ZFS (Sun/Oracle File System)</h4>
<ul>
<li>state is always consistent on disk</li>
<li>data is copied, then changed, then re-written
<ul>
<li>only when transaction is complete are references to the old pointers and block deleted</li>
</ul></li>
</ul>
<p><em>If the disk becomes completely and totally full it is not possible to delete anything and make space, because there’s no place to allocate new blocks.</em></p>
<h4 id="apfs-apple-file-system">APFS (Apple File System)</h4>
<ul>
<li>maintains a git diff, and stores changes instead of the actual file itself</li>
<li>weakness against standard copy backup method for most users since it simply creates a pointer to the original file</li>
<li>you can replay changes to get your file back which is really good</li>
</ul>
<h4 id="ntfs-windows-file-system">NTFS (Windows File System)</h4>
<p><img src="./images/ntfs-volume.png" class="responsive-img" /></p>
<p>The Master File Table (MFT) contains information about all the files and folders. Following the that, a block is allocated to system files that contain some important system information:</p>
<ol type="1">
<li><p><strong>MFT2</strong>: Mirror of the first few rows of the MFT (in case the original is damaged).</p></li>
<li><p><strong>Log File</strong>: The journalling transaction log.</p></li>
<li><p><strong>Cluster Bitmap</strong>: Bitmap showing which of the clusters are in use.</p></li>
<li><p><strong>Attribute Definition Table</strong>: Attribute types supported on this volume.</p></li>
</ol>
<p>NTFS uses journalling, where it stores what the current write transaction is trying to do, so that in case of a crash there is a way to recover. BUT, this means we could have an incomplete disk state, i.e. windows detected a recovered version of this document</p>
<p>The actual implementation of journalling works as follows :</p>
<ol type="1">
<li>Record the change(s) in the log file in the cache.</li>
<li>Modify the volume in the cache.</li>
<li>The cache manager flushes the log file to disk.</li>
<li>Only after the log file is flushed to disk, the cache manager flushes the volume changes.</li>
</ol>
<p>What’s really interesting about this is that the changes are carried out in the background, that is to say, asynchronously.</p>
</body>
</html>

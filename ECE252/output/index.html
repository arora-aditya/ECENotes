<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>index.html</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="pandoc.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
    var mathElements = document.getElementsByClassName("math");
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") { katex.render(texText.data, mathElements[i], { displayMode: mathElements[i].classList.contains("display"), throwOnError: false } );
    }}});</script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="shortcut icon" href="https://arora-aditya.com/images/A2.png" type="img">
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-137390799-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-137390799-2');
    window.onload = function(){
      let num = window.location.pathname.slice(window.location.pathname.length-3, window.location.pathname.length-1);
      if(parseInt(num) >= 33){
      document.getElementById('button').parentNode.removeChild(document.getElementById('button'));
      }
    }
  
    function next(){
      var num = window.location.pathname.slice(window.location.pathname.length-7, window.location.pathname.length-5);
      var next= String(parseInt(num)+1);
      if(next.length < 2){
        next = "0" + next
      }
      if(parseInt(num) < 33){
        // string manipulation to handle edge case for L"25" conflicting with "25"2 in header
        window.location.pathname = window.location.pathname.slice(0, window.location.pathname.length-7) + window.location.pathname.slice(window.location.pathname.length-7).replace(num, next);
      }
    }
  </script>
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction-and-our-c-toolkit">1 — Introduction and Our C Toolkit</a><ul>
<li><a href="#about-the-course">About the Course</a></li>
<li><a href="#some-background-on-operating-systems">Some Background on Operating Systems</a><ul>
<li><a href="#systems-programming">Systems Programming</a></li>
<li><a href="#concurrency">Concurrency</a></li>
</ul></li>
<li><a href="#our-c-toolkit">Our C Toolkit</a><ul>
<li><a href="#comments.">Comments.</a></li>
<li><a href="#structures.">Structures.</a></li>
<li><a href="#type-names.">Type Names.</a></li>
<li><a href="#memory-allocation-deallocation-and-pointers">Memory Allocation, Deallocation, and Pointers</a></li>
<li><a href="#dereferencing-address-of-and-the-arrow.">Dereferencing, Address-Of, and The Arrow.</a></li>
<li><a href="#arrays.">Arrays.</a></li>
<li><a href="#strings.">Strings.</a></li>
<li><a href="#function-convention.">Function Convention.</a></li>
<li><a href="#printing.">Printing.</a></li>
<li><a href="#define-directives.">Define Directives.</a></li>
<li><a href="#main-and-arguments.">Main and Arguments.</a></li>
<li><a href="#void-pointers.">Void Pointers.</a></li>
</ul></li>
</ul></li>
<li><a href="#interrupts-system-calls">2 — Interrupts &amp; System Calls</a><ul>
<li><a href="#computer-organization">Computer Organization</a><ul>
<li><a href="#the-processor">The Processor</a></li>
<li><a href="#interrupts">Interrupts</a><ul>
<li><a href="#storing-and-restoring-state.">Storing and Restoring State.</a></li>
<li><a href="#multiprogramming.">Multiprogramming.</a></li>
</ul></li>
</ul></li>
<li><a href="#its-a-trap">It’s a Trap!</a><ul>
<li><a href="#motivation-for-dual-mode-operation">Motivation for Dual Mode Operation</a></li>
<li><a href="#example-reading-from-disk">Example: Reading from Disk</a></li>
<li><a href="#summary-invoking-a-system-call">Summary: Invoking a System Call</a></li>
</ul></li>
</ul></li>
<li><a href="#the-file-system">3 — The File System</a><ul>
<li><a href="#file-systems">File Systems</a><ul>
<li><a href="#file-operations">File Operations</a><ul>
<li><a href="#creating-a-file.">Creating a File.</a></li>
<li><a href="#writing-a-file.">Writing a File.</a></li>
<li><a href="#reading-a-file.">Reading a File.</a></li>
<li><a href="#truncating-a-file.">Truncating a File.</a></li>
<li><a href="#repositioning-within-a-file.">Repositioning within a File.</a></li>
<li><a href="#deleting-a-file.">Deleting a File.</a></li>
</ul></li>
<li><a href="#reading-and-writing">Reading and Writing</a></li>
<li><a href="#file-types">File Types</a></li>
<li><a href="#directories">Directories</a></li>
<li><a href="#file-permissions">File Permissions</a><ul>
<li><a href="#unix-style-permissions.">UNIX-Style Permissions.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#processes">4 — Processes</a><ul>
<li><a href="#processes-1">Processes</a><ul>
<li><a href="#the-process-control-block">The Process Control Block</a></li>
<li><a href="#the-circle-of-life">The Circle of Life</a><ul>
<li><a href="#process-creation">Process Creation</a></li>
<li><a href="#process-destruction">Process Destruction</a></li>
</ul></li>
<li><a href="#process-family-tree">Process Family Tree</a></li>
<li><a href="#the-five-state-model">The Five-State Model</a></li>
<li><a href="#swapping-processes-to-disk">Swapping Processes to Disk</a></li>
</ul></li>
</ul></li>
<li><a href="#processes-in-unix">5 — Processes in UNIX</a><ul>
<li><a href="#the-process-in-unix">The Process in UNIX</a><ul>
<li><a href="#show-me-the-code">Show Me The Code!</a><ul>
<li><a href="#use-of-fork-design-problem.">Use of Fork Design Problem. </a></li>
<li><a href="#use-of-fork-design-solution">Use of Fork Design Solution</a></li>
</ul></li>
</ul></li>
<li><a href="#the-fork-bomb">The Fork Bomb</a></li>
<li><a href="#signals">Signals</a></li>
</ul></li>
<li><a href="#inter-process-communication">6 — Inter-Process Communication</a><ul>
<li><a href="#inter-process-communication-ipc">Inter-Process Communication (IPC)</a><ul>
<li><a href="#file-system">File System</a></li>
<li><a href="#message-passing">Message Passing</a></li>
<li><a href="#message-queues">Message Queues</a><ul>
<li><a href="#using-signals.">Using Signals.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#sockets">7 — Sockets</a><ul>
<li><a href="#network-communication">Network Communication</a><ul>
<li><a href="#sockets-1">Sockets</a><ul>
<li><a href="#check-the-boot-of-the-car-for-your-jumper">Check the Boot of the Car for your Jumper!</a></li>
<li><a href="#addresses.">Addresses.</a></li>
<li><a href="#looking-up-the-address.">Looking Up the Address.</a></li>
<li><a href="#client-connect.">Client: Connect.</a></li>
<li><a href="#server-bind-listen-and-accept.">Server: Bind, Listen, and Accept.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#network-communication-1">8 — Network Communication</a><ul>
<li><a href="#network-communication-continued">Network Communication, Continued</a><ul>
<li><a href="#send.">Send.</a></li>
<li><a href="#receive.">Receive.</a></li>
<li><a href="#datagrams">Datagrams</a></li>
<li><a href="#curl">cURL</a><ul>
<li><a href="#setting-up-callbacks.">Setting up Callbacks.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#rogue-one-a-star-wars-story">9 — Rogue One: A Star Wars Story</a><ul>
<li><a href="#in-class-exercise-scarif-dont-like-it">In Class Exercise: Scarif Don’t Like It</a><ul>
<li><a href="#background.">Background.</a></li>
<li><a href="#primary-objective.">Primary Objective.</a></li>
<li><a href="#secondary-objectives.">Secondary Objective(s).</a></li>
<li><a href="#starter-code.">Starter Code.</a></li>
<li><a href="#submitting-your-code.">Submitting Your Code.</a></li>
<li><a href="#grading.">Grading.</a></li>
<li><a href="#description-of-behaviour.">Description of Behaviour.</a></li>
<li><a href="#hints-debugging-guidance.">Hints &amp; Debugging Guidance.</a></li>
</ul></li>
</ul></li>
<li><a href="#pipes-and-shared-memory">10 — Pipes and Shared Memory</a><ul>
<li><a href="#ipc-same-system">IPC: Same System</a><ul>
<li><a href="#unix-pipes">UNIX Pipes</a><ul>
<li><a href="#unix-pipes-code-example">UNIX Pipes: Code Example</a></li>
</ul></li>
<li><a href="#shared-memory">Shared Memory</a><ul>
<li><a href="#alternatively-mmap.">Alternatively: <code>mmap</code>.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#threads">11 — Threads</a><ul>
<li><a href="#threads-1">Threads</a><ul>
<li><a href="#motivation-for-threads">Motivation for Threads</a></li>
<li><a href="#thread-states">Thread States</a></li>
</ul></li>
<li><a href="#posix-threads">POSIX Threads</a><ul>
<li><a href="#creating-a-new-thread.">Creating a New Thread.</a></li>
<li><a href="#returning-values.">Returning Values.</a></li>
<li><a href="#collecting-returned-values.">Collecting Returned Values.</a></li>
</ul></li>
</ul></li>
<li><a href="#threads-and-concurrency">12 — Threads and Concurrency</a><ul>
<li><a href="#more-on-threads">More on Threads</a><ul>
<li><a href="#thread-cancellation.">Thread Cancellation.</a></li>
<li><a href="#nows-not-a-good-time">Now’s not a good time!</a></li>
<li><a href="#attributes-and-using-memory-to-pass-data.">Attributes and Using Memory to Pass Data.</a></li>
<li><a href="#count-to-10...">Count to 10...</a></li>
</ul></li>
<li><a href="#concurrency-1">Concurrency</a><ul>
<li><a href="#parallelism-and-speedup">Parallelism and Speedup</a><ul>
<li><a href="#merge-sort-example.">Merge Sort Example.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#concurrency-synchronization-and-atomicity">13 — Concurrency: Synchronization and Atomicity</a><ul>
<li><a href="#synchronization">Synchronization</a><ul>
<li><a href="#serialization-through-messages">Serialization through Messages</a></li>
<li><a href="#shared-data-and-atomic-operations">Shared Data and Atomic Operations</a></li>
<li><a href="#mutual-exclusion-through-flags">Mutual Exclusion through Flags</a></li>
<li><a href="#test-and-set">Test-and-Set</a></li>
</ul></li>
</ul></li>
<li><a href="#semaphores">14 — Semaphores</a><ul>
<li><a href="#mutual-exclusion-through-messages">Mutual Exclusion through Messages</a></li>
<li><a href="#semaphore">Semaphore</a><ul>
<li><a href="#example-linked-list-integrity">Example: Linked List Integrity</a></li>
<li><a href="#semaphore-syntax">Semaphore Syntax</a></li>
<li><a href="#applying-the-semaphore-to-the-linked-list">Applying the Semaphore to the Linked List</a></li>
</ul></li>
</ul></li>
<li><a href="#synchronization-patterns">15 — Synchronization Patterns</a><ul>
<li><a href="#synchronization-patterns-1">Synchronization Patterns</a><ul>
<li><a href="#signalling">Signalling</a></li>
<li><a href="#rendezvous">Rendezvous</a></li>
<li><a href="#mutual-exclusion">Mutual Exclusion</a></li>
<li><a href="#multiplex">Multiplex</a></li>
<li><a href="#barrier">Barrier</a></li>
<li><a href="#the-reusable-barrier">The Reusable Barrier</a></li>
</ul></li>
</ul></li>
<li><a href="#the-producer-consumer-problem">16 — The Producer-Consumer Problem</a><ul>
<li><a href="#classical-synchronization-problems-producer-consumer">Classical Synchronization Problems: Producer-Consumer</a><ul>
<li><a href="#producer-consumer-example">Producer-Consumer Example</a></li>
<li><a href="#mutex-syntax">Mutex Syntax</a></li>
<li><a href="#parallelizing-the-producer-consumer-solution">Parallelizing the Producer-Consumer Solution</a></li>
</ul></li>
</ul></li>
<li><a href="#hogwarts-school-of-witchcraft-and-wizardry">17 — Hogwarts School of Witchcraft and Wizardry</a><ul>
<li><a href="#in-class-exercise-harry-potter-and-the-pthread-house-elves">In Class Exercise: Harry Potter and the pthread House Elves</a><ul>
<li><a href="#background.-1">Background.</a></li>
<li><a href="#primary-objective.-1">Primary Objective.</a></li>
<li><a href="#secondary-objectives.-1">Secondary Objective(s).</a></li>
<li><a href="#starter-code.-1">Starter Code.</a></li>
<li><a href="#submitting-your-code.-1">Submitting Your Code.</a></li>
<li><a href="#grading.-1">Grading.</a></li>
<li><a href="#description-of-behaviour.-1">Description of Behaviour.</a></li>
<li><a href="#sample-output.">Sample Output.</a></li>
<li><a href="#hints-debugging-guidance.-1">Hints &amp; Debugging Guidance.</a></li>
</ul></li>
</ul></li>
<li><a href="#the-readers-writers-problem">18 — The Readers-Writers Problem</a><ul>
<li><a href="#the-readers-writers-problem-1">The Readers-Writers Problem</a><ul>
<li><a href="#readers-writers-example">Readers Writers Example</a></li>
<li><a href="#seek-and-destroy-the-search-insert-delete-problem">Seek and Destroy: the Search-Insert-Delete Problem</a></li>
</ul></li>
</ul></li>
<li><a href="#deadlock">19 — Deadlock</a><ul>
<li><a href="#the-dining-philosophers-problem">The Dining Philosophers Problem</a></li>
<li><a href="#deadlock-1">Deadlock</a><ul>
<li><a href="#reusable-and-consumable-resources">Reusable and Consumable Resources</a></li>
<li><a href="#conditions-for-deadlock">Conditions for Deadlock</a></li>
</ul></li>
<li><a href="#dealing-with-deadlock">Dealing with Deadlock</a><ul>
<li><a href="#deadlock-option-1-ignore-it">Deadlock Option 1: Ignore it</a></li>
<li><a href="#deadlock-option-2-deadlock-prevention">Deadlock Option 2: Deadlock Prevention</a><ul>
<li><a href="#mutual-exclusion.">Mutual Exclusion.</a></li>
<li><a href="#hold-and-wait.">Hold and Wait.</a></li>
<li><a href="#no-preemption.">No Preemption.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#deadlock-avoidance">20 — Deadlock Avoidance</a><ul>
<li><a href="#dealing-with-deadlock-1">Dealing with Deadlock</a><ul>
<li><a href="#deadlock-option-3-deadlock-avoidance">Deadlock Option 3: Deadlock Avoidance</a><ul>
<li><a href="#ordering-of-resources">Ordering of Resources</a></li>
<li><a href="#stay-alert-stay-safe">Stay Alert, Stay Safe</a><ul>
<li><a href="#resource-allocation-graph-algorithm.">Resource-Allocation-Graph Algorithm.</a></li>
<li><a href="#the-bankers-algorithm.">The Banker’s Algorithm.</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#deadlock-detection-recovery">21 — Deadlock Detection &amp; Recovery</a><ul>
<li><a href="#deadlock-detection">Deadlock Detection</a><ul>
<li><a href="#general-deadlock-detection-algorithm">General Deadlock Detection Algorithm</a><ul>
<li><a href="#deadlock-detection-algorithm-example.">Deadlock Detection Algorithm Example.</a></li>
</ul></li>
<li><a href="#when-to-detect-deadlock">When to Detect Deadlock</a></li>
</ul></li>
<li><a href="#deadlock-recovery">Deadlock Recovery</a><ul>
<li><a href="#recovery-strategies">Recovery Strategies</a><ul>
<li><a href="#robbery">Robbery</a></li>
<li><a href="#mass-murder">Mass Murder</a></li>
<li><a href="#murder">Murder</a></li>
<li><a href="#time-travel">Time Travel</a></li>
<li><a href="#armageddon">Armageddon</a></li>
</ul></li>
<li><a href="#victim-selection">Victim Selection</a></li>
<li><a href="#miscarriages-of-justice">Miscarriages of Justice</a></li>
</ul></li>
</ul></li>
<li><a href="#advanced-concurrency-problems">22 — Advanced Concurrency Problems</a><ul>
<li><a href="#get-a-pizza-this">Get a Pizza This!</a></li>
<li><a href="#the-barbershop-problem">The Barbershop Problem</a><ul>
<li><a href="#chemistry-building-h_2o">Chemistry: Building H<span class="math inline">_{2}</span>O</a></li>
</ul></li>
</ul></li>
<li><a href="#condition-variables-monitors-atomic-types">23 — Condition Variables, Monitors, Atomic Types</a><ul>
<li><a href="#condition-variables">Condition Variables</a></li>
<li><a href="#monitors">Monitors</a></li>
<li><a href="#atomic-types">Atomic Types</a><ul>
<li><a href="#spinlocks.">Spinlocks.</a></li>
</ul></li>
</ul></li>
<li><a href="#of-asgard-hel">24 — Of Asgard &amp; Hel</a><ul>
<li><a href="#norse-mythology">Norse Mythology</a><ul>
<li><a href="#valgrind-or-memcheck">Valgrind (or Memcheck) </a></li>
<li><a href="#helgrind">Helgrind</a></li>
</ul></li>
</ul></li>
<li><a href="#the-time-war">25 — The Time War</a><ul>
<li><a href="#in-class-exercise-gallifrey-stands">In Class Exercise: Gallifrey Stands!</a><ul>
<li><a href="#background.-2">Background.</a></li>
<li><a href="#primary-objective.-2">Primary Objective.</a></li>
<li><a href="#secondary-objectives.-2">Secondary Objective(s).</a></li>
<li><a href="#starter-code.-2">Starter Code.</a></li>
<li><a href="#submitting-your-code.-2">Submitting Your Code.</a></li>
<li><a href="#grading.-2">Grading.</a></li>
<li><a href="#description-of-behaviour.-2">Description of Behaviour.</a></li>
<li><a href="#hints-debugging-guidance.-2">Hints &amp; Debugging Guidance.</a></li>
</ul></li>
</ul></li>
<li><a href="#the-byzantine-generals-problem">26 — The Byzantine Generals Problem</a><ul>
<li><a href="#istanbul-was-constantinople">Istanbul was Constantinople</a><ul>
<li><a href="#should-i-stay-or-should-i-go-now">Should I Stay or Should I Go Now?</a></li>
</ul></li>
</ul></li>
<li><a href="#concurrency-in-file-systems">27 — Concurrency in File Systems</a><ul>
<li><a href="#concurrency-in-file-systems-1">Concurrency in File Systems</a><ul>
<li><a href="#using-a-file-as-a-lock">Using A File as a Lock</a></li>
</ul></li>
</ul></li>
<li><a href="#more-concurrency-in-file-systems">28 — More Concurrency in File Systems</a><ul>
<li><a href="#concurrency-in-file-systems-continued">Concurrency in File Systems, Continued</a><ul>
<li><a href="#copy-modify-merge">Copy-Modify-Merge</a></li>
<li><a href="#you-have-15-unread-notifications...">You Have 15 Unread Notifications...</a></li>
</ul></li>
<li><a href="#consistency-journalling">Consistency: Journalling</a><ul>
<li><a href="#zfs-sunoracle-file-system">ZFS (Sun/Oracle File System)</a></li>
<li><a href="#apfs-apple-file-system">APFS (Apple File System)</a></li>
<li><a href="#ntfs-windows-file-system">NTFS (Windows File System)</a></li>
</ul></li>
</ul></li>
<li><a href="#asynchronous-io-with-select-poll">29 — Asynchronous I/O with select, poll</a><ul>
<li><a href="#asynchronous-non-blocking-io">Asynchronous (non-blocking) I/O</a><ul>
<li><a href="#third-option-select">Third option: <code>select()</code></a><ul>
<li><a href="#chat-server.">Chat Server.</a></li>
<li><a href="#slightly-different-mostly-the-same-pselect.">Slightly different, mostly the same: <code>pselect</code>.</a></li>
<li><a href="#i-only-wanted-a-nap...">I only wanted a nap...</a></li>
</ul></li>
<li><a href="#alternative-poll">Alternative: <code>poll()</code></a><ul>
<li><a href="#comparing-the-two.">Comparing the two.</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#asynchronous-io-with-curl">30 — Asynchronous I/O with cURL</a><ul>
<li><a href="#using-curl-asynchronously">Using cURL Asynchronously</a><ul>
<li><a href="#i-enjoy-pain">I enjoy pain!</a></li>
<li><a href="#maybe-not-this-much-pain...">Maybe not this much pain...</a></li>
</ul></li>
</ul></li>
<li><a href="#asynchronous-io-with-aio">31 — Asynchronous I/O with AIO</a><ul>
<li><a href="#aio">AIO</a><ul>
<li><a href="#aio-example-read-while-you-eat.">AIO Example: Read While You Eat.</a></li>
<li><a href="#callback-when-aio-is-complete.">Callback when AIO is complete.</a></li>
<li><a href="#one-last-thing-the-list.">One last thing: the list.</a></li>
<li><a href="#aio-is-hard">AIO is HARD!</a></li>
</ul></li>
</ul></li>
<li><a href="#event-driven-io-with-libevent">32 — Event-Driven I/O with libevent</a><ul>
<li><a href="#event-driven-io-with-libevent-1">Event-Driven I/O with libevent</a><ul>
<li><a href="#getting-ready.">Getting ready.</a></li>
<li><a href="#all-your-base...">All your base...</a></li>
<li><a href="#event-notification.">Event notification.</a></li>
<li><a href="#lets-get-started.">Let’s get started.</a></li>
<li><a href="#cleaning-up.">Cleaning up.</a></li>
<li><a href="#buffered-events.">Buffered events.</a></li>
</ul></li>
</ul></li>
<li><a href="#starling-city-vigilantes">33 — Starling City Vigilantes</a><ul>
<li><a href="#in-class-exercise">In Class Exercise: </a><ul>
<li><a href="#background.-3">Background.</a></li>
<li><a href="#primary-objective.-3">Primary Objective.</a></li>
<li><a href="#secondary-objectives.-3">Secondary Objective(s).</a></li>
<li><a href="#starter-code.-3">Starter Code.</a></li>
<li><a href="#submitting-your-code.-3">Submitting Your Code.</a></li>
<li><a href="#grading.-3">Grading.</a></li>
<li><a href="#description-of-behaviour.-3">Description of Behaviour.</a></li>
<li><a href="#hints-debugging-guidance.-3">Hints &amp; Debugging Guidance.</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="introduction-and-our-c-toolkit" class="unnumbered">1 — Introduction and Our C Toolkit</h1>
<h2 id="about-the-course" class="unnumbered">About the Course</h2>
<p>We’ll start by reviewing the highlights of the class syllabus. Please read it carefully (it is available in Learn under Content <span class="math inline">\rightarrow</span> Overview). It contains a lot of important information about the class including: the lecture topics, the grading scheme, contact information for the course staff, and university policies.</p>
<h2 id="some-background-on-operating-systems" class="unnumbered">Some Background on Operating Systems</h2>
<p>An operating system (often abbreviated OS) is a piece of software that sits between the hardware of a computer and the applications (programs) that run on that computer. The OS does many different things and often has many (occasionally-conflicting) goals.</p>
<p>To use an analogy, you may wish to think of the operating system as the “secretary” of the computer. It is a resource manager, and it allocates resources as necessary. The most significant difference between a secretary and an operating system is that while a secretary can work in parallel with you, operating systems often work when programs are sleeping, and operating systems must put themselves to sleep to allow programs to execute. It is responsible for seeing to it that other programs can operate efficiently, providing an environment for other programs, and collecting and reporting data about what is and has been happening.</p>
<p>An operating system is also responsible for resource allocation. In the real world, the resources we have to work with, such as CPU time or memory space, are limited. The OS decides how to allocate these resources, keeps track of who currently owns what, and, in the event of conflicting requests, determines who gets the resource.</p>
<p>The OS usually enables useful programs like Photoshop or Microsoft Word to run. Any computer has various pieces of hardware, such as the CPU, memory, input/output devices (such as monitors, keyboards, modems). The OS is responsible for abstracting away the details of this, so that the authors of programs do not have to worry about the specifics of the hardware. Imagine how painful it would be to write even a simple program, like the Hello World example, if we had to write our program differently for every combination of hardware.</p>
<p>In most cases there will be multiple programs running on the computer. This implies the sharing of various resources. When this is the case, there is the potential for conflicts to arise. An operating system creates and enforces rules to make sure all the programs get along and play fairly. Of course, not all interaction between programs is competitive; sometimes they want to co-operate, and the OS helps them do that, too.</p>
<h3 id="systems-programming" class="unnumbered">Systems Programming</h3>
<p>The operating system is, however, just the backdrop to what we are going to do in this course. We will often be doing <em>Systems Programming</em>. This is the next layer above the operating system itself. System programs ship with the operating system and they are useful tools, but they are not part of the kernel.</p>
<p>Some examples of things that might fall under systems programming (from <span class="citation" data-cites="osc"></span>):</p>
<ul>
<li><p><strong>File Manipulation</strong> - Programs to create, delete, copy, rename, print, and manipulate files and directories.</p></li>
<li><p><strong>Communication</strong> - Remote login capability, file transfer, download utilities, and messaging.</p></li>
<li><p><strong>Processes and Thread Management</strong> - Creating processes and threads, working with them, interacting with others, and cleaning them up.</p></li>
</ul>
<p>Programming at this level is more difficult than writing regular programs. It may require knowledge of the hardware, or perhaps programming facilities like debugging are limited. Furthermore, systems programs must take concurrency into account; multiple (regular) programs may try to use the systems program at the same time. An e-mail client may choose to refuse to allow two instances of the program to be open at the same time, but users would not accept a system that did not permit more than one file operation at a time.</p>
<p>A key thing that distinguishes systems programming is that we want to do certain operations that involve the operating system. In short, there are some things that the operating system does not allow programs to do, and what they have to do is ask the operating system to do it instead. Learning how to use the functionality provided by the OS is a key part of writing any complex program (i.e., one that is non-trivial).</p>
<h3 id="concurrency" class="unnumbered">Concurrency</h3>
<p>The previous section mentioned concurrency, but didn’t really introduce what it is. A program is said to be concurrent if it can support two or more actions in progress at the same time; it is parallel if it can have two or more actions executing simultaneously <span class="citation" data-cites="artofc"></span>. Soon enough we will spend a great deal of time examining the differences between parallelism and concurrency in the program.</p>
<p>It is already the case that many programs you use are to a greater or smaller degree concurrent. Depending on your level of programming experience, you may have already written a concurrent program, intentionally or without knowing it. We will learn about how to take a program and make it concurrent, as well as how to write it with concurrency in mind from the ground up.</p>
<p>Concurrency comes with a number of advantages, chief amongst them the ability to speed up your program and get more work done in the same amount of time. It does, however, come with a number of drawbacks. On top of being somewhat more difficult to write, it is more difficult to be sure that the program is correct. We have tools to find and deal with the problems that arise, but we will need to use them carefully.</p>
<p>To give you a taste of the sort of problem that we may encounter, consider a program that performs a simple calculation given some input. If the program has a concurrency problem, then the answer could be (1) consistently the wrong answer every single time, (2) different on consecutive runs with the same input, or (3) correct some of the time but incorrect some of the time. As you can imagine, none of these options are acceptable. If you bought a simple four operation calculator that only gave the correct answer 99% of the time, would you be satisfied with your purchase?</p>
<p>Without going too much into the statistics of this, if your company’s payroll system got it right 98% of the time, and the company paid you every 2 weeks (ie 26 pay periods a year), then statistically they would likely fail to pay you within your first two years working there. Ouch. Correctness matters.</p>
<h2 id="our-c-toolkit" class="unnumbered">Our C Toolkit</h2>
<p>This is a programming course, after all, and we will be programming in C. There’s a baseline assumption that you have experience with a C-like language (if not C itself), such as , Java, C#. While the purpose of this class it not to teach you how to program in C, past experience (from ECE 254) suggests that it is helpful to cover a number of key concepts and conventions in C programming to make sure that everyone is on the same page, and to streamline explanation of future code examples. It is also probably desirable to put all of these things together in the same place for quick reference.</p>
<p>C is a procedural language: that is to say it has functions (but that doesn’t make it a functional programming language). It is not Object-Oriented or anything like it. We will write functions and functions work as they do in all C-like languages. They have a return type, function name, and then a list of arguments (or parameters) in parenthesis.</p>
<div class="sourceCode" id="cb1" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">int</span> function_name( <span class="dt">double</span> arg1, <span class="dt">int</span> arg2, <span class="dt">char</span> arg3 ) { ... }</a></code></pre></div>
<p>Header files, whether our own or for provided libraries are imported into the program using a precompiler directive such as below, where two of the standard headers are imported.</p>
<div class="sourceCode" id="cb2" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a></code></pre></div>
<p>Many of the functions we wish to call are included in these header files, but there are many many more. If you are attempting to use a library function and the compiler says it doesn’t know what you mean, then first check your spelling, as well as the number of parameters... and then check to be sure you have included the correct header file(s). If you get a compiler warning about “implicit declaration” of a function it means that a header is missing but the compiler can guess about what you want. You should still fix this by including the right header, which you might have to google.</p>
<p>C has no <code>bool</code> type by default. In many contexts an <code>int</code> is used where 0 represents false and 1 represents true. Or you can include the header <code>stdbool.h</code> which provides you the type as well as the explicit values of true and false.</p>
<p>But speaking of the compiler not knowing how to find a function you might have the compiler tell you that it can’t find the definition for <code>bar</code> when compiling <code>foo</code>.</p>
<div class="sourceCode" id="cb3" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">int</span> foo() {</a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="cf">return</span> bar( <span class="dv">7</span>, <span class="dv">11</span> );</a>
<a class="sourceLine" id="cb3-3" title="3">}</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="dt">int</span> bar( <span class="dt">int</span> v1, <span class="dt">int</span> v2 ) {</a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="cf">return</span> v1 * v2;</a>
<a class="sourceLine" id="cb3-7" title="7">} </a></code></pre></div>
<p>What gives?! It’s RIGHT THERE!</p>
<p>Some of the rules of the C compiler date back to the original design of the language and in these ancient and primitive times the compiler was unwilling to take two passes compiling source code because it would take too long. This can be solved in one of two ways. Either move <code>bar()</code> in the source so it appears before <code>foo</code>, or, instead, provide a function prototype for <code>bar()</code>.</p>
<div class="sourceCode" id="cb4" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">int</span> bar( <span class="dt">int</span> v1, <span class="dt">int</span> v2 );</a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="dt">int</span> foo() {</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="cf">return</span> bar( <span class="dv">7</span>, <span class="dv">11</span> );</a>
<a class="sourceLine" id="cb4-5" title="5">}</a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="dt">int</span> bar( <span class="dt">int</span> v1, <span class="dt">int</span> v2 ) {</a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="cf">return</span> v1 * v2;</a>
<a class="sourceLine" id="cb4-9" title="9">} </a></code></pre></div>
<p>The function prototype appears earlier in the file and promises the compiler that at some point there will be an implementation of this function, but be aware that it exists. This will now allow compilation to succeed. Function prototypes are frequently declared all at the top of the file.</p>
<p>In another ancient rule based on no second passes, versions of C before the C99 standard do not allow declaring of variables in a function anywhere but at the very start of the function. This means that in the example below, <code>loop1</code> will not compile but <code>loop2</code> will. Fortunately we will always assume (at least) C99 standard so this problem is avoided.</p>
<div class="sourceCode" id="cb5" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> loop1() {</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) { ... }</a>
<a class="sourceLine" id="cb5-3" title="3">}</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="dt">void</span> loop2() {</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="cf">for</span> ( i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) { ... }</a>
<a class="sourceLine" id="cb5-7" title="7">}</a></code></pre></div>
<h5 id="comments.">Comments.</h5>
<p>In C comments always begin with <code>/*</code> and end with <code>*/</code>. The style of comment like <code>// This is a comment</code> may be permitted by your compiler but this is not supported everywhere. Please use C-style comments.</p>
<h5 id="structures.">Structures.</h5>
<p>Perhaps the most striking difference in C for those coming from an Object-Oriented Programming language is that C has no such concept. There are no classes, and no class hierarchy, no interfaces or abstract classes, none of that. There are no access control modifiers (<code>public, private</code>, etc).</p>
<p>What we have instead for programmer-defined types is the <em>structure</em>, the <code>struct</code>. A structure is the forerunner of the class but is much simpler: it is a grouping of variables, and nothing more. A structure is composed of a group of variables as one might expect. A simple structure representing a 3-dimensional cartesian coordinate:</p>
<div class="sourceCode" id="cb6" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> point {</a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="dt">double</span> z;</a>
<a class="sourceLine" id="cb6-5" title="5">};</a></code></pre></div>
<p>In the example, all three elements are defined as <code>double</code> but there’s no reason why they have to be the same (they can be anything). The following short example shows creating a <code>struct point</code> and assigning some values. As you would expect, the attributes of the structure are accessed with the dot operator (<code>.</code>):</p>
<div class="sourceCode" id="cb7" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">struct</span> point p1;</a>
<a class="sourceLine" id="cb7-2" title="2">p1.x = <span class="fl">1.9</span>;</a>
<a class="sourceLine" id="cb7-3" title="3">p1.y = <span class="fl">2.5</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">p1.z = -<span class="fl">1.0</span>;</a></code></pre></div>
<h5 id="type-names.">Type Names.</h5>
<p>In the previous example when we want to use the <code>point</code> structure as defined, we have to write <code>struct point</code> as the full name of the type. This can result in a lot of typing of the keyword <code>struct</code> such as in a function like this:</p>
<div class="sourceCode" id="cb8" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">struct</span> point add( <span class="kw">struct</span> point p1, <span class="kw">struct</span> point p2 ) { ... }</a></code></pre></div>
<p>Fortunately, we are provided another keyword that will reduce the amount of typing that we have to do. This is the <code>typedef</code> keyword. The keyword precedes a structure definition, and after the definition there is the new name you’d like to use.</p>
<div class="sourceCode" id="cb9" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> point {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="dt">double</span> z;</a>
<a class="sourceLine" id="cb9-5" title="5">} point_t;</a></code></pre></div>
<p>This would allow you to rewrite the previous function call as a more compact form:</p>
<div class="sourceCode" id="cb10" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1">point_t add( point_t p1, point_t p2 ) { ... }</a></code></pre></div>
<p>You can (if you want) use <code>typedef</code> on other things, such as <code>typedef int pid_t</code> which allows you to use your own names for certain things if you have a reason (as we’ll see later).</p>
<p>A small note on the naming convention: it is now discouraged to use the <code>_t</code> ending on the name of a programmer-defined type. Hopefully the UNIX police will not arrest me based on the previous example. Nevertheless, when we do some future examples, we will see that there are types (like <code>pid_t</code>) where this convention holds. But regardless, it’s just convention, not law, and using it (or not using it) isn’t wrong.</p>
<p>You may also notice that in the definition there is the <code>point</code> name after the <code>struct</code> keyword and this is not used anywhere once we have finished the <code>typedef</code> definition. It can be omitted and the definition would just be:</p>
<div class="sourceCode" id="cb11" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="dt">double</span> x;</a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="dt">double</span> y;</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="dt">double</span> z;</a>
<a class="sourceLine" id="cb11-5" title="5">} point_t;</a></code></pre></div>
<p>And this would be exactly equivalent to the previous definition.</p>
<h5 id="memory-allocation-deallocation-and-pointers">Memory Allocation, Deallocation, and Pointers</h5>
<p>Your program has three kinds of memory: global variables, stack, and heap. Memory that is allocated on the stack is local to the function currently running and will automatically be thrown away when the function returns. Memory that is allocated on the heap is explicitly asked for and must also be explicitly returned as well. Stack memory is somewhat limited; heap is very large (although not infinite). In some programming languages one may get away without knowing the difference, but this is C...</p>
<p>Stack allocated memory is fairly simple. In the example below, <code>bar</code> is a variable allocated on the stack. The lifetime of this variable is just as long as <code>foo</code> runs.</p>
<div class="sourceCode" id="cb12" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="dt">void</span> foo() {</a>
<a class="sourceLine" id="cb12-2" title="2"> <span class="dt">int</span> bar;</a>
<a class="sourceLine" id="cb12-3" title="3"> ...</a>
<a class="sourceLine" id="cb12-4" title="4">}</a></code></pre></div>
<p>It’s important to remember that the variable <code>bar</code> has no initial value. It has to be initialized to some value, otherwise it simply contains garbage. This is a key step and a frequent source of error in programs. Even students in 4th year with a great deal of programming experience sometimes forget to initialize variables and spend many hours debugging their programs.</p>
<p>Global variables are variables declared outside of any function. Although they can be used for good, excessive use of them is a warning sign of poor program design. Global variable space is also not infinite. While we might use global variables in the class for simple examples or to make an exam question simpler, in real life it is usually better to avoid them. Global variables may be initialized for you to zero or something like it, but it is best not to count on this and to initialize the variables.</p>
<p>In C, heap memory is allocated in a very simple way: you ask for the amount of memory that you want. The function for this is <code>malloc()</code> and it takes one parameter – the number of bytes of memory that you want. So if we want to allocate an integer on the heap, we need to call <code>malloc()</code> and request the number of bytes that correspond to an <code>int</code>. But how many bytes is that?</p>
<p>You may think the answer is 4 bytes, but a quick look at the C standard says that while there are are exact sizes for some types, other types have only a minimum size. The rest is implementation specific. That is, it can vary from one system to another. Yikes! Fortunately we have <code>sizeof</code>, which ask the compiler to help us out here and substitute in the correct size where it is needed. So we would call <code>malloc()</code> with the argument <code>sizeof( int )</code>. At run time, the correct amount of memory will be requested.</p>
<p>This is also very helpful for when you want to allocate a structure. Instead of needing to work out the size yourself (well, this is three <code>double</code>s, and a <code>double</code> is 8 bytes...), <code>sizeof( point_t )</code> will allocate the correct size... as a nice bonus, if ever the definition of the structure is changed the amount of memory requested is updated automatically.</p>
<p>The return value of <code>malloc()</code> is a pointer to the memory that is allocated. Unlike , the value does not need to be cast (and probably shouldn’t be).
Consider the following allocation:</p>
<div class="sourceCode" id="cb13" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">void</span> example( ) {</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="dt">int</span> * x = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb13-3" title="3">  ...</a>
<a class="sourceLine" id="cb13-4" title="4">}</a></code></pre></div>
<p>The variable <code>x</code> is a pointer to an integer, and it is allocated on the stack. The value contained in <code>x</code> is the address of the memory that was allocated by <code>malloc()</code>. That memory currently contains garbage because it has not been initialized. To initialize it, of course, we just assign it a value as below:</p>
<div class="sourceCode" id="cb14" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="dt">void</span> example( ) {</a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">int</span> * x = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb14-3" title="3">  *x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb14-4" title="4">}</a></code></pre></div>
<p>When we are finished with memory, it is proper to deallocate it using <code>free()</code>. This function takes a pointer to the memory that is to be deallocated and lets the operating system know that we are finished with this memory. We don’t have to specify the number of bytes being returned, because it will be the same as was originally allocated and this is tracked by the system’s memory allocator. So the complete example:</p>
<div class="sourceCode" id="cb15" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="dt">void</span> example( ) {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="dt">int</span> * x = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb15-3" title="3">  *x = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb15-4" title="4">  ...</a>
<a class="sourceLine" id="cb15-5" title="5">  free( x );</a>
<a class="sourceLine" id="cb15-6" title="6">}</a></code></pre></div>
<p>If we forget to deallocate some memory that is allocated, this is a <em>memory leak</em> and this is a bad thing. It may not have immediate bad effects, but it is wrong and in the long term (such as a program that runs 24/7) memory leaks will slow down the program and can eventually lead to a crash. When memory is being allocated, you should always take a moment to consider where it is to be deallocated. The call to <code>free()</code> should be when the memory is no longer needed (ideally as soon as possible after this is known), but it may be in a different function altogether.</p>
<p>A provided function <code>a()</code> might, for example, allocate the memory and return a pointer to it for your use and it is then your responsibility to deallocate this memory when you no longer need it. Reading the documentation (or source code) of a function will tell you if this is the case. Or, you may pass memory between two (or more) functions you have written in your program; just be sure to check the “flow” of the data to be sure that anything that was allocated gets deallocated.</p>
<p>It is worth noting that <code>free()</code> just marks the memory as being available; it doesn’t actually erase what is there. So you might be able to use memory after marking it as free. Murphy’s Law suggests that this will work just fine when you test your code but will crash the program every time when it is in production (or the TA is marking it). To reduce the likelihood of this, some coding conventions ask you to assign a pointer to 0 after it has been freed. This guarantees that a future attempt to use that same pointer will crash.</p>
<p>Also noteworthy: if you try to call <code>free()</code> on the same pointer twice, this will very likely crash your program immediately. Similarly, if you try to free memory that was allocated on the stack rather than on the heap, this also leads swiftly to a crash.</p>
<h5 id="dereferencing-address-of-and-the-arrow.">Dereferencing, Address-Of, and The Arrow.</h5>
<p>You will recall from some basics about how pointers work that the <code>*</code> symbol is used to declare something a pointer, and to <em>dereference</em> the pointer (follow the directions to the memory on the heap). This is also used when we are expecting a value. If we have a function defined like this:</p>
<div class="sourceCode" id="cb16" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">int</span> work( <span class="dt">int</span> x, <span class="dt">int</span> y ) {</a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="cf">return</span> x + y;</a>
<a class="sourceLine" id="cb16-3" title="3">}</a></code></pre></div>
<p>And our variables are allocated on the heap then we know how to use them in a function call as below.</p>
<div class="sourceCode" id="cb17" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">void</span> baz() {</a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="dt">int</span>* a = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb17-3" title="3">  *a = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="dt">int</span>* b = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb17-5" title="5">  *b = <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb17-6" title="6">  </a>
<a class="sourceLine" id="cb17-7" title="7">  <span class="dt">int</span> z = work( *a, *b );</a>
<a class="sourceLine" id="cb17-8" title="8">  free( a );</a>
<a class="sourceLine" id="cb17-9" title="9">  free( b );</a>
<a class="sourceLine" id="cb17-10" title="10">}</a></code></pre></div>
<p>But suppose the situation is reversed; the function <code>work()</code> is now defined like this:</p>
<div class="sourceCode" id="cb18" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">int</span> work( <span class="dt">int</span> * x, <span class="dt">int</span> * y ) {</a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="cf">return</span> *x + *y;</a>
<a class="sourceLine" id="cb18-3" title="3">}</a></code></pre></div>
<p>And our variables <code>a</code> and <code>b</code> are stack allocated? To invoke this function we use <code>&amp;</code>, the address-of operator.</p>
<div class="sourceCode" id="cb19" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="dt">void</span> baz() {</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="dt">int</span> a = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="dt">int</span> b = <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="dt">int</span> z = work( &amp;a, &amp;b );</a>
<a class="sourceLine" id="cb19-6" title="6">}</a></code></pre></div>
<p>In short, the function is expecting a pointer to an integer but we have a regular integer allocated on the stack. We can feed the function <code>work()</code> a pointer to that stack-allocated memory using the address-of operator. It needs to be used with caution, however, because of the fact that stack allocated memory does not outlive the function it is allocated in... and sometimes does not outlive a particular iteration of a loop. We will use this in a number of examples, but if your program is not behaving as expected you should check places where this is used as it can be a source of issues.</p>
<p>The “Arrow” operator is a nice notational shorthand. If we allocate a structure on the heap, and want to assign one of the members of that structure, we write something like this: <code> (*p1).x = 99.9; </code>. An equivalent statement that results in the same outcome but looks a little neater: <code>p1-&gt;x = 99.9;</code>. These two statements are perfectly interchangeable. If you really prefer one style, use that style. If the Arrow makes no sense to you<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> you don’t have to use it.</p>
<h5 id="arrays.">Arrays.</h5>
<p>Arrays can be either stack or heap allocated, as you would expect. A stack allocated array is fairly simple, where you use the square brackets to specify the size that you want, as below:</p>
<div class="sourceCode" id="cb20" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="dt">int</span> array[<span class="dv">10</span>];</a></code></pre></div>
<p>Now the stack has an array named <code>array</code> of capacity 10 integers, all of which, remember, contains garbage because it has not been initialized. For a small array, or one that doesn’t need to last very long, this suffices. But it is much more likely that we need to allocate arrays on the heap:</p>
<div class="sourceCode" id="cb21" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="dt">int</span>* array = malloc( <span class="dv">10</span> * <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a></code></pre></div>
<p>This looks weird, but this is how we do it we asked for enough memory to hold 10 integers and this will be our array. But yes, an integer pointer could point to only one integer or to an array of integers. When deallocating this memory, the call is still <code>free( array ) </code> (unlike there’s no difference when deallocating an array).</p>
<p>Either way, to assign elements of the array we use the square brackets operators, like <code>array[0] = 5;</code>. There’s no difference in whether or not it is stack or heap allocated when we do this.</p>
<p>As said, the array needs to be initialized, regardless of whether it is stack or heap allocated. The simple way would be a for loop:</p>
<div class="sourceCode" id="cb22" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">int</span> * array = malloc( <span class="dv">10</span> * <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) {</a>
<a class="sourceLine" id="cb22-3" title="3">  a[i] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-4" title="4">}</a></code></pre></div>
<p>This is nice but as you might realize this could take a long time for a sufficiently large array. There is a nice shortcut you can use (if you include the <code>string.h</code> header). It is called <code>memset</code>. It takes three arguments: a pointer to the memory you want to set, the value you want to initialize it to (the function does unsigned char conversion here, so pretty much this is only good for initializing to 0), and then how many bytes should be set:</p>
<div class="sourceCode" id="cb23" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">int</span> * array = malloc( <span class="dv">10</span> * <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb23-2" title="2">memset( array, <span class="dv">0</span>, <span class="dv">10</span> * <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a></code></pre></div>
<p>There are no automatic bounds checking for arrays, and C will gladly let you try to read the 12th element of a capacity-10 array. You will either read garbage or perhaps crash your program. When iterating over an array, you will need to know in advance how long the array is so you know when to terminate the loop. For that reason, when an array is passed as an argument to a function, another variable is used to specify the length.</p>
<h5 id="strings.">Strings.</h5>
<p>As far as C is concerned, a string is just a character array (and is generally just <code>char*</code>. In C, a string is of arbitrary length and terminates with a byte of zero (or if you prefer, <code>NULL</code>). This is distinct from the character “0” which has a nonzero value. If you put a string literal in some code like <code>"Hello World"</code> then the compiler will graciously add the null-terminator for you. If you are composing a string, however, then you need to remember to add it (and the char for it is <code>’\0’</code>). And either way you should also remember to make room for the null terminator when allocating memory or calculating the length of a string.</p>
<h5 id="function-convention.">Function Convention.</h5>
<p>Because there are no member functions for data objects the convention is generally that the first parameter to a function is modified. Thus, an initialization routine will take several arguments: the first being whatever it is we wish to initialize, then further arguments that are used to initialize this structure. Or, if a function modifies a struct, it is typically the first one that is changed:</p>
<div class="sourceCode" id="cb24" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">int</span> initialize_header( <span class="kw">struct</span> header * h, <span class="dt">int</span> v1, <span class="dt">double</span> v2, <span class="kw">struct</span> blah * v3 );</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="dt">void</span> addToPoint( point p1, point p2 );</a></code></pre></div>
<p>This is not a firm rule and there are examples that contradict this. But it is convention and will be seen frequently.</p>
<p>In this same vein, many functions have integer return types. Because the first parameter structure is being modified, the return value is an integer that is the “result code”. If everything went well this is usually zero. If there was a problem, then it’s a nonzero number and the number can help you figure out what’s wrong. For example, a return value of 36 might be something you can look up in the documentation and find out that the value used for the third argument is too large.</p>
<p>Also noteworthy: there is a header <code>errno.h</code> that defines a variable <code>errno</code>. Many functions and library calls set the value of this variable if something goes wrong during their execution. Knowing what precisely went wrong can be very valuable when debugging your program.</p>
<p>If you want to read <code>errno</code> (or print it) then you include the header and declare <code>extern int errno;</code> in your program. Then, when a function call that uses it has a problem, you can use <code>errno</code> by, for example, printing an error message. The header file contains definitions of numerous standard error values such as <code>EIO</code> for “Error in Input/Output”. Check the documentation to get the full picture – there are a lot of them. But learning that your network call is code 111, <code>ECONNREFUSED</code> (connection refused) is a lot more helpful than just getting back <code>-1</code> as a return code.</p>
<h5 id="printing.">Printing.</h5>
<p>Writing to the console is done using the <code>printf()</code> function. This function formats a string and writes it to the console. In a simple example, the Hello World program would contain the following print statement:</p>
<div class="sourceCode" id="cb25" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1">printf(<span class="st">&quot;Hello World</span><span class="sc">\n</span><span class="st">&quot;</span>);</a></code></pre></div>
<p>Note that the <code>"\n"</code> in there is a newline character, which should probably not be forgotten if you want your printout to look right.</p>
<p>In addition to this, <code>printf()</code> does <em>formatted</em> printing. When we have values that need to appear in the output, we use a <em>format specifier</em>. The format specifier tells the printf how to format the value. The value is then given as an argument after the string. Order matters: the first format specifier encountered will match to the first argument after the string.</p>
<div class="sourceCode" id="cb26" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">int</span> x = -<span class="dv">25</span>;</a>
<a class="sourceLine" id="cb26-2" title="2">...</a>
<a class="sourceLine" id="cb26-3" title="3">printf(<span class="st">&quot;The value of x is %d</span><span class="sc">\n</span><span class="st">&quot;</span>, x);</a></code></pre></div>
<p>Results in printing to the console <code>The value of x is -25</code> (and a newline character after it). In this example the format specifier <code>%d</code> is used for a signed integer (or <code>%i</code> would do the same). There are different format specifiers for different types: unsigned integers, floating point numbers, scientific notation, even a string. There are many options but we do not wish to belabour the point by putting them all here. But be sure you chose the right one: if you have a <code>double</code> and you try to print it with an <code>int</code> format specifier, it will look like the data contains garbage (yes, I have helped someone debug this).</p>
<p>Or another example:</p>
<div class="sourceCode" id="cb27" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1">point p1 = malloc( <span class="kw">sizeof</span>( point ) );</a>
<a class="sourceLine" id="cb27-2" title="2">p1-&gt;x = <span class="fl">9.5</span>;</a>
<a class="sourceLine" id="cb27-3" title="3">p1-&gt;y = -<span class="fl">5.4</span>;</a>
<a class="sourceLine" id="cb27-4" title="4">p1-&gt;z = <span class="fl">0.1</span>;</a>
<a class="sourceLine" id="cb27-5" title="5">printf(<span class="st">&quot;(%f, %f, %f)</span><span class="sc">\n</span><span class="st">&quot;</span>, p1-&gt;x, p1-&gt;y, p1-&gt;z);</a></code></pre></div>
<p>Results in printing <code>(9.5, -5.4, 0.1)</code>. As you see, the <code>printf()</code> routine takes an arbitrary number of parameters. If the string contains 5 format specifiers, then the string is followed by five arguments. If the string contains 10 format specifiers, then there are 10 arguments after the string. If you have 3 format specifiers but only 2 arguments after the string, <code>printf()</code> will take whatever value is next on the stack which may be garbage.</p>
<h5 id="define-directives.">Define Directives.</h5>
<p>It is possible to use a precompiler directive for fixed values in your program. This is the <code>#define</code> directive. Placing them at the top of the program is common. They are then used throughout the program to avoid “magic numbers” (i.e., numeric values that have no obvious meaning). Creation is like this:</p>
<div class="sourceCode" id="cb28" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="pp">#define BUFFER_SIZE 1000</span></a></code></pre></div>
<p>And then later in the program it will be used:</p>
<div class="sourceCode" id="cb29" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="dt">char</span>* buffer = malloc( BUFFER_SIZE );</a></code></pre></div>
<p>When the program is compiled, the compiler replaces <code>BUFFER_SIZE</code> everywhere with its definition. If used in many places, changing the definition in the central location saves you from having to change it everywhere.</p>
<p>There is a small potential pitfall in this though; the compiler is VERY literal about how it makes the replacement. So if the directive is <code>#define VALUE 2 * 25 + 4</code>, then you will get the wrong answer if that’s later used in something like <code>int size = VALUE * 2;</code>, because the compiler will make it <code>int size = 2 * 25 + 4 * 2;</code> for a total size of 58 rather than 108. This can be avoided by putting parenthesis <code>#define VALUE (2 * 25 + 4)</code>. Because BEDMAS.</p>
<h5 id="main-and-arguments.">Main and Arguments.</h5>
<p>A program begins at the start of <code>main</code> and the signature is as follows:</p>
<div class="sourceCode" id="cb30" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb30-2" title="2">  ...</a>
<a class="sourceLine" id="cb30-3" title="3">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb30-4" title="4">}</a></code></pre></div>
<p>The variable <code>argc</code> returns the count of the number of arguments to the program. The variable <code>argv</code> has two stars... because it is a pointer to an array of <code>char*</code> (if it helps you, imagine <code>char**</code> as <code>(char*)*</code>). This second variable is a pointer to an array of the actual text arguments. Let’s imagine we invoke a program like this:</p>
<div class="sourceCode" id="cb31" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1">jz@Tyr:~$ ./a.out Hello <span class="dv">17</span></a></code></pre></div>
<p>In this case, the value of <code>argc</code> is 3. The first argument is always the name of the executable, and thus <code>argv[0]</code> is <code>"./a.out"</code> (as a “string”). Then <code>argv[1]</code> is <code>"Hello"</code>, and <code>argv[2]</code> is <code>"17"</code>. The use of quotation marks is not a coincidence or oversight: it is a string and not the number 17. If we actually want to convert it, we need to parse it to an integer with a function like <code>atoi()</code>, such as <code>int value = atoi( argv[2] );</code>.</p>
<p>It is convention that the <code>main</code> method returns 0 if everything went well in the program and a different value if something went wrong. So if the wrong number of parameters is provided, you might end the program with <code>return -1;</code>.</p>
<h5 id="void-pointers.">Void Pointers.</h5>
<p>A construct we will use frequently is <code>void *</code>. It’s not a pointer to nothing; it is a pointer with no type. This is the way of saying there is a pointer with no specific type. We’ve already seen an example of how to use it. The function <code>memset</code> takes as its first argument a void pointer. That is to say, this function does not care what the type of the pointer that it is provided is. So we can initialize an array of <code>int, char, double, point_t</code>, anything we like. This is but one example where untyped pointers will be used; we will see many more.</p>
<h1 id="interrupts-system-calls" class="unnumbered">2 — Interrupts &amp; System Calls</h1>
<h2 id="computer-organization" class="unnumbered">Computer Organization</h2>
<p>Although a regular program like a word processor need not be concerned with the underlying hardware of the computer, this abstraction does not come for free: the operating system must be aware of these details and manage them for everyone. What is a program, anyway? You will know from your programming experience that a program is just a sequence of instructions and some data. Thus, to execute a program, we will need a few things:</p>
<ol>
<li><p><strong>Main Memory</strong> – a place where the instructions and data are stored;</p></li>
<li><p><strong>System Bus</strong> – a way for instructions and data to travel between memory and the processor; and</p></li>
<li><p><strong>Processor</strong> – that critical element of the system that actually executes the instructions.</p></li>
</ol>
<p>For our purposes we are really only interested in talking about the processor, because it matters in the context of interrupts, which is our real goal.</p>
<h3 id="the-processor" class="unnumbered">The Processor</h3>
<p>The Processor (or <em>CPU</em>, central processing unit) is the brain of the computer. It fetches instructions from memory, via the bus, decodes the instruction, then executes it. This fetch-decode-execute cycle will be repeated until the program finishes (... if the program finishes). The different steps may be executed in parallel: while one instruction is being executed, the next is being decoded, and the one after that is being fetched. We call this a <em>pipeline</em>, and the length and complexity of the pipeline is something we will not examine here, but is an interesting subject all its own. A processor’s largest unit on which it operates is called a <em>word</em>. A 32-bit processor has a word size of 32 bits and a 64-bit processor has a word size of 64 bits.</p>
<p>CPU instructions are, obviously, specific to the processor. If you have any experience in writing assembly code, you have probably used some books that tell you all the instructions that can be issued and what operands, if any, those instructions take. In some CPU architectures, some operations are available only in “supervisor mode” and not in “user mode”. An instruction that disables interrupts is an example of an instruction that would be available only in supervisor mode. Attempting to run it in user mode will be an error.</p>
<p>In addition to the hardware to decode and execute the different instructions, the CPU has some storage locations called <em>registers</em>. They may store data or instructions (they are both, after all, just a bunch of bits). Registers are a key concept in CPUs and management of those registers is partly the responsibility of the operating system. Registers are used to hold key variables and temporary results. Registers are often, but not always, word-sized.</p>
<h3 id="interrupts" class="unnumbered">Interrupts</h3>
<p>The CPU frequently needs data to continue its operations, but it can take a variable amount of time to get it, depending on where it’s coming from. An analogy to put it in perspective: imagine I am the CPU and a particular book is the piece of data needed. If the data is in the cache, it is as if the book is on a bookshelf in my office. Thus, I can retrieve the book very quickly. If the data for the CPU on a magnetic hard disk, it is as if I would have to get the book from Library and Archives Canada in Ottawa (about 550 km away, according to Google Maps). And I would have to walk. Of course, the analogy is slightly tortured because the CPU doesn’t go get the data; instead it must wait for it to arrive. If I ordered a book from Library and Archives Canada and someone had to walk it over, I would spend a lot of time waiting. What might I do in the meantime...?</p>
<p>It seems logical that I should do something else. There are two options for dealing with this situation. One is polling: that I can check periodically if the book has arrived. This approach is fairly wasteful (how often do I check? How much time will I spend checking?). The other solution is that I can receive a notification when the poor fellow who has walked the 550 km to my office has arrived. If he knocks on my office door, it will cause me to suspend what I am doing and collect the book. Or, to put it in one word: interrupts.</p>
<p>In that analogy I played the part of the CPU, and was interrupted and had to deal with that interruption. We have the same in computer systems. When an interrupt happens, the normal sequencing of the processor does not continue. Interrupts can come from many sources <span class="citation" data-cites="osi"></span>:</p>
<ol>
<li><p><strong>Program:</strong> Something happens in the program (e.g., a division by zero).</p></li>
<li><p><strong>Timer:</strong> A configured timer within the processor’s time expires (e.g., to update the system clock).</p></li>
<li><p><strong>Input/Output:</strong> An I/O controller signals (un)successful completion of an operation (e.g., read from disk).</p></li>
<li><p><strong>Hardware Failure:</strong> Something happens in hardware (e.g., power failure).</p></li>
</ol>
<p>Interrupts are primarily a way to improve processor utilization (i.e., the fraction of the time the CPU is doing useful work). CPU time is valuable and the CPU can and should do something else while it is awaiting the results of some other operation. Thus, the CPU might issue a read from memory instruction, work on something else, and then be interrupted when the data has arrived from memory.</p>
<p>When an interrupt takes place, the processor might choose to ignore it, but this is rare. Interruptions usually contain important information. Almost always, we will want to <em>handle</em> (deal with) the interrupt in some way.</p>
<p>Consider an analogy with which you are surely familiar: a professor is at the front of the lecture hall droning on about some subject. A student raises her hand to ask a question. The professor can ignore this, but that is generally a bad idea. The professor should pause what he is doing (pause execution), remembering where he was (save state), take the question and answer it (handle the interrupt), and then resume from where he left off (restore the saved state and continue execution).</p>
<p>The operating system is responsible for storing the state of the program being interrupted, handling the interrupt, and then restoring the state of the program that was interrupted.</p>
<p>Sometimes the CPU is in the middle of something where an interruption would be bad. Thus, interrupts can be disabled. This is like the professor saying that all questions should be saved until the end of the lecture. Once interrupts are enabled again, the interruptions can be handled. So all the questions that students have saved can be answered. Interrupts tend to have a priority, so if multiple interrupts are pending, the highest priority one will be dealt with first.</p>
<p>There can also be multiple interrupts happening in a short period of time: suppose interrupt 1 occurs and then interrupt 2 occurs while interrupt 1 is still being handled. Often, but not always, interrupt handlers themselves disable interrupts so a subsequent interrupt will be handled after the current one is dealt with. Or, interrupt 2 may itself interrupt the first. Consider the diagrams below:</p>
<p><img src="images/interrupts.png" alt="image" style="width:45.0%" /><br />
Top: Sequential interrupt handling. Bottom: Nested interrupt handling. <span class="citation" data-cites="osi"></span></p>
<p>A combination of these different techniques may be used. A low priority interrupt handler may be suspended to deal with a high priority interrupt. Suppose while the high priority interrupt is being handled, a medium priority interrupt occurs. The high priority interrupt handler will be allowed to complete its work before the medium priority interrupt is dealt with.</p>
<h5 id="storing-and-restoring-state.">Storing and Restoring State.</h5>
<p>We mentioned already that the operating system is responsible for storing the state of the program (or interrupt handler) being interrupted when an interrupt occurs. To do so, the state of the CPU is what must be stored. The values of the various registers (e.g., program counter, instruction register, etc.) are stored by pushing them onto the stack. When the interrupt is finished, those values are popped off the stack and loaded into the registers again. After that, program execution continues (almost) as if the interruption never took place.</p>
<h5 id="multiprogramming.">Multiprogramming.</h5>
<p>Thus far we have assumed that there is a program running and that same program is the one that resumes at the end of the interrupt handling. This is, however, not always the case. Given that we have stored the state of the interrupted program, the OS can resume it any time we like, and run a different program now instead. But which program should run next? This is a matter of scheduling and from our view in application programming, out of our control (mostly but not entirely).</p>
<h2 id="its-a-trap" class="unnumbered">It’s a Trap!</h2>
<p>Operating systems run, as previously discussed, on interrupts. In addition to the interrupts that will be generated by hardware and devices (e.g., a keyboard signalling that the F1 key has been pressed), there are also interrupts generated in software. These are often referred to as a <em>trap</em> (or, sometimes, an exception). The trap is usually generated either by an error like an invalid instruction or from a user program request.</p>
<p>If it is simply an error the operating system will decide how to deal with it, and in desktop/laptop OSes, the usual strategy is sending the exception to the program that caused it, and this is usually fatal to the offending program. Your programming experience will tell you that you can sometimes deal with an exception (perhaps through the language equivalent of the Java/C# <code>try-catch-finally</code> syntax), but often an exception is unhandled and terminates the program.</p>
<p>The more interesting case is the intentional use of the trap: this is how a user program gets the operating system’s attention. When a user program is running, the operating system is not; we might even say it is “sleeping”. If the program running needs the operating system to do something, it needs to wake up the OS: interrupt its sleep. When the trap occurs, the interrupt handler (part of the OS) is going to run to deal with the request.</p>
<p>Already we saw the concept of user mode vs. supervisor mode instructions: some instructions are not available in user mode. Supervisor mode, also called kernel mode, allows all instructions and operations. Even something seemingly simple like reading from disk or writing to console output requires privileged instructions. These are common operations, but they involve the operating system every time.</p>
<p>Modern processors keep track of what mode they are in with the mode bit. This was not the case for some older processors and some current processors have more than two modes, but we will restrict ourselves to dual-mode operation with a mode bit. Thus we can see at a glance which mode the system is in. At boot up, the computer starts up in kernel mode as the operating system is started and loaded. User programs are always started in user mode. When a trap or interrupt occurs, and the operating system takes over, the mode bit is set to kernel mode; when it is finished the system goes back to user mode before the user program resumes <span class="citation" data-cites="osc"></span>.</p>
<p>Suppose a text editor wants to output data to a printer. Management of I/O devices like printers is the job of the OS, so to send the data, the text editor must ask the OS to step in, as in the diagram below:</p>
<p><img src="images/trap.png" alt="image" style="width:75.0%" /><br />
Transition from user to supervisor (kernel) mode <span class="citation" data-cites="osc"></span>.</p>
<p>So to print out the data, the program will prepare the data for printing. Then it calls the system call. You may think of this as being just like a normal function call, except it involves the operating system. This triggers the operating system (with a trap). The operating system responds and executes the system call and dispatches that data to the printer. When this job is done, operation goes back to user mode and the program returns from the system call.</p>
<h3 id="motivation-for-dual-mode-operation" class="unnumbered">Motivation for Dual Mode Operation</h3>
<p>Why do we have user and supervisor modes, anyway? As Uncle Ben told Spiderman, “with great power comes great responsibility”. Many of the reasons are the same as why we have user accounts and administrator accounts: we want to protect the system and its integrity against errant and malicious users.</p>
<p>An example: multiple programs might be trying to use the same I/O device at once. If Program 1 tries to read from disk, it will take time for that request to be serviced. During that time, if Program 2 wants to read from the same disk, the operating system will force Program 2 to wait its turn. Without the OS to enforce this, it would be up to the author(s) of Program 2 to check if the disk is currently in use and to wait patiently for it to become available. That may work if everybody plays nicely, but without someone to enforce the rules, sooner or later there will be a program that does something nasty, like cancel another program’s read request and perform its read first.</p>
<p>This doesn’t come for free, of course: there is a definite performance trade-off. Switching from user mode to kernel mode requires some instructions and some time. It would be faster if everything ran in kernel mode because we would spend no time switching. Despite this, the performance hit for the mode switch is judged worthwhile for the security and integrity benefits it provides.</p>
<h3 id="example-reading-from-disk" class="unnumbered">Example: Reading from Disk</h3>
<p>Let us examine in some more detail what is actually happening in a
system call. This example is from <span class="citation" data-cites="mos"></span> and will use C code to
perform a read on a UNIX system. The specification says the function
<code>read</code> takes three parameters: (1) the file (a file
descriptor, from a previous call to <code>open</code>); (2) where to read
the data to; and (3) how many bytes to read. Here is an example:</p>
<div class="sourceCode" id="cb32" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="dt">int</span> bytesRead = read( file, buffer, numBytes );</a></code></pre></div>
<p>(The <code>read</code> function returns the number of bytes successfully read; it is normally equal to <code>numBytes</code> but might be smaller if the end of the file is reached. Here we are storing it in a variable <code>bytesRead</code>.)</p>
<p>In preparation for invocation of <code>read</code> the parameters are pushed on the stack. This is the normal way in which a procedure is called in C(++). Then the <code>read</code> procedure is called and this is just the normal instruction to enter another function. The <code>read</code> function will put its identifier (the system call number) in a predefined location (typically a register). Then it executes the <code>trap</code> instruction, activating the OS.</p>
<p>When the <code>trap</code> occurs, the OS takes over and control switches from user mode to kernel mode. Control transfers to a predefined memory location within the kernel (the trap handler). The trap handler then runs and examines the request: it checks the identifier that was put in the register earlier. Based on that, it knows what system call request handler should execute: the one to read from a file. That routine executes. When it is finished, control will be returned to the <code>read</code> function; we exit the kernel and return to user mode.</p>
<p>Back in user mode, the <code>read</code> call finishes and returns, and control goes back to the user program.</p>
<p>Let’s consider a more complex example. This uses some Linux specific items, but is a quick example of a program that reads a file and prints it out:</p>
<div class="sourceCode" id="cb33" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb33-6" title="6"></a>
<a class="sourceLine" id="cb33-7" title="7"><span class="dt">void</span> readfile( <span class="dt">int</span> fd );</a>
<a class="sourceLine" id="cb33-8" title="8"></a>
<a class="sourceLine" id="cb33-9" title="9"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb33-10" title="10">    <span class="cf">if</span> ( argc != <span class="dv">2</span> ) {</a>
<a class="sourceLine" id="cb33-11" title="11">        printf(<span class="st">&quot;Usage: %s &lt;filename&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">0</span>]);</a>
<a class="sourceLine" id="cb33-12" title="12">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-13" title="13">    }</a>
<a class="sourceLine" id="cb33-14" title="14">    <span class="dt">int</span> fd = open( argv[<span class="dv">1</span>], O_RDONLY );</a>
<a class="sourceLine" id="cb33-15" title="15">    <span class="cf">if</span> ( fd == -<span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb33-16" title="16">        printf(<span class="st">&quot;Unable to open file! %s is invalid name?</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb33-17" title="17">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb33-18" title="18">    }</a>
<a class="sourceLine" id="cb33-19" title="19">    readfile( fd );</a>
<a class="sourceLine" id="cb33-20" title="20">    close( fd );</a>
<a class="sourceLine" id="cb33-21" title="21">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb33-22" title="22">}</a>
<a class="sourceLine" id="cb33-23" title="23"></a>
<a class="sourceLine" id="cb33-24" title="24"><span class="dt">void</span> readfile( <span class="dt">int</span> fd ) {</a>
<a class="sourceLine" id="cb33-25" title="25">    <span class="dt">int</span> buf_size = <span class="dv">256</span>;</a>
<a class="sourceLine" id="cb33-26" title="26">    <span class="dt">char</span>* buffer = malloc( buf_size );</a>
<a class="sourceLine" id="cb33-27" title="27">    <span class="cf">while</span> ( <span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb33-28" title="28">        memset( buffer, <span class="dv">0</span>, buf_size );</a>
<a class="sourceLine" id="cb33-29" title="29">        <span class="dt">int</span> bytes_read = read( fd, buffer, buf_size  - <span class="dv">1</span>);  </a>
<a class="sourceLine" id="cb33-30" title="30">        <span class="cf">if</span> ( bytes_read == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb33-31" title="31">            <span class="cf">break</span>; </a>
<a class="sourceLine" id="cb33-32" title="32">        }     </a>
<a class="sourceLine" id="cb33-33" title="33">        printf(<span class="st">&quot;%s&quot;</span>, buffer);</a>
<a class="sourceLine" id="cb33-34" title="34">    }</a>
<a class="sourceLine" id="cb33-35" title="35">    printf(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">End of File.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb33-36" title="36">    free( buffer );</a>
<a class="sourceLine" id="cb33-37" title="37">}</a></code></pre></div>
<h3 id="summary-invoking-a-system-call" class="unnumbered">Summary: Invoking a System Call</h3>
<p>To summarize, the steps, arranged chronologically, when invoking a system call are:</p>
<ol>
<li><p>The user program pushes arguments onto the stack.</p></li>
<li><p>The user program invokes the system call.</p></li>
<li><p>The system call puts its identifier in the designated location.</p></li>
<li><p>The system call issues the <code>trap</code> instruction.</p></li>
<li><p>The OS responds to the interrupt and examines the identifier in the designated location.</p></li>
<li><p>The OS runs the system call handler that matches the identifier.</p></li>
<li><p>When the handler is finished, control exits the kernel and goes back to the system call (in user mode).</p></li>
<li><p>The system call returns control to the user program.</p></li>
</ol>
<h1 id="the-file-system" class="unnumbered">3 — The File System</h1>
<h2 id="file-systems" class="unnumbered">File Systems</h2>
<p>The file system is important and very useful to programs. It is more than just the way of storing data and programs persistently; it also provides organization for the files through a directory structure and maintains metadata related to files.</p>
<p>But what is a file? The snarky UNIX answer is, “Everything is a file!”, but using the word in the definition is rather bad form. As far as the computer is concerned, any data is just 1s and 0s (bytes). The file is just a logical unit to organize these. So an area of disk is designated as belonging to a file.</p>
<p>Files can contain programs (e.g., <code>word.exe</code>) and/or data (e.g., <code>technical-report.docx</code>). The content of a file is defined by its creator. The creator could be a user if he or she is using notepad or something, or it could be a program, like a compiler creating an output binary file.</p>
<p>The UNIX approach is treating everything like a file, whether it is a device, regular file, or anything else (we’ll see some examples later). This means that the functions that we use to interact with a file can be applied in several other contexts as well.</p>
<p>Files typically have attributes, which, although they can vary, tend generally to include the following things <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p><strong>Name</strong>: The symbolic file name, in human-readable form.</p></li>
<li><p><strong>Identifier</strong>: The unique identifier, usually a number, that identifies the file inside the file system.</p></li>
<li><p><strong>Type</strong>: Information about what kind of file it is.</p></li>
<li><p><strong>Location</strong>: The physical location of the file, including what device (e.g., hard drive) it is on.</p></li>
<li><p><strong>Size</strong>: The current, and possibly maximum, size of the file.</p></li>
<li><p><strong>Protection</strong>: Access-control information, including who owns the file, who may read, write, and execute it...</p></li>
<li><p><strong>Time, Date, User ID</strong>: The owner of the file, time of creation, last access, last change... any sort of data that is useful for protection, security, usage monitoring...</p></li>
</ol>
<p>Files are maintained in a directory structure. The directory structure is generally quite familiar to us as the folders on the system. Directories, really, are just like files; they are information about what files are in what locations, and they too will be stored on disk.</p>
<h3 id="file-operations" class="unnumbered">File Operations</h3>
<p>It makes some sense to consider a file to be a structure; a file has some data (fields, metadata) and some operations (methods). The OS provides these operations to allow users to work with and on files. Six basic operations are required for a file system to be useful, though other things like renaming and so on are nice to have <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p>Creating a file.</p></li>
<li><p>Writing a file.</p></li>
<li><p>Reading a file.</p></li>
<li><p>Repositioning within a file.</p></li>
<li><p>Deleting a file.</p></li>
<li><p>Truncating a file.</p></li>
</ol>
<p>Let’s examine each of these briefly. As you will see, there is a certain similarity between file operations and memory operations, with which we should already be familiar. In all cases, we can look at some equivalent system calls (in the context of a trivial program) with thanks to <span class="citation" data-cites="cfiles"></span> as the source of some examples.</p>
<p>We already saw in an earlier example how to open and close a file:</p>
<div class="sourceCode" id="cb34" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1">    <span class="dt">FILE</span>* f = fopen( argv[<span class="dv">1</span>], <span class="st">&quot;r&quot;</span>);</a>
<a class="sourceLine" id="cb34-2" title="2">    <span class="cf">if</span> ( f == NULL ) {</a>
<a class="sourceLine" id="cb34-3" title="3">        printf(<span class="st">&quot;Unable to open file! %s is invalid name?</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb34-4" title="4">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb34-5" title="5">    }</a>
<a class="sourceLine" id="cb34-6" title="6">    readfile( f );</a>
<a class="sourceLine" id="cb34-7" title="7">    fclose( f );</a></code></pre></div>
<h5 id="creating-a-file.">Creating a File.</h5>
<p>Like allocating memory, creating a new file has multiple essential steps: first, find a place to put the file, allocate that space and mark that file as being allocated, and finally put the file in its appropriate directory.</p>
<h5 id="writing-a-file.">Writing a File.</h5>
<p>Writing a file requires the name or identifier of the file and the data to be written to the file. Using the name or identifier, the system finds that file and can then start putting data in the file. A write operation may replace the existing contents or append (write at the end) to the existing contents. A pointer will be needed to keep track of where the next write will take place, and will be updated after each write (but we don’t have to manage this ourselves if we don’t want to).</p>
<h5 id="reading-a-file.">Reading a File.</h5>
<p>This requires the name or identifier of the file and where in memory the next block of the file should be put. A pointer will also be required to indicate where the next read will take place (and like the write pointer, we don’t have to manage this ourselves usually).</p>
<h5 id="truncating-a-file.">Truncating a File.</h5>
<p>If a file should be erased but its attributes maintained (e.g., all the metadata), we can truncate it: cut off all the contents. The file length is reset to zero and its data area is marked as free, but the rest of the attributes remain the same.</p>
<p>It turns out that creating, reading, writing, and truncating are all done with the open call. The call is <code>FILE * fopen( const char* filename, const char* mode )</code>. In addition to the filename as the first parameter, the function is called with the mode as the second parameter. In the last example, the mode we provided was a string literal of <code>r</code>. The modes are:</p>
<ul>
<li><p><code>r</code> – Open the file for reading only.</p></li>
<li><p><code>w</code> – Open the file for writing. If a file with the name exists, it’s overwritten.</p></li>
<li><p><code>a</code> – Open the file, writing data at the end of the file.</p></li>
<li><p><code>r+</code> – Open for read and update (the file must exist).</p></li>
<li><p><code>w+</code> – Create a file and open it for update; if the file exists it’s overwritten.</p></li>
<li><p><code>a+</code> – Open a file for update, with new output operations at the end of the file.</p></li>
</ul>
<p>If we combine this with a <code>b</code>, such as <code>rb</code> then we are opening the file as a binary file. Also, as of the C 2011 standard, there is a new add-on <code>x</code> which can be used to make any write operation fail if the file exists.</p>
<h5 id="repositioning-within-a-file.">Repositioning within a File.</h5>
<p>Since a file may be read or written, but usually only one at a time, the pointer for the write location may in fact be the same pointer for the memory location. If so, we might call it a current position pointer, and this operation is just repositioning it within the file. Repositioning is also sometimes called a seek operation.</p>
<p>In C this is done with the <code>fseek()</code> call. This adjusts the pointer for reading or writing. This should be done with caution though, because you can go to an arbitrary location, even the middle of a two (or more) byte character. And we can’t seek when a file is opened for append.</p>
<h5 id="deleting-a-file.">Deleting a File.</h5>
<p>Deletion works pretty much as we would expect: find the file, mark its space as free, and remove it from the directory listing. This is a “simple” deletion and it does not actually get rid of any of the data, it just makes the file system forget the existence of the file. However, it might be possible to recover the data if the space it previously occupied has not been overwritten. This is a bit like a freed pointer in C possibly still being accessible. Some systems offer a more secure deletion routine that overwrites the space the file used to occupy with zeros.</p>
<p>In C a file is deleted with the <code>remove()</code> function. This simple program deletes whatever file is provided as the second argument. In reality, we would more likely delete a temporary file that the program has used for some purpose, at the end of execution.</p>
<div class="sourceCode" id="cb35" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb35-2" title="2">  <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb35-3" title="3">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb35-4" title="4">  }</a>
<a class="sourceLine" id="cb35-5" title="5">  </a>
<a class="sourceLine" id="cb35-6" title="6">  remove( argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb35-7" title="7"></a>
<a class="sourceLine" id="cb35-8" title="8">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb35-9" title="9">}    </a></code></pre></div>
<p>These six operations can be combined for most of the other things we may want to do. To copy a file, for example, create a new file, read from the old file, and write it into the new file. We may also have operations to allow a user to access or set various attributes such as the owner, security descriptors, size on disk, et cetera <span class="citation" data-cites="osc"></span>.</p>
<p>Aside from creation and deletion, all the other operations are restricted to files that are open. When a file is opened, a program gets a reference to it, and the operating system keeps track of which files are currently open in which process. It is good behaviour for a process to close a file when it is no longer using it, but eventually when the process terminates, that will automatically close any open files (hopefully).</p>
<p>Some operating systems support file locks. Locks may be exclusive, or non-exclusive. When a file is locked by one process, other processes will be advised that opening failed due to someone having a lock on that file. Similarly, files in use cannot be deleted while that file is in use.</p>
<p>Windows, for example, uses locking and any file that is open in some program cannot be deleted. UNIX, however, does not, so UNIX-compatible programs can, if they need, lock a file, but by default this does not happen. In UNIX if a file is open in a program, another user can still delete the file and it will be removed from the directory. As long as that program remains open and retains that reference to the file, it can still operate on that file. However, once the file is no longer open in a program, its storage space will be marked as free.</p>
<p>To lock a file in Linux, the call for this is <code>flock()</code>. Think “File-Lock”, not “flock of seagulls”. It takes two parameters, the file descriptor and the type of lock we wish to have. But we have opened a file with <code>fopen()</code> and it returns a <code>FILE</code> pointer. To convert that to a file descriptor, there is a function <code>fileno()</code>.</p>
<div class="sourceCode" id="cb36" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="dt">FILE</span>* f = fopen(<span class="st">&quot;myfile.txt&quot;</span>, <span class="st">&quot;r&quot;</span>);</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="dt">int</span> file_desc = fileno( f );</a>
<a class="sourceLine" id="cb36-3" title="3"><span class="dt">int</span> result = flock( file_desc, LOCK_EX );</a></code></pre></div>
<p>This example locks the file exclusively. A shared lock would be <code>LOCK_SH</code>, and to unlock the parameter is <code>LOCK_UN</code>.</p>
<h3 id="reading-and-writing" class="unnumbered">Reading and Writing</h3>
<p>Writing to a file is easy enough because it works like <code>printf</code>. In fact, the function call for it is <code>fprintf</code> and the only real difference between that and <code>printf</code> is that the first argument to this is the file pointer where you’d like the data to be written to:</p>
<div class="sourceCode" id="cb37" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="dt">void</span> write_points_to_file( point* p, <span class="dt">FILE</span> f ) {</a>
<a class="sourceLine" id="cb37-2" title="2">  <span class="cf">while</span>( p != NULL ) {</a>
<a class="sourceLine" id="cb37-3" title="3">    fprintf(f, <span class="st">&quot;(%d, %d, %d)</span><span class="sc">\n</span><span class="st">&quot;</span>, p-&gt;x, p-&gt;y, p-&gt;z);</a>
<a class="sourceLine" id="cb37-4" title="4">    p = p-&gt;next;</a>
<a class="sourceLine" id="cb37-5" title="5">  }</a>
<a class="sourceLine" id="cb37-6" title="6">}</a></code></pre></div>
<p>Reading from a file involves the use of <code>fscanf</code> which is a mirror image of <code>fprintf</code>. The format specifiers are the same. Let’s look at an example from <span class="citation" data-cites="cfiles"></span>:</p>
<div class="sourceCode" id="cb38" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb38-1" title="1"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ){</a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="dt">FILE</span> *fp;</a>
<a class="sourceLine" id="cb38-3" title="3">  <span class="dt">int</span> i, isquared;</a>
<a class="sourceLine" id="cb38-4" title="4">   </a>
<a class="sourceLine" id="cb38-5" title="5">  fp = fopen(<span class="st">&quot;results.dat&quot;</span>, <span class="st">&quot;r&quot;</span>);</a>
<a class="sourceLine" id="cb38-6" title="6">  <span class="cf">if</span> (fp == NULL) {</a>
<a class="sourceLine" id="cb38-7" title="7">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb38-8" title="8">  }</a>
<a class="sourceLine" id="cb38-9" title="9">   </a>
<a class="sourceLine" id="cb38-10" title="10">  <span class="cf">while</span> (fscanf(fp, <span class="st">&quot;%d,%d</span><span class="sc">\n</span><span class="st">&quot;</span>, &amp;i, &amp;isquared) == <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb38-11" title="11">    printf(<span class="st">&quot;i: %d,  isquared: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, i, isquared);</a>
<a class="sourceLine" id="cb38-12" title="12">  }</a>
<a class="sourceLine" id="cb38-13" title="13">  </a>
<a class="sourceLine" id="cb38-14" title="14">  fclose(fp);</a>
<a class="sourceLine" id="cb38-15" title="15">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb38-16" title="16">}</a></code></pre></div>
<p>The return value of this function call is the number of elements successfully read, which in this case is supposed to be two. But it’s worth noting that there’s no space in the read from the file, because the <code>%d</code> skips leading whitespaces (occasionally leading to hard-to-find bugs).</p>
<p>If reading user input, there is of course, regular <code>scanf</code>. We can, of course, read a file with <code>getline</code> as in the earlier examples.</p>
<h3 id="file-types" class="unnumbered">File Types</h3>
<p>Files we are familiar with often have extensions separated from the file name by a period, like <code>fork.txt</code>. The <code>txt</code> extension tells us some information about the file, i.e. that it is a text file. These things are mostly hints to the OS or user about what sort of file it is. In most operating systems, any program can open arbitrary files... that it has a <code>.docx</code> extension is only a suggestion that it should be opened by a word processing program, but nothing stops people from opening it in any other program. OSes typically allow setting a default program for the extension: e.g., always open <code>.docx</code> files with LibreOffice.</p>
<h3 id="directories" class="unnumbered">Directories</h3>
<p>A directory is really just a symbol table that translates file names (user-readable representations) to their directory entries. A directory should support several common operations <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p><strong>Search</strong>. We want to be able to find a file, and searching is typically not just on the file name but may include the contents of files as well, if their content is human-readable data.</p></li>
<li><p><strong>Add a File</strong>. Add a file to the directory.</p></li>
<li><p><strong>Remove a File</strong>. Remove a file from the directory.</p></li>
<li><p><strong>List a Directory</strong>. List the files of the directory and the contents of the directory entry.</p></li>
<li><p><strong>Rename a File</strong>. Change the user-friendly file name, possibly changing the file’s position in the directory if it is sorted by name.</p></li>
<li><p><strong>Navigate the File System</strong>. It should be possible to open subdirectories, go to parent directories, and so on.</p></li>
</ol>
<p>There are some simple file systems where there are no such things as subdirectories, but they don’t really require any examination. Textbooks may also bring up a structure where each user has his or her own directory but cannot have subdirectories either. Also rather uninteresting. The kind of directory we are most familiar with is tree-structured: there is a root directory, and every file in the system has a unique name when the name and path to it (from the root) are combined.</p>
<p>In UNIX the root directory is just called <code>/</code> (forward slash) and from there we can navigate to any file. If we would like to run the <code>ls</code> command, we will find it in the <code>bin</code> directory as <code>/bin/ls</code>. This is an example of an absolute path. Most of the time we do not have to use the absolute path (the full file name); a relative path (the path from the current directory) will suffice. As an example, if you want to compile something with a command like <code>gcc code/example.c</code>, the file <code>example.c</code> is in a subdirectory of the current directory called <code>code</code> and the system will work out that we need to start from the current directory (e.g., <code>/home/jz/ece252/</code>) and prepend that to the given file name, to produce the absolute path of <code>/home/jz/ece252/code/example.c</code>.</p>
<p>OS designers have to make a choice about deletion of directories, if a directory is not empty. If it is empty, just removing the directory is enough. If it contains some files, either the system can refuse to delete the directory until it is empty, or automatically delete the files and subdirectories in their entirety. Also, what does it mean to delete a file or folder? In modern operating systems, the delete command sometimes does not necessarily actually delete the file or folder, but instead moves it to some deleted files directory (recycle bin, trash can, whatever you want to call it). If it is deleted from there then it is really gone, but while it is in that deleted file directory it can be restored.</p>
<p>File systems may also support the sharing of files: there is one copy of the file but it has more than one name. In UNIX this concept is called a <em>link</em> and this is effectively a pointer to another file. Links are either “hardlinks” or “symlinks”.</p>
<p>Symlinks, or symbolic links, are just references by file name. So if a symbolic link is created to a file like <code>/Users/jz/file.txt</code>, the symbolic link will just be a “shortcut” to that file. If the file is later deleted, the symbolic link is left pointing to nothing. A future attempt to use this pointer will result in an error, so it is something to check on. It would be expensive, though possible, to search through the file system to find all links and remove them.</p>
<p>Creating a hardlink means creating a second pointer to the underlying file in the file system. If a hardlink exists and the user deletes that file, the file still remains on disk until the last hardlink is removed. We will see later on, when we examine the file system implementation, how this actually works, but the short answer is: reference counting. The file structure maintains a count of how many hardlinks reference a file, and it is only really deleted if the count falls to zero.</p>
<h3 id="file-permissions" class="unnumbered">File Permissions</h3>
<p>To protect users from one another and to maintain the confidentiality and integrity of data, files usually have some permissions associated with them, which may control access to the following operations <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p>Read</p></li>
<li><p>Write</p></li>
<li><p>Execute</p></li>
<li><p>Append (write at the end of the file)</p></li>
<li><p>Delete</p></li>
<li><p>List (view the attributes of the file)</p></li>
</ol>
<h5 id="unix-style-permissions.">UNIX-Style Permissions.</h5>
<p>UNIX-Style permissions are commonly used still today in a lot of UNIX and UNIX-like systems. Each file has an owner and a group, and a set of permissions that can be assigned for the owner, the group, and for everyone. There are three basic permissions: read, write, and execute (run as a program). The permissions are represented using 10 bits, where a 1 indicates true and a 0 indicates false. The first bit is the directory bit and indicates if the file being examined is actually a directory. The next three bits are the read, write, and execute bits for the owner, followed by the read, write, and execute bits for the group, and finally the read, write, and execute bits for everyone.</p>
<p>Effective permissions are determined by the user: the owner of the file gets the owner permissions even if different permissions are assigned to the group or everyone. Precedence goes from left to right: owner takes precedence over the group; group takes precedence over the permissions for everyone.</p>
<p>The permissions can be shown to the screen in a human-readable format which is ten characters long. The order is always the same, and so a dash (<code>-</code>) appears if a bit is zero (permission does not exist). The character <code>d</code> is used to indicate a directory, <code>r</code> to indicate read access, <code>w</code> to indicate write access, and <code>x</code> to indicate execute access.</p>
<p>Example: permissions of <code>-rwxr-----</code> indicate that a file is not a directory; the owner can read, write, and execute; other members of the group can read it only, and everyone else has no access to the file (cannot read, write, or execute).</p>
<p>Permissions can also be written in octal (base 8) where r = 4, w = 2, and x = 1. To get the octal representation, start with 0, and then add the value of the permissions that are present, using zero where permissions are absent. You might then have a permission that reads <code>750</code> - meaning that the owner has read, write and execute access (0 + 4 + 2 + 1 = 7); group members have read and execute access (0 + 4 + 0 + 1 = 5); everyone else has no access to it at all.</p>
<p>There are some more details like what the permissions mean on directories, and some advanced topics like <code>setuid</code>, <code>setgid</code>, and “sticky bit”, but we will not cover them in this course.</p>
<p>The obvious shortcoming of this approach is that it is very coarse-grained: there are only three groups for whom we can specify permissions. Within Linux and other similar systems there is a trend now towards using SELinux (Security Enhanced Linux) which is an Access Control List system. For the moment we’ll leave off the discussion of access control lists and just proceed forward.</p>
<h1 id="processes" class="unnumbered">4 — Processes</h1>
<h2 id="processes-1" class="unnumbered">Processes</h2>
<p>Early computers, as well as many modern embedded systems, did exactly one thing, or at least, exactly one thing at a time. At that time, the program had access to all the resources available in the system. Now, we expect that the OS supports multiple programs running concurrently. For that to work reliably, the operating system needs a way to manage the complexity and this has resulted in the notion of a <em>process</em>. We’ve already worked with processes, but most likely we didn’t know it at the time.</p>
<p>A process is a program in execution. It is composed of three things:</p>
<ol>
<li><p>The instructions and data of the program (the compiled executable).</p></li>
<li><p>The current state of the program.</p></li>
<li><p>Any resources that are needed to execute the program.</p></li>
</ol>
<p>Having two instances of the same program running counts as two separate processes. Thus, you may have two windows open for Microsoft Word, and even though they are the same program, they are separate processes. Similarly, two users who both use Firefox at the same time on a terminal server are interacting with two different processes.</p>
<h3 id="the-process-control-block" class="unnumbered">The Process Control Block</h3>
<p>We will take a slight detour to the behind-the-scenes view of how the operating system manages a process, so that we can have a mental model of what may happen when a program is executing. The operating system’s data structure for managing processes is the <em>Process Control Block</em> (PCB). This is a data structure containing what the OS needs to know about the program. It is created and updated by the OS for each running process and can be thrown away when the program has finished executing and cleaned everything up. The blocks are held in memory and maintained in some container (e.g., a list) by the kernel.</p>
<p>The process control block will (usually) have <span class="citation" data-cites="osi"></span>:</p>
<ul>
<li><p><strong>Identifier.</strong> A unique ID associated with the process; usually a simple integer that increments when a new process is created and reset when the system is rebooted.</p></li>
<li><p><strong>State.</strong> The current state of the process.</p></li>
<li><p><strong>Priority.</strong> How important this process is (compared to the others).</p></li>
<li><p><strong>Program Counter.</strong> A place to store the address of the next instruction to be executed (*when needed).</p></li>
<li><p><strong>Register Data.</strong> A place to store the current values of the registers (*when needed); also called context data.</p></li>
<li><p><strong>Memory Pointers.</strong> Pointers to the code as well as data associated with this process, and any memory that the OS has allocated by request.</p></li>
<li><p><strong>I/O Status Information.</strong> Any outstanding requests, files, or I/O devices currently assigned to this process.</p></li>
<li><p><strong>Accounting Information.</strong> Some data about this process’s use of resources. This is optional (but common).</p></li>
</ul>
<p>To represent this visually:</p>
<p><img src="images/pcb.png" alt="image" style="width:24.0%" /><br />
A simplified Process Control Block <span class="citation" data-cites="osi"></span>.</p>
<p>Almost all of the above will be kept up to date constantly as the process executes. Two of the items, notably the program counter and the register data are asterisked with the words “when needed”. When the program is running, these values do not need to be updated. However, when a system call (trap) or process switch occurs, and the execution of that process is suspended, the OS will save the state of the process into the PCB. This includes the Program Counter variable (so the program can resume from exactly where it left off) and the Register variables (so the state of the CPU goes back to how it was). The diagram below shows the sequence as the OS switches between the execution of process <span class="math inline">P_{0}</span> and process <span class="math inline">P_{1}</span>.</p>
<p><img src="images/process-switch.png" alt="image" style="width:65.0%" /><br />
A process switch from <span class="math inline">P_{0}</span> to <span class="math inline">P_{1}</span> and back again <span class="citation" data-cites="osc"></span>.</p>
<h3 id="the-circle-of-life" class="unnumbered">The Circle of Life</h3>
<p>Unlike energy, processes may be created and destroyed. Upon creation, the OS will create a new PCB for the process and initialize the data in that block. This means setting the variables to their initial values: setting the initial program state, setting the instruction pointer to the first instruction in <code>main</code>, and so on. The PCB will then be added to the set of PCBs the OS maintains. After the program is terminated and cleaned up, the OS may collect some data (like a summary of accounting information) and then it can remove the PCB from its list of active processes and carry on.</p>
<h4 id="process-creation" class="unnumbered">Process Creation</h4>
<p>There are, generally speaking, three main events that may lead to the creation of a process <span class="citation" data-cites="mos"></span>:</p>
<ol>
<li><p>System boot up.</p></li>
<li><p>User request to start a new process.</p></li>
<li><p>One process spawns another.</p></li>
</ol>
<p>When the computer boots up, the OS is started and begins creating processes. An embedded system might have all the processes it will ever run created by this initialization process, but general-purpose operating systems will allow at least one of the other routes (if not both of them).</p>
<p>At boot time the OS starts up various processes, some of which will be in the foreground (visible to the user) and some in the background. A user-visible process might be the log in screen; a background process might be the server that shares media on the local network. The UNIX term for a background process is <em>Daemon</em>. You have already worked with one of these if you have ever used the <code>ssh</code> (Secure Shell) command to log into a Linux system; when you attempt to connect it is the <code>sshd</code> (Secure Shell Daemon) that responds to your connection attempt.</p>
<p>Users are well known for starting up processes whenever they feel like it, much to the chagrin of system designers everywhere. Every time you double-click an icon or enter a command line command (like <code>ssh</code> above) that will result in the creation of a process.</p>
<p>An already-executing process may spawn another. If you receive an e-mail with a link in it and click on that link<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, the e-mail program will start up the web browser (another process) to open the web page. Or a program may break its work up into different logical parts to be parcelled out to subprograms that run as their own process (to promote parallelism or fault tolerance). When an already-executing program spawns another process, we say the spawning process is the <em>parent</em> and the one spawned is the <em>child</em>. Later on, we will return to the subject of relations between processes in UNIX.</p>
<h4 id="process-destruction" class="unnumbered">Process Destruction</h4>
<p>Eventually, most processes die. This is sad, but it can happen in one of four ways <span class="citation" data-cites="mos"></span>:</p>
<ol>
<li><p>Normal exit (voluntary)</p></li>
<li><p>Error exit (voluntary)</p></li>
<li><p>Fatal Error (involuntary)</p></li>
<li><p>Killed by another process (involuntary)</p></li>
</ol>
<p>Most of the time, the process finishes because they are finished or the user asks them to. If the command is to compile some piece of code, when the compiler process is finished, it terminates normally. When you are finished writing a document in a text editor, you may click the close button on the window and this will terminate the program normally.</p>
<p>Sometimes there is voluntary exit, but with an error. If the user attempts to run a program that requires write access to the temporary directory, and it checks for the permission on startup and does not find it, it may exit voluntarily with an error code. Similarly, the compiler will exit with an error if you ask it to compile a non-existent file <span class="citation" data-cites="mos"></span>. In either case, the program has chosen to terminate (not continue) because of the error and it is a voluntary termination.</p>
<p>The third reason for termination is a fatal error occurring in the program, like a stack overflow error or division by zero. The OS will detect this error and send it to the program. Very often, this results in the involuntary termination of the offending program. A process may tell the OS it wishes to handle some kinds of errors (like in Java/C# with the <code>try-catch-finally</code> syntax) in which case the OS will send the error to the program which can hopefully deal with it. If so, the process may continue, otherwise, the unhandled exception will result in the involuntary termination.</p>
<p>The last reason for termination is that one process might be killed by another (yes, processes can murder one another. Is no-one safe?!). Typically this is a user request: a program is stuck or consuming too much CPU and the user opens task manager in Windows or uses the <code>ps</code> command (in UNIX) to find the offender and then terminates it with the “End Process” button (in Windows) or the <code>kill</code> command (in UNIX). However, programs can, without user intervention, theoretically kill other processes, such as a parent process killing a child it believes to be stuck (or timed out).</p>
<p>Obviously, there are restrictions on killing process: a user or process must have the rights to execute the victim. Typically a user may only kill a process he or she has created, unless that user is a system administrator. While killing processes may be fun, it is something that should be reserved for when it is needed.</p>
<p>Sometimes when a process is killed, all the processes it has spawned are killed as well (this is really cruel). Neither UNIX nor Windows works this way, however: a parent can outlive the death of its child and vice-versa.</p>
<h3 id="process-family-tree" class="unnumbered">Process Family Tree</h3>
<p>In UNIX, but not in Windows, the relationship between the parent process and child process(es), if any, is maintained, forming a hierarchy. A process, unlike most plants and animals, reproduces asexually: a process has one parent, but may have zero or more children. A process and all its descendants form a <em>process group</em> and certain operations like sending a signal (e.g., the terminate signal <code>Ctrl-C</code>) can be sent to the whole group, letting each process decide what to do with it. <span class="citation" data-cites="mos"></span>.</p>
<p>In UNIX the first process created is called <code>init</code> and it is the parent of all processes (eventually), much like the <code>Object</code> class in Java is the superclass of all classes in the system. Thus in UNIX we may represent all processes as a tree structure, where each node is a process, each node may have zero or more children, and moving up the hierarchy will eventually take us to <code>init</code>.</p>
<p>In Windows, a process that spawns another process gets a reference to its child, allowing it to exercise some measure of control over the child. However, this reference may be given to another process (so, the concept of adoption exists) meaning there is no real hierarchy. A process in UNIX cannot disinherit a child <span class="citation" data-cites="mos"></span>.</p>
<p>When a process terminates, voluntarily or otherwise, it does so with a return code, just as a function often returns a value. If the command is issued on the command line (e.g., <code>cat /var/log/syslog</code>) or from double clicking an icon, the return value is generally ignored (or at least, not presented to the user). In UNIX, when a parent process spawns a child, it can get the code that process returns. Usually, a return value of zero indicates success and other values indicate an error of some sort. Normally there is some sort of understanding between the parent and child processes about what a particular code means.</p>
<p>When a child process finishes execution, until such time as the parent comes by to collect the return value, the child continues in a state of “undeath” we call a <em>zombie</em>. This does not mean that the process then shuffles around the system attempting to eat the brains of other processes; it just means that the process is dead but not gone. The program has finished executing, there is still an entry in the PCB list, and the process holds on to its allocated resources until such time as the return value is collected. Only after the return value is collected can it be cleaned up. Usually, a child process’s result is eagerly awaited by its parent and the <code>wait</code> call collects the value right away, allowing the child to be cleaned up (or, more grimly, “reaped”). If there is some delay for some reason, the process is considered a zombie until that value is collected.</p>
<p>If a child process’s parent should die before the child does, the process is called an <em>orphan</em>. In UNIX any orphan process is automatically adopted by the <code>init</code> process, making sure all processes have a good home. By default, <code>init</code> will just <code>wait</code> on all its child processes (and do nothing with the return values), ensuring that when they are finished, they do not become zombies. Sometimes a program is intentionally orphaned: it is spawned to run in the background (e.g., when starting up a service or daemon on the system). This would be cruel, except that processes, as far as anyone knows, do not have feelings.</p>
<h3 id="the-five-state-model" class="unnumbered">The Five-State Model</h3>
<p>As you might imagine, at any given time, a process is running or not running. The first two states of the model are therefore “Running” and “Ready”.</p>
<p>A program that requests a resource like I/O or memory may not get it right away. This is not to say the program will never get it, just that it does not have it right now. Sometimes the program needs user input, and as far as the computer is concerned, the user moves at glacial speed. In any case, the program wants to continue but cannot until it gets what it is waiting for. If the scheduler picks a process that is waiting for user input, nothing will be happening while the program is waiting for input, so the CPU’s time would be wasted. Thus, we should be able to mark a process as “not ready to proceed”, which gives us our “Blocked” state.</p>
<p>Earlier we discussed that a UNIX process may be finished but a zombie, because its parent has not (yet) come by to collect its return value. The process is not ready to run (it has finished running) and it is not waiting for a resource, so it does not qualify for Ready or Blocked. Thus, we need a state to represent that it is finished but not yet cleaned up: Terminated.</p>
<p>The fifth and final state will be the “New” state: a process that has just been defined. Suppose a user wants to run a new process. The OS will first perform the necessary administrative tasks: define an identifier for the process, instantiate the PCB object, and put the process in the New state. The OS has created the process but has not committed itself to execution thereof. This may be because the system limits the number of concurrent processes for performance reasons. When the process is in the New state is is typically not in memory, but on disk instead <span class="citation" data-cites="osi"></span>.</p>
<p>Thus, with the two new states added, the five states of a process in the system are:</p>
<ol>
<li><p><strong>Running:</strong> Actively executing right now.</p></li>
<li><p><strong>Ready:</strong> Not running, but ready to execute if selected by the scheduler.</p></li>
<li><p><strong>Blocked:</strong> Not running, and not able to run until some event happens.</p></li>
<li><p><strong>New:</strong> Just created but not yet added to the list of processes ready to run.</p></li>
<li><p><strong>Terminated:</strong> Finished executing, but not yet cleaned up (reaped).</p></li>
</ol>
<p>With five states, we will have significantly more transitions between the states. The diagram below shows the five-state model:</p>
<p><img src="images/5-state-model.png" alt="image" style="width:85.0%" /><br />
State diagram for the five-state model.</p>
<p>There are now eight transitions, most of which are similar to what we have seen before:</p>
<ul>
<li><p><strong>Create:</strong> The process is created and enters the New state.</p></li>
<li><p><strong>Admit:</strong> A process in the New state is added to the list of processes ready to start, in the Ready state.</p></li>
<li><p><strong>Dispatch:</strong> A process that is not currently running begins executing and moves to the Running state.</p></li>
<li><p><strong>Suspend:</strong> A running program pauses execution, but can still run if allowed, and moves to the Ready state.</p></li>
<li><p><strong>Exit:</strong> A running program finishes and moves to the Terminated state; its return value is available.</p></li>
<li><p><strong>Block:</strong> A running program requests a resource, does not get it right away, and cannot proceed.</p></li>
<li><p><strong>Unblock:</strong> A program, currently blocked, receives the resource it was waiting for; it moves to the Ready state.</p></li>
<li><p><strong>Reap:</strong> A terminated program’s return value is collected by a <code>wait</code> and its resources can be released.</p></li>
</ul>
<p>There are two additional “Exit” transitions that may happen but are not shown. In theory, a process that is in the Ready or Blocked state might transition directly to the Terminated state. This can happen if a process is killed, by the user or by its parent (recall that parent processes can generally kill their children at any time, something the law thankfully does not permit). It may also happen that the system has a policy of killing all the children of a parent process when the parent process dies.</p>
<h3 id="swapping-processes-to-disk" class="unnumbered">Swapping Processes to Disk</h3>
<p>We can expand on the five state model with something else: the idea that a process might be swapped out to disk rather than in memory. Memory can have multiple processes in it and if the executing process gets blocked, another can be swapped into memory. Unfortunately, however, it is quite possible that the user wants to have more processes running than can currently be accommodated in main memory. The problem is not the PCBs, which are relatively small (a few thousand bytes), but the stack and heap space allocated to the running program can be very large (on the order of gigabytes).</p>
<p>With no other place to put them, we have to put some processes on disk, and this is what we know as swapping. Thus, when the demands for memory exceed the available memory, some of the processes will be moved to disk storage to make room for other processes. This is a notably expensive operation: swapping a process to disk might mean transferring several hundred megabytes of data, or even a few gigabytes, which, from the perspective of the CPU, takes about seven eternities. Then, when that process is going to run again, the OS will need to load it back in to memory, which, again, will take just as much time as it took to flush it out. So this is something to be done only when necessary.</p>
<p>Because the OS does not want to spend any more time swapping the process in and out of memory than is necessary, (and we need to know if a particular process is in memory or on disk) we need a new state: swapped. Ideally, it will only swap a process to disk if it is blocked. It cannot run anyway, so if it has to choose a process to put on disk, a blocked one is better than a ready one. A process swapped to disk then enters that sixth state, swapped, which means it is blocked and not in main memory.</p>
<p>There are two scenarios that may have occurred to you that tell us the swapped state on its own is not sufficient. The first is: what if all processes are ready but there is not enough memory space? Or, in other words, what if we need to swap out a process that is ready? The second is: what if the event the blocked process was awaiting has taken place (e.g., the user presses a key) and the process could proceed? How can we tell which processes currently swapped out have had their desired events occur and which have not? We would not like to guess in the second scenario, because swapping a process into memory is time consuming.</p>
<p>The solution to both problem scenarios is to split the swapped state in two: Ready/Swapped (ready to run, and currently not in memory) and Blocked/Swapped (not ready to run, and currently not in memory). That gives us, finally, the seven-state model, a minor variation of the five-state model:</p>
<p><img src="images/7-state-model.png" alt="image" style="width:85.0%" /><br />
State diagram for the seven-state model.</p>
<p>The Admit transition is modified to show that by default the new process does not start in main memory. Two new transitions, Swap In and Swap Out, are added to show a process being loaded into main memory and written out to disk respectively. Finally, there is a second Unblock transition, where a Blocked/Swapped process gets whatever it was waiting for and moves to the Ready/Swapped state, because it can now run (but is still on disk).</p>
<p>As in the five-state model, there are additional “Exit” transitions that may happen but are not shown. If a process is killed, for example, regardless of whether it is in memory or on disk, it will move to the Terminated state.</p>
<h1 id="processes-in-unix" class="unnumbered">5 — Processes in UNIX</h1>
<h2 id="the-process-in-unix" class="unnumbered">The Process in UNIX</h2>
<p>Earlier on, we mentioned that in UNIX, a process may create other processes. The creating process is the parent and the newly-created process(es) is (are) its child(ren). Every process has a parent, stretching back to the <code>init</code> process (or <code>launchd</code>) at the root of the tree.</p>
<p>Each process has a unique identifier in its process control block, and in UNIX we call this the <code>pid</code> (process ID). For the most part, users will not need to know or think about the ID of a process except when trying to terminate one that’s gotten stuck (<code>kill -9 24601</code>). The <code>init</code> process always gets a pid of 1. I don’t recommend trying to kill <code>init</code>. In most cases, <code>init</code> will just laugh off your attempt (“’tis but a scratch!”) but you might end up rebooting the system or causing a crash.</p>
<p><embed src="images/linux-process-tree.pdf" style="width:50.0%" /><br />
A tree of processes in a Linux system.</p>
<p>In a UNIX system, we can obtain a list of processes at any time with the <code>ps</code> command. The diagram illustrates that each user, when logging in, spawns a <code>login</code> process (and an administrator can log people out by killing their <code>login</code> process... not that this is necessarily a good way to do it). The user’s shell (these days, almost always <code>bash</code>, the Bourne Again Shell) is then spawned from <code>login</code>. That shell provides the command line interface where the user can enter a command.</p>
<p>When you issue a command, like <code>ls</code> or <code>top</code> (table of processes), the new process is created and the shell will <code>wait</code> on that process to finish (in the case of <code>ls</code>) or for the user to tell it to exit (<code>top</code>); when it does, control goes back to the shell and you get presented with the prompt again (e.g., <code>jz@Loki:~/$</code>). This would, on its face, seem kind of limiting – do I have to log in to the system in a second terminal window to run two things at a time? The answer is no, and there are two ways to get around it.</p>
<p>The first thing we can do is tell the shell we want the task to run in the background. To do that, add to the command the <code>&amp;</code> symbol, like so:</p>
<p><code>gcc fork.c &amp;</code></p>
<p>This will return control almost immediately to the shell (as it will not be waiting for the <code>gcc</code> command to finish). You may see some output like <code>[1] 34429</code> which is the shell saying the child has been created and it has process ID 34429. When the process is finished, there is another update, looking something like:</p>
<p><code>[1]+ Done gcc fork.c</code></p>
<p>Notably, any console output that the <code>gcc</code> command would generate will still appear on the console where the background task was created. Maybe you want that but maybe you want to put the output in a log file, with a command like <code>cat fork.c &gt; logfile.txt &amp;</code>. (Telling <code>gcc</code> to be silent is a somewhat more complex operation.)</p>
<p>A common example of a command I use involving the <code>&amp;</code>:<br />
<code> sudo service xyz start &amp; </code><br />
This will (with super user permissions - that’s the purpose of <code>sudo</code>) start up the service <code>xyz</code> but return control to the console so I don’t have to wait for the <code>xyz</code> service to be started to enter my next command. This is good, because the next thing I’d like to do is <code>tail -f /var/log/xyz/console.log</code> which will allow me to watch the console log of the <code>xyz</code> service as it starts up to see if there are any errors.</p>
<p>The other alternative to get something to run in the background is with the <code>screen</code> command. While having something run in the background is nice, it does not work for interactive processes. Suppose you are working on some code in <code>vi</code> and you would like to pause that for a minute and write an e-mail (with <code>pine</code> or whatever the cool kids use for command line e-mail these days). One approach is to save and exit <code>vi</code> and open up <code>pine</code>. The other would be to start up each of these in <code>screen</code> and switch between them.</p>
<p>Thus instead of just opening <code>vi fork.c</code> I can issue the command <code>screen vi fork.c</code> and this spawns <code>screen</code> and takes me right to editing the file. The key difference is that I can “detach” from this screen and go back to the command line that spawned it. And if I log out, <code>screen</code> keeps running with the <code>vi</code> inside it. If I have multiple screens running, I can just “reattach” to the one I want to use next. To get a full understanding of <code>screen</code>, try the command <code>man screen</code> and the user manual will appear to give you some information and instructions about how to use this. Or you can use Google.</p>
<h3 id="show-me-the-code" class="unnumbered">Show Me The Code!</h3>
<p>The workflow in UNIX is as follows. First, the parent spawns the child process with the <code>fork</code> system call. If it is interested in waiting for the child process to finish, it will use the system call <code>wait</code>, in which case the parent will be awaiting the completion of the child process. When the child process is finished, it returns a value with the <code>exit</code> system call. The parent process will then get this as the return value of the <code>wait</code> call and may proceed.</p>
<p>What does <code>fork</code> do? It creates a new process; it makes a copy of itself. The parent and child continue execution after the <code>fork</code> statement. If <code>fork</code> returns a negative number, the <code>fork</code> system call failed. If it returns 0, the process that got the 0 back is the child. If it returns a positive value, that is the process ID of the child.</p>
<p>After the <code>fork</code>, one of the processes may use the <code>exec</code> system call, or one of its variants, to replace its memory space with a new program. There’s no rule that says this must happen; a child can continue to be a clone of its parent if it wishes. The <code>exec</code> invocation loads the binary file into memory and starts execution <span class="citation" data-cites="osc"></span>. At this point, the programs can go their separate ways, or the parent might want to wait for the child to finish. The parent is then blocked, waiting for the child process to execute.</p>
<p>Let’s put this all together in an actual C-code example adapted from <span class="citation" data-cites="osc"></span>:</p>
<div class="sourceCode" id="cb39" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb39-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp"> </span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb39-4" title="4"></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb39-6" title="6">  pid_t pid;</a>
<a class="sourceLine" id="cb39-7" title="7">  <span class="dt">int</span> childStatus;</a>
<a class="sourceLine" id="cb39-8" title="8"></a>
<a class="sourceLine" id="cb39-9" title="9">  <span class="co">/* fork a child process */</span></a>
<a class="sourceLine" id="cb39-10" title="10">  pid = fork();</a>
<a class="sourceLine" id="cb39-11" title="11">  </a>
<a class="sourceLine" id="cb39-12" title="12">  <span class="cf">if</span> (pid &lt; <span class="dv">0</span>) { </a>
<a class="sourceLine" id="cb39-13" title="13">    <span class="co">/* error occurred */</span> </a>
<a class="sourceLine" id="cb39-14" title="14">    fprintf(stderr, <span class="st">&quot;Fork Failed&quot;</span>); </a>
<a class="sourceLine" id="cb39-15" title="15">    <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb39-16" title="16">  </a>
<a class="sourceLine" id="cb39-17" title="17"> } <span class="cf">else</span> <span class="cf">if</span> (pid == <span class="dv">0</span>) {    </a>
<a class="sourceLine" id="cb39-18" title="18">    <span class="co">/* child process */</span></a>
<a class="sourceLine" id="cb39-19" title="19">    execlp(<span class="st">&quot;/bin/ls&quot;</span>,<span class="st">&quot;ls&quot;</span>,NULL);</a>
<a class="sourceLine" id="cb39-20" title="20">    </a>
<a class="sourceLine" id="cb39-21" title="21">  } <span class="cf">else</span> {    </a>
<a class="sourceLine" id="cb39-22" title="22">    <span class="co">/* parent process */</span></a>
<a class="sourceLine" id="cb39-23" title="23">    <span class="co">/* parent will wait for the child to complete */</span></a>
<a class="sourceLine" id="cb39-24" title="24">    wait(&amp;childStatus);</a>
<a class="sourceLine" id="cb39-25" title="25">    printf(<span class="st">&quot;Child Complete with status: %i </span><span class="sc">\n</span><span class="st">&quot;</span>, childStatus);</a>
<a class="sourceLine" id="cb39-26" title="26">    </a>
<a class="sourceLine" id="cb39-27" title="27">  }</a>
<a class="sourceLine" id="cb39-28" title="28">    </a>
<a class="sourceLine" id="cb39-29" title="29">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb39-30" title="30">}</a></code></pre></div>
<p>When executed, this code starts up and attempts to spawn a child process. Let us assume that the <code>fork</code> command succeeds and we do not enter the error-occurred block. After the fork there are now two processes at the statement <code> if ( pid &lt; 0 ) </code> . The child process calls <code>execlp</code>, replacing itself with the <code>ls</code> (list directory contents) command. The parent process will go to the <code>wait</code> statement and wait for the child process to complete. The child process runs <code>ls</code>, listing the contents of the directory. Then it finishes. The parent process, finally, prints “Child Complete” to the console.</p>
<p>Thus, the output is:</p>
<pre><code>jz@Freyja:~/fork$ ./fork 
fork   fork.c
Child Complete with status: 0
jz@Freyja:~/fork$ </code></pre>
<p>Or, to represent this visually:</p>
<p><img src="images/fork-syscall.png" alt="image" style="width:85.0%" /><br />
Process creation with the <code>fork</code> system call <span class="citation" data-cites="osc"></span>.</p>
<p>What about termination? On the assumption that the process is terminating normally and not being killed, the system call for that is <code>exit</code>. If the program itself has no explicit call to <code>exit</code>, the <code>return</code> statement at the end of <code>main</code> will have the same effect.</p>
<h5 id="use-of-fork-design-problem.">Use of Fork Design Problem. </h5>
<p>It’s not necessary for a child to replace itself with another one. Let us do an example of how we might write a program where both parts are in the same source file.</p>
<p>There is a task that can be split into parts ’A’ and ’B’. You may assume there are implementations for the functions <code>int execute_A()</code> and <code>int execute_B()</code> that work correctly (and are not shown). If either of the execution functions returns a non-zero value, this indicates an error.</p>
<p>Use <code>fork()</code> to create a child process. The child process should call function <code>execute_B()</code> and return the result to the parent. The parent process should call <code>execute_A()</code> and collect its result. The parent should then collect the result of the child using <code>wait()</code> and then produce the console output described in the next paragraph. If no errors occurred, <code>main</code> should return 0; otherwise it should return -1.</p>
<p>If an error occurs, it should be reported to the console including the error number (e.g., “Error 7 Occurred.”). If more than one error occurs, report both errors. If both functions return zero, it means all is well and the program should print “Completed.” to the console.</p>
<h5 id="use-of-fork-design-solution">Use of Fork Design Solution</h5>
<p>The solution:</p>
<div class="sourceCode" id="cb41" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb41-2" title="2"></a>
<a class="sourceLine" id="cb41-3" title="3">  pid_t pid;</a>
<a class="sourceLine" id="cb41-4" title="4">  <span class="dt">int</span> child_result;</a>
<a class="sourceLine" id="cb41-5" title="5">  <span class="dt">int</span> parent_result;</a>
<a class="sourceLine" id="cb41-6" title="6"></a>
<a class="sourceLine" id="cb41-7" title="7">  pid = fork();</a>
<a class="sourceLine" id="cb41-8" title="8">  </a>
<a class="sourceLine" id="cb41-9" title="9">  <span class="cf">if</span> ( pid &lt; <span class="dv">0</span> ) { <span class="co">/* Fork Failed */</span></a>
<a class="sourceLine" id="cb41-10" title="10">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb41-11" title="11">  } <span class="cf">else</span> <span class="cf">if</span> ( pid == <span class="dv">0</span> ) { <span class="co">/* Child */</span></a>
<a class="sourceLine" id="cb41-12" title="12">    <span class="cf">return</span> execute_B();</a>
<a class="sourceLine" id="cb41-13" title="13">  } <span class="cf">else</span> { <span class="co">/* Parent */</span> </a>
<a class="sourceLine" id="cb41-14" title="14">    parent_result = execute_A();</a>
<a class="sourceLine" id="cb41-15" title="15">    wait( &amp;child_result );</a>
<a class="sourceLine" id="cb41-16" title="16">  }</a>
<a class="sourceLine" id="cb41-17" title="17">  </a>
<a class="sourceLine" id="cb41-18" title="18">  <span class="cf">if</span> ( child_result == <span class="dv">0</span> &amp;&amp; parent_result == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb41-19" title="19">    printf( <span class="st">&quot;Completed.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb41-20" title="20">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb41-21" title="21">  }</a>
<a class="sourceLine" id="cb41-22" title="22">  </a>
<a class="sourceLine" id="cb41-23" title="23">  <span class="cf">if</span> ( child_result != <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb41-24" title="24">    printf( <span class="st">&quot;Error %d Occurred.</span><span class="sc">\n</span><span class="st">&quot;</span>, child_result);</a>
<a class="sourceLine" id="cb41-25" title="25">  }</a>
<a class="sourceLine" id="cb41-26" title="26">  <span class="cf">if</span> ( parent_result != <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb41-27" title="27">    printf( <span class="st">&quot;Error %d Occurred.</span><span class="sc">\n</span><span class="st">&quot;</span>, parent_result);</a>
<a class="sourceLine" id="cb41-28" title="28">  }</a>
<a class="sourceLine" id="cb41-29" title="29">  </a>
<a class="sourceLine" id="cb41-30" title="30">  <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb41-31" title="31">}</a></code></pre></div>
<h2 id="the-fork-bomb" class="unnumbered">The Fork Bomb</h2>
<p>We will take a slight digression from the general topic of processes to discuss a denial-of-service attack against UNIX systems that is called the “Fork Bomb”. The idea behind the attack is to call <code>fork</code> repeatedly until the number of processes spawned is too high for the system to manage and it either crashes or is so slow that no useful work can get done. As you can imagine, this is caused by repeatedly calling <code>fork</code>. Each time a program does so, there are now two processes running, each of which calls <code>fork</code>. There are then <span class="math inline">2^{n}</span> processes after each of <span class="math inline">n</span> invocations and this exponential growth will soon crash up against the limits of the system.</p>
<p>A system configured to defend against this may impose limits on (1) the total number of processes a user may create; and (2) the rate at which a user may spawn a new process.</p>
<p>Note: do not attempt this on anything other than your personal computer at home. It is a denial of service attack and would certainly count as misuse of resources on any system. Accordingly, trying to do it will very likely result in a ban. Getting banned from using university computer resources is not conducive to completing your degree.</p>
<h2 id="signals" class="unnumbered">Signals</h2>
<p>UNIX systems use signals to indicate events (e.g., the <code>Ctrl-C</code> on the console). Signals also are things like exceptions (division by zero, segmentation fault), etc. A signal may be <em>synchronous</em> if the signal occurs as a result of the program execution (e.g., dividing by zero); it is <em>asynchronous</em> if it comes from outside the process (e.g., the user pressing <code>Ctrl-C</code> or one process or thread sending a signal to another). Signals are, in the end, interrupts with a certain integer ID.</p>
<p>By default, the kernel will handle any signal that is sent to a process with the default handler. The behaviour of the default handler may be to ignore the signal, but some signals (segmentation fault) will result in termination of the process.</p>
<p>Here are some of the many signals described in the POSIX.1-1990 standard:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Signal</strong></th>
<th style="text-align: left;"><strong>Comment</strong></th>
<th style="text-align: left;"><strong>Value</strong></th>
<th style="text-align: left;"><strong>Default Action</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>SIGHUP</code></td>
<td style="text-align: left;">Hangup detected</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGINT</code></td>
<td style="text-align: left;">Keyboard interrupt (<code>Ctrl-C</code>)</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGQUIT</code></td>
<td style="text-align: left;">Quit from keyboard</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGILL</code></td>
<td style="text-align: left;">Illegal instruction</td>
<td style="text-align: left;">4</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGKILL</code></td>
<td style="text-align: left;">Kill signal</td>
<td style="text-align: left;">9</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGSEGV</code></td>
<td style="text-align: left;">Segmentation fault (invalid memory reference)</td>
<td style="text-align: left;">11</td>
<td style="text-align: left;">Terminate process, dump debug info</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGTERM</code></td>
<td style="text-align: left;">Termination signal</td>
<td style="text-align: left;">15</td>
<td style="text-align: left;">Terminate process</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGCHLD</code></td>
<td style="text-align: left;">Child stopped or terminated</td>
<td style="text-align: left;">20,17,18</td>
<td style="text-align: left;">Ignore</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SIGCONT</code></td>
<td style="text-align: left;">Continue if stopped</td>
<td style="text-align: left;">19,18,25</td>
<td style="text-align: left;">Continue the process if stopped</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SIGSTOP</code></td>
<td style="text-align: left;">Stop process</td>
<td style="text-align: left;">18,20,24</td>
<td style="text-align: left;">Stop process</td>
</tr>
</tbody>
</table>
<p>Alternatively, a process may inform the operating system it is prepared to handle the signal itself (such as doing some cleanup when the <code>Ctrl-C</code> is received instead of just dying). In any event, a signal needs to be handled, even if the handling is to ignore it. Note that the signals <code>SIGKILL</code> and <code>SIGSTOP</code> cannot be caught, blocked, or ignored.</p>
<p>On the command line, the command to send a signal is also<code>kill</code> followed by a process ID. Normally a command like <code>kill 24601</code> will send <code>SIGHUP</code> to a process, which will, by default, kill the process. The process has an opportunity to clean things up if it wants to. If the process is still stuck, you can “force” kill the process by sending <code>SIGKILL</code> with the command <code>kill -9 24601</code>. The <code>-9</code> parameter says to send signal 9 (<code>SIGKILL</code>) rather than the default 1 (<code>SIGHUP</code>). Some users are eager to jump to <code>kill -9</code> whenever a process is stuck, but it’s usually worthwhile to attempt a less severe killing (<code>SIGHUP</code> or <code>Ctrl-C</code>) so that the process can at least try to clean up.</p>
<p>A signal is, interestingly, a form of inter-process communication: you are sending a signal from one process to another, even if it’s your terminal doing the sending. When we have more than one process, we might want them to communicate, so we should look into how to make that happen.</p>
<h1 id="inter-process-communication" class="unnumbered">6 — Inter-Process Communication</h1>
<h2 id="inter-process-communication-ipc" class="unnumbered">Inter-Process Communication (IPC)</h2>
<p>When two or more processes would like to co-ordinate or exchange data the mechanism for doing so is called <em>inter-process communication</em>, usually abbreviated as IPC. If a process shares data with another process in the system, the operating system will provide some facilities to make this possible.</p>
<p>The motivations for inter-process communication are fairly obvious and we do not need to waste time with long descriptions of scenarios where IPC is desirable. Every time you send an e-mail, for example, there’s IPC going on. In the context of your own program, you could consider breaking a large task into smaller subtasks, allowing multiple users to edit the same data, and system modularity.</p>
<p>Before proceeding, we need to define some idea about what communication is: transfer of data from one process to another. The data being transferred is typically referred to as the <em>message</em>. The process sending that message is the <em>sender</em> and the process receiving it will be the <em>receiver</em>. This terminology is brutally, painfully obvious, but completeness is key.</p>
<p>The processes involved must have some agreement on what data a message should contain, and the way the data is formatted. Though there may be defined standards, e.g., transferring data formatted in XML, for the message content, the processes themselves would have to be aware of the fact that the message is in XML format. How this agreement is reached tends to fall outside the purview of the operating system; perhaps the authors agree in a meeting or the sender publishes its format online and the author of the receiver program writes her code to accommodate that.</p>
<p>Sending and receiving of messages may be either synchronous or asynchronous. If sending is synchronous, the sender sends the message and then is blocked from proceeding until the message is received. If sending is asynchronous, the sender can post the message and then carry on execution. If receiving is synchronous, the receiver is blocked until it receives the message. If receiving is asynchronous, the receiver is notified there is no message available and continues execution. Thus there are four combinations to consider, three of which are common <span class="citation" data-cites="mte241"></span>:</p>
<ol>
<li><p><strong>Synchronous send, synchronous receive:</strong> the sender is blocked until the receiver collects the message; the receiver waits for a message and is blocked until it arrives.</p></li>
<li><p><strong>Synchronous send, asynchronous receive:</strong> the sender is blocked when the message is sent, but the receiver will continue whether or not a message is available. This is a very uncommon configuration.</p></li>
<li><p><strong>Asynchronous send, synchronous receive:</strong> the sender continues execution when the message is sent, but the receiver will wait until the message is received before it can continue. This is the most common configuration; usually the receiver needs a message to continue.</p></li>
<li><p><strong>Asynchronous send, asynchronous receive:</strong> the sender can continue as soon as it sends the message, and the receiver will check for a message but will continue whether or not the message is available.</p></li>
</ol>
<p>It is also common in the case of asynchronous receive for the receiver to send back another message confirming receipt of the message. When that happens, just reverse the labels: the receiver of the initial message is the sender of the acknowledgement.</p>
<p>A general paradigm for understanding IPC is known as the <em>producer-consumer</em> problem. The <em>producer</em> creates some information which is later used by the <em>consumer</em>. For example, the database may produce the data (some records from the database) to be consumed by the shell to be displayed to the user. This is a general problem and applicable to client-server situations (e.g., web servers sending out web pages to web browsers).</p>
<p>There are three approaches we will consider on how we can accomplish IPC:</p>
<ol>
<li><p>The file system.</p></li>
<li><p>Message passing.</p></li>
<li><p>Shared memory.</p></li>
</ol>
<p>All of these methods are quite common and a system can easily implement them all. There is no single option that is optimal in every situation, but each method has some areas of strength and weakness.</p>
<h3 id="file-system" class="unnumbered">File System</h3>
<p>One way for two processes to communicate is through the file system. Messages stored in the file system will be persistent and survive a reboot. It can also be used when the sender and receiver know nothing about one another (and the programmer knows nothing about any other IPC mechanisms).</p>
<p>The producer may write to a file in an agreed upon location and the consumer may read from that same location. The operating system is still involved because of its role in file creation and manipulation (as well as permissions for who may read and write a file).</p>
<p>If one file is being used then we have the problem of co-ordination: making sure one process does not overwrite the changes of another. We can get around this, however, by using multiple files with unique IDs. Consider an example from a co-op work term: if the producer is generating XML data, it can write in a file in a designated <code>import/</code> directory. The consumer program scans the directory, and when it finds files, reads the file and imports the data contained therein. The imported data is then shown in the program. In this case, since one process writes files and another reads them, there is no possibility that one process overwrites the data of another. As long as the sender chooses distinct file names, it will not overwrite a message if a second message is created before the receiver picks up the first.</p>
<h3 id="message-passing" class="unnumbered">Message Passing</h3>
<p>Message passing is a service provided by the operating system where the sender will give the message to the OS and ask that it be delivered to a recipient. There are two basic operations: sending and receiving. Messages can be of fixed or variable size.</p>
<p>Our experience with postal mail, or e-mail, suggests that to send a message successfully, the sender needs to indicate where the message should go. Under <em>direct communication</em>, each process that wants to communicate needs to explicitly name the recipient or sender of the communication, making the send and receive functions <span class="citation" data-cites="osc"></span>:<br />
<code>send(A, message)</code> – Send a message to process <span class="math inline">A</span>.<br />
<code>receive(B, message)</code> – Receive a message from process <span class="math inline">B</span>.</p>
<p>This requires <em>symmetric</em> addressing: the sender and receiver have to know one another to communicate. This deviates from our experience in sending postal mail: receiving an item does not require foreknowledge of the sender. We would more typically expect <em>asymmetric</em> addressing: the sender names the recipient, but the receiver can pick up items from anyone. The system calls for that scheme are <span class="citation" data-cites="osc"></span>:<br />
<code>send(A, message)</code> – Send a message to Process <span class="math inline">A</span> (unchanged).<br />
<code>receive(id, message)</code> – Receive a message from any process; the variable <code>id</code> is set to the sender.</p>
<p>In either case, we have to know some identifier for the other processes. This is not very flexible; if we want to replace process <span class="math inline">B</span> with some alternative software, do we have to change the identifier in <span class="math inline">A</span>, recompile it, and reinstall it? Do we “fake” the identifier of the new software so it calls itself <span class="math inline">B</span> even though it’s not the same software? Furthermore, oftentimes the sender will produce the data but is not interested in who receives it.</p>
<p>What we would like is <em>indirect communication</em> where the messages are sent to mailboxes. That makes our send and receive functions <span class="citation" data-cites="osc"></span>:<br />
<code>send(M, message)</code> – Send a message to mailbox <span class="math inline">M</span>.<br />
<code>receive(M, message)</code> – Receive a message from mailbox <span class="math inline">M</span>.</p>
<p>A mailbox may belong specifically to one process or may be set up by the operating system. If the mailbox belongs to the process, then anyone can send to this mailbox, but only the owning process may receive messages from that mailbox. If the owner process has not started or has terminated, attempting to send to that mailbox will be an error for the sender.</p>
<p>If the mailbox is owned by the operating system, it is persistent and independent of any particular process. When we used direct communication, e.g., sending to process <span class="math inline">A</span>, the communication relationship is 1:1 - one sender and one receiver. When there was a mailbox owned by <span class="math inline">A</span>, we could be certain that only process <span class="math inline">A</span> could retrieve items from that mailbox. There is no conceptual reason, however, preventing an operating system mailbox from belonging to more than one process. If mailbox <span class="math inline">M</span> belongs to the operating system and processes <span class="math inline">P_{1}</span> and <span class="math inline">P_{2}</span> have access to it, which process will receive a message sent to that mailbox?</p>
<p>There are two ways we can deal with this problem. The first is that the OS should allow only one process at a time to pick up items from the mailbox, thus preventing the problem altogether. The other solution is that the OS may have some scheme: whichever process gets there first, alternation (taking turns), or any other system of deciding whose turn it is.</p>
<p>The diagram below shows a message queue for communication between processes <span class="math inline">A</span> and <span class="math inline">B</span>:</p>
<p><img src="images/message-passing.png" alt="image" style="width:20.0%" /><br />
A view of memory in a message-passing system <span class="citation" data-cites="osc"></span>.</p>
<p>In this diagram we see something new for the receiver process: a message queue.</p>
<h3 id="message-queues" class="unnumbered">Message Queues</h3>
<p>Thus far we have dealt with messages one at a time: the sender wants to send one message and the receiver wants to receive one message. If the sender wants to send a second message before the first message is received, the sender will have three choices, regardless of whether the communication is synchronous:</p>
<ol>
<li><p>Wait for the last message to be picked up (block).</p></li>
<li><p>Overwrite the last message (sometimes this is what you want).</p></li>
<li><p>Discard the current message (let the old one remain).</p></li>
</ol>
<p>A message queue may alleviate the problem or just “kick the can down the road”. If a queue exists, when sending a message, that message is placed in the queue and when receiving a message, the first message is taken. If the queue is of (effectively) unlimited size, then the problem may generally be ignored. If the queue has a fixed size then the problem is put off but not solved: the sender can keep adding messages to the queue until the queue is full. If the queue is full, the sender has to face the same choices of what to do: block, overwrite, or discard.</p>
<h5 id="using-signals.">Using Signals.</h5>
<p>We got onto the topic of inter-process communication by talking about signals, so it makes sense to start with then. Signals are, as previously introduced, an interrupt with a specified ID. They don’t contain any “message” within them, so they are somewhat limited. It’s a little bit like how pagers work (strange as those are to think about, doctors still use them!). When someone is paged their pager vibrates and they can see only the number who paged them. So it’s like a text message, but the body is blank. Nevertheless, the poor sleep-deprived overworked medical resident is alerted and will react appropriately, dealing with the situation before going back to whatever else they were doing before being paged.</p>
<p>As you can imagine, the fact that a signal contains no message is a limitation that means signals can’t be used for every single interprocess communication scenario. That is true, but it is sufficient for some of them. When the fire alarm sounds in a building, you don’t need an accompanying voice announcement to say “this indicates a fire alarm; please calmly exit the building” – you will figure this out just fine on your own (one hopes!). Some of the reason it works out, though, is that you have previously been informed that when the fire alarm sounds it means you need to exit the building, and the same is true for signals: you need to know what to listen for and what’s supposed to happen if you want to react accordingly.</p>
<p>The appropriate header for including signals is <code>signal.h</code> and it contains the definitions that let you write <code>SIGKILL</code> instead of having to put an explicit int <code>9</code> in your program. Earlier, we introduced a small table of some of the common UNIX signals. They are by no means exhaustive, but unfortunately there is not always 100% agreement between different implementations about what the higher signal numbers are. For this reason it’s helpful to use the names, so if you use <code>SIGABC</code> then it abstracts away the fact that on one system that’s implemented as being <code>X</code> and on another it’s <code>Y</code>.</p>
<p>We already learned how to send a signal from the command line. But there are two functions for sending a signal programmatically:</p>
<div class="sourceCode" id="cb42" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb42-1" title="1"><span class="dt">int</span> kill( <span class="dt">int</span> pid, <span class="dt">int</span> signo );</a>
<a class="sourceLine" id="cb42-2" title="2"><span class="dt">int</span> raise( <span class="dt">int</span> signo );</a></code></pre></div>
<p>Both functions return 0 if they were successful and -1 if they were unsuccessful (for whatever reason, such as no such process existing). The <code>raise</code> function sends the signal to the current process, so a nice little shortcut when you need it.</p>
<p>We need to know the process ID of the recipient. This is fine, but may require a little bit of negotiation for how processes find out about each other. A common convention is for services to register themselves in some way, which might be as simple as putting a file on disk in a specific location that contains the process ID. For example, mysql (a database) server will put its process ID in the file <code>/var/run/mysqld/mysqld.pid</code> and in that file is just the number of its process ID (e.g., <code>1494</code>). So if you know where to look, you can find the recipient’s address. But this could also be communicated in any other way.</p>
<p>You can use <code>kill</code> to do some interesting things, like signal all your processes. It depends on the value chosen for your <code>pid</code> argument <span class="citation" data-cites="apunix"></span>:</p>
<ul>
<li><p><code>pid &gt; 0</code> – send the signal to the process with process ID <code>pid</code>.</p></li>
<li><p><code>pid == 0</code> – send the signal to all processes in the same process group as the caller.</p></li>
<li><p><code>pid == -1</code> – send the signal to all processes for which the calling process has permission to send a signal, except <code>init</code> and the calling process. Broadcast, basically.</p></li>
<li><p><code>pid &lt; -1</code> – send the signal to all processes whose process group ID is equal to the absolute value of <code>pid</code>.</p></li>
</ul>
<p>In addition to the signals we know, you can also invoke the <code>kill</code> function with a 0 argument for the signal. This is called the “null signal”. It does not actually send any signal, but can be used to check if the recipient process exists. If not, the <code>errno</code> return value of <code>ESRCH</code> tells you that it no longer exists <span class="citation" data-cites="apunix"></span>. This is of limited utility, however, because (1) the process might exit between the time you check for its existence and the time you do something with that information; and (2) process IDs are only relatively unique so a given ID could be reused for a different process, and the recipient is no longer whom you expect it to be...</p>
<p>A signal can be sent to a given process, but that process can only actually deal with it when that process is running. A signal is generated by something, and it is later delivered to the recipient. But during the time between generation and delivery, we say the signal is <em>pending</em>. The pending signal is typically delivered at the first opportunity, which might be immediately if the recipient is currently executing <span class="citation" data-cites="lpi"></span>.</p>
<p>Interestingly, for most (but not all) signals, your process can choose to refuse to listen. This is called blocking signals, and can be done to any with with the exception of <code>SIGKILL</code> and <code>SIGSTOP</code>. When a signal is blocked, it just remains in the pending state until signals of that type are unblocked. Blocking signals is supposed to be temporary, although a badly-behaved program could ignore them indefinitely.</p>
<p>If the same signal is sent more than once when that signal is blocked by the recipient, it might be delivered only once, depending on your particular operating system implementation <span class="citation" data-cites="apunix"></span>.</p>
<p>As introduced earlier, signals have a default action. The action that is taken when the signal is delivered is called the <em>disposition</em> of the signal. If you don’t explicitly change what happens when the signal arrives, the default (see the table) happens. But we can change it. There are three options (1) ignore it, (2) run a signal handler, and (3) run the default action. The third option is used to undo an earlier change (such as if we said we wanted to ignore the signal but now no longer do). We’ll restrict our to the “run a signal handler” option in this lecture.</p>
<p>If we decide to register a signal handler, the function is:</p>
<div class="sourceCode" id="cb43" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb43-1" title="1"><span class="dt">void</span> (*signal( <span class="dt">int</span> signo, <span class="dt">void</span> (*handler)(<span class="dt">int</span>))) (<span class="dt">int</span>);</a></code></pre></div>
<p>Yikes! That is difficult to read. The good news is that using this in practice is a lot easier. What we actually do is call a function to say “for signal <code>X</code>, run function <code>foo</code>”. There are restrictions on the function signature. It must have a <code>void</code> return type and take one parameter of an <code>int</code>. It returns a pointer to the old handler (if there was one). You could use that to set it back if you wanted.</p>
<p>So a sample signal handler would be:</p>
<div class="sourceCode" id="cb44" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb44-1" title="1"><span class="dt">void</span> sig_handler( <span class="dt">int</span> signal_num ) {</a>
<a class="sourceLine" id="cb44-2" title="2">  <span class="co">/* Handle the signal in some way */</span></a>
<a class="sourceLine" id="cb44-3" title="3">}</a></code></pre></div>
<p>The integer parameter is set to the number of the signal received. This allows us to have one signal handler that handles many signals, if we wish, but differentiate between them at the time of invocation. To register the signal handler, the simplest way is to ignore the return value of <code>signal</code>:</p>
<div class="sourceCode" id="cb45" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb45-1" title="1">signal( SIGINT, sig_handler );</a></code></pre></div>
<p>Alright, with your signal handler set up, then the workflow looks like the diagram below:</p>
<p><img src="images/sighandler.png" alt="image" style="width:50.0%" /><br />
Signal delivery, signal handler execution and return <span class="citation" data-cites="lpi"></span>.</p>
<p>The content of your signal handler, however, is restricted. Because the handler deals with an interrupt and runs between two instructions it is important to make sure that the signal handler doesn’t mess anything up. If the signal handler runs in the middle of <code>malloc</code> and the signal handler itself calls <code>malloc</code> it could put the memory management in an invalid state <span class="citation" data-cites="apunix"></span>.</p>
<p>We can only use functions that are <em>reentrant</em>. That is to say, a function that can be interrupted during execution, have another complete to that same function execute, and then resume (and have everything be okay). In particular the big ones to avoid are: <code>printf</code>, <code>malloc</code>, <code>free</code>, and anything that could possibly block the process (e.g., a read of a file!). The subject of reentrancy is a little bit more complicated than can be covered in a few sentences, and future courses should cover reentrancy in much more detail.</p>
<p>There are tables of what functions are safe to invoke from within a signal handler. In general what you are looking for is a designation of <em>async-signal safe</em>.</p>
<p>To block a signal, unblock one, or just find out what the current state is, the function is:</p>
<div class="sourceCode" id="cb46" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb46-1" title="1"><span class="dt">int</span> sigprocmask( <span class="dt">int</span> how, <span class="dt">const</span> sigset_t * set, sigset_t * old_set );</a></code></pre></div>
<p>The first argument is what we would like to do here: if <code>SIG_BLOCK</code>, the signals pointed to by <code>set</code> are added to the block list; if <code>SIG_UNBLOCK</code> then the ones in <code>set</code> are removed from the block list; if <code>SIG_SETMASK</code> then <code>set</code> is assigned to the signal mask (overwrite all current values)<span class="citation" data-cites="lpi"></span>.</p>
<p>The third argument is optional, and if a pointer is provided then upon a change to the signal mask, <code>old_set</code> is updated to contain the values from before the change.</p>
<p>There is also the ability to manage signal disposition in a more advanced way using the function <code>sigaction</code>, but we will consider this beyond the scope of the course.</p>
<p>There are some helper functions to fill in the mask:</p>
<div class="sourceCode" id="cb47" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1"><span class="dt">int</span> sigemptyset( sigset_t *set ); <span class="co">/* Initialize an empty sigset_t */</span></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="dt">int</span> sigaddset( sigset_t *set, <span class="dt">int</span> signal ); <span class="co">/* Add specified signal to set */</span></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="dt">int</span> sigfillset( sigset_t *set ); <span class="co">/* Add ALL signals to set */</span></a>
<a class="sourceLine" id="cb47-4" title="4"><span class="dt">int</span> sigdelset( sigset_t *set, <span class="dt">int</span> signal ); <span class="co">/* Remove specified signal from set */</span></a>
<a class="sourceLine" id="cb47-5" title="5"><span class="dt">int</span> sigismember( sigset_t *set, <span class="dt">int</span> signal ); <span class="co">/* Returns 1 if true, 0 if false */</span></a></code></pre></div>
<p>A quick example based on <span class="citation" data-cites="lpi"></span>:</p>
<div class="sourceCode" id="cb48" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb48-1" title="1">sigset_t set;</a>
<a class="sourceLine" id="cb48-2" title="2">sigset_t previous;</a>
<a class="sourceLine" id="cb48-3" title="3"></a>
<a class="sourceLine" id="cb48-4" title="4">sigemptyset( &amp;set ); <span class="co">/* Initialize set */</span></a>
<a class="sourceLine" id="cb48-5" title="5">sigaddset( &amp;set, SIGINT ); <span class="co">/* Add SIGINT to it */</span></a>
<a class="sourceLine" id="cb48-6" title="6"></a>
<a class="sourceLine" id="cb48-7" title="7">sigprocmask( SIG_BLOCK, &amp;set, &amp;previous ); <span class="co">/* Add SIGINT to the mask */</span></a>
<a class="sourceLine" id="cb48-8" title="8"><span class="co">/* SIGINT is blocked in this section */</span></a>
<a class="sourceLine" id="cb48-9" title="9">sigprocmask( SIG_SETMASK, &amp;previous, NULL ); <span class="co">/* Restore previous mask */</span></a></code></pre></div>
<p>Finally, if you want to pause your program for a bit until the call is interrupted by a signal, there is the function <code>int pause( )</code>. This function always returns -1 and it suspends your program until the signal handler runs. This can be useful if we really do need to wait for something...</p>
<h1 id="sockets" class="unnumbered">7 — Sockets</h1>
<h2 id="network-communication" class="unnumbered">Network Communication</h2>
<p>Another form of inter-process communication is of course the idea of network communication. If two processes are not running on the same machine in the same environment, then to get them to communicate we can’t use pipes or shared memory... instead, we must communicate over the network. But not only that: we can actually use the network as a method of communication if the two processes are on the same machine (as we will see).</p>
<p>A diagram describing network communication frequently represents the network as just a mysterious cloud or blob, and for the moment we will just pretend that is how it is. There is a whole course on how computer networks function and behave and what the various layers are. For the sake of simplicity we will focus just on how we use the network, and not how the network is implemented.</p>
<h3 id="sockets-1" class="unnumbered">Sockets</h3>
<p>The <em>socket</em> API is a standard dating back many years, describing how to communicate over the network in a standard way. The socket is the concept for how to establish a communication channel between two processes. There are really two ways that we can communicate: datagrams and connection streams.</p>
<p>A datagram is a lot like sending a letter in the mail (you know, snail mail): you can mail out letters but they can be delivered in any order, might get lost along the way, and are unidirectional <span class="citation" data-cites="apunix"></span>. The recipient of a letter can write one back if desired but it may not be. There’s no “connection” to be established, it’s just message delivery.</p>
<p>The stream is like making a telephone call. When you dial a number, the other side has to be available (i.e., not on the phone or away from their phone) and if they answer then a line of communication is established to allow exchange of data (talking). Then at some point one party or the other will hang up and that’s the end of the call. The telephone network has to do quite a bit to get your data from one end to the other in a timely manner, but that’s not really your concern at the time that you want to make the phone call.</p>
<p>Much like everything else in UNIX, a socket is handled like a file. It just so happens that when you open a socket, the data to be read or written from the “file” is being routed over the network somehow. To create a socket, we need the <code>sys/socket.h</code> header included and the call is <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb49" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb49-1" title="1"><span class="dt">int</span> socket( <span class="dt">int</span> domain, <span class="dt">int</span> type, <span class="dt">int</span> protocol )</a></code></pre></div>
<p>The arguments require some explanation. The <code>domain</code> value defines the address format (amongst other things) and is how we would choose between, for example, IPv4 and IPv6 (or other more things...). For the purposes of this course, we’ll use IPv4 and the constant for that is defined as <code>AF_INET</code> (address family: internet!).</p>
<p>The <code>type</code> argument gives what kind of information we are going to be sending. <code>SOCK_DGRAM</code> is for datagrams and <code>SOCK_STREAM</code> is for a bidirectional byte stream <span class="citation" data-cites="apunix"></span>.</p>
<p>The <code>protocol</code> argument is about how the data is to be transported over the connection, and we will just use 0 for the default. If we chose a stream, the default is TCP/IP. Without going into too much detail, TCP/IP is the way a lot of data is transported over the internet. This is a (generally) reliable method of transport that makes sure your data gets to where it needs to go, with all the pieces in the correct order. If we chose a datagram, the default is UDP, which is not a reliable method of communication: data packets might get there or they might not.</p>
<p>Notice that the return type is an integer. Why is that? Well, a file descriptor is really just an integer, as we already saw with the pipe examples. So as long as we remember that’s what the integer represents, we will not have any problems.</p>
<p>And just like a file that is opened, a socket that is opened needs to be closed when we are finished with it. For that we can just use <code>close</code>. You have probably noticed some asymmetry: there are different calls to open things (<code>open</code>, <code>pipe</code>, <code>socket</code>). That’s because when we want to open something we have to say what kind of thing we want to open. When we want to close something, we already know what type it is.</p>
<h5 id="check-the-boot-of-the-car-for-your-jumper">Check the Boot of the Car for your Jumper!</h5>
<p>When we are going to communicate over the network we have to make sure that we speak the same language. More than that, we have to speak the same dialect (British English, for example, contains phrases and terms that you might not know if you only know Canadian or American English).</p>
<p>Normally this is not something that we need to think about, but when communicating over the network, the system on the other side might have a different idea of how data is organized. Consider, if you will, a four byte (32 bit) integer. There are two possible (reasonable) orders for how its bytes can be stored: smallest to largest or largest to smallest. These are shown below as big-endian and little-endian respectively:</p>
<p><img src="images/endian" alt="image" style="width:25.0%" /><br />
Byte order for a 4-byte (32 bit) integer <span class="citation" data-cites="apunix"></span>.</p>
<p>You might think that little-endian makes no sense. This is because you are a human reading a language left to right in a case where we put lower memory addresses on the left and higher ones on the right. The computer does not care about the convention. But anyway, x86 architecture is little-endian, but others (PowerPC) are not, so we can make no assumptions about what the architecture of the other side is. For this reason, network protocols specify a particular byte ordering so that everyone agrees on the meaning of the material. And this means that we need to translate the values to the big-endian format.</p>
<p>Included in the <code>arpa/inet.h</code> header are some functions to help us out. They translate from whatever system byte order you have to the network byte order, and vice versa. Their use is advisable even if you’re sure the system you are using is big-endian, because of portability of your code. They come in 32-bit and 16-bit variants depending on what you need.</p>
<div class="sourceCode" id="cb50" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb50-1" title="1"><span class="dt">uint32_t</span> htonl( <span class="dt">uint32_t</span> hostint32 ) <span class="co">/* Translate 4 byte int to network format */</span></a>
<a class="sourceLine" id="cb50-2" title="2"><span class="dt">uint16_t</span> htons( <span class="dt">uint16_t</span> hostint16 ) <span class="co">/* Translate 2 byte int to network format */</span></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="dt">uint32_t</span> ntohl( <span class="dt">uint32_t</span> netint32 )  <span class="co">/* Translate 4 byte int to host format */</span></a>
<a class="sourceLine" id="cb50-4" title="4"><span class="dt">uint16_t</span> ntohs( <span class="dt">uint16_t</span> netint16 ) <span class="co">/* Translate 2 byte int to host format */</span></a></code></pre></div>
<p>Wait, these don’t look like integers, or unsigned integers, do they? Well, sometimes we want to be very specific about the size of the integer. As you can imagine, this routine doesn’t work if you don’t know how big of an integer you’re dealing with. And sometimes we will need to be specific about sizes.</p>
<h5 id="addresses.">Addresses.</h5>
<p>Right, so keeping this in mind, when we want to call someone, we have to put in their phone number. And if we want someone to call us, we need a phone number and we need to be ready to receive calls. This number has to be translated to the right format, sure, but we’re able to do this using those functions above. The structure for a socket address is <code>struct sockaddr_in</code>. The structure has three fields, and below is a sample initialization <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb51" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">struct</span> sockaddr_in {</a>
<a class="sourceLine" id="cb51-2" title="2">  sa_family_t sin_family; <span class="co">/* Address family */</span></a>
<a class="sourceLine" id="cb51-3" title="3">  in_port_t sin_port; <span class="co">/* Port number */</span></a>
<a class="sourceLine" id="cb51-4" title="4">  <span class="kw">struct</span> in_addr sin_addr; <span class="co">/* IPv4 Address */</span></a>
<a class="sourceLine" id="cb51-5" title="5">};</a>
<a class="sourceLine" id="cb51-6" title="6"></a>
<a class="sourceLine" id="cb51-7" title="7"><span class="kw">struct</span> sockaddr_in addr;</a>
<a class="sourceLine" id="cb51-8" title="8">addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb51-9" title="9">addr.sin_port = htons( <span class="dv">2520</span> );</a>
<a class="sourceLine" id="cb51-10" title="10">addr.sin_addr.s_addr = htonl( INADDR_ANY );</a></code></pre></div>
<p>As expected, if we want an IPv4 address then we use the matching family type of <code>AF_INET</code>. Then there are the IP address and port fields.</p>
<p>You’re almost certainly familiar with IPv4 addresses... they take the format of <code>XXX.XXX.XXX.XXX</code> where each grouping of <code>XXX</code> is a number between 0 and 255. If you want to connect to your router, for example, you might type in <code>192.168.0.1</code> in the address bar of your browser. When you type in a name, like <code>uwaterloo.ca</code> there is a translation process that occurs that transforms this into an IP address, like <code>129.97.208.23</code>. The computer uses the number; names are nice for humans, though. But here we chose a constant value, <code>INADDR_ANY</code>. This says, choose the current IP address of the current computer (and it could have several if it has more than one network connection). We aren’t trying to use any specific address; we just want one the computer has.</p>
<p>And what about ports? If you want to think about your computer’s address as being like a street address, imagine that it’s then an apartment building and the port number is which apartment the connection is made with. Different services (processes) are communicating over different ports. No two processes can be using the same port at the same time. By convention, ports with numbers below 1024 considered to be reserved for system services (and requiring superuser access to make use of). For our purposes, we will always choose ports above 1024.</p>
<p>When you log in to a server with <code>ssh</code>, for example, the default port for that is 22. This is a “well known” port, in that everyone agrees up front this port is the one for this service. Thus when a server starts up the daemon, it knows to listen for connections on port 22 and when you’re ready to connect to that server, the <code>ssh</code> client chooses that port by default.</p>
<h5 id="looking-up-the-address.">Looking Up the Address.</h5>
<p>In real life, we probably only rarely use IP addresses directly when trying to connect to services. If you already know it, that’s fine, but more likely you use a human-friendly name. For example, you use <code>ssh username@ecelinux.uwaterloo.ca</code> and don’t need to manually look up the IP address for the server. You can, of course (the command line tool is <code>nslookup</code>), but why should you have to? The computer can do this for you.</p>
<p>Looking up hostnames and the like is somewhat complex (and not the focus), so we will just learn one method for doing this. Many examples and older texts use the function <code>gethostbyname()</code>, but this is now deprecated and has been replaced with the <code>getaddrinfo()</code> function instead. You might still see it in the wild but we should learn the new way.</p>
<p>The function is prototyped in in <code>netdb.h</code> and looks like this <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb52" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb52-1" title="1"><span class="dt">int</span> getaddrinfo(<span class="dt">const</span> <span class="dt">char</span> *node,     <span class="co">// e.g. &quot;www.example.com&quot; or IP</span></a>
<a class="sourceLine" id="cb52-2" title="2">                <span class="dt">const</span> <span class="dt">char</span> *service,  <span class="co">// e.g. &quot;http&quot; or port number</span></a>
<a class="sourceLine" id="cb52-3" title="3">                <span class="dt">const</span> <span class="kw">struct</span> addrinfo *hints,</a>
<a class="sourceLine" id="cb52-4" title="4">                <span class="kw">struct</span> addrinfo **res);</a></code></pre></div>
<p>The <code>node</code> parameter is the hostname to connect to but can also be an IP address. The <code>service</code> parameter can be things like “http” to get the defined port for that protocol, but I really recommend you use explicit port number such as “80” for HTTP. The <code>hints</code> parameter is used (optionally) to restrict what kind of connection you want, such as saying you want IPv4, TCP Stream sockets, and letting the function fill in the IP address (see example below). And then there is a pointer to a <code>struct addrinfo *</code> (pointer to a pointer); that structure will be updated when the function is done. And the function does have a return value of an int, whereby 0 indicates success.</p>
<p>Okay, so let’s try it out <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb53" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb53-2" title="2"><span class="kw">struct</span> addrinfo *serverinfo;  <span class="co">// will point to the results</span></a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span> hints); <span class="co">// make sure the struct is empty</span></a>
<a class="sourceLine" id="cb53-5" title="5">hints.ai_family = AF_INET;     <span class="co">// Choose IPv4</span></a>
<a class="sourceLine" id="cb53-6" title="6">hints.ai_socktype = SOCK_STREAM; <span class="co">// TCP stream sockets</span></a>
<a class="sourceLine" id="cb53-7" title="7">hints.ai_flags = AI_PASSIVE;     <span class="co">// fill in my IP for me</span></a>
<a class="sourceLine" id="cb53-8" title="8"></a>
<a class="sourceLine" id="cb53-9" title="9"><span class="dt">int</span> result = getaddrinfo(<span class="st">&quot;www.example.com&quot;</span>, <span class="st">&quot;2520&quot;</span>, &amp;hints, &amp;serverinfo);</a>
<a class="sourceLine" id="cb53-10" title="10"><span class="cf">if</span> (result != <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb53-11" title="11">  <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb53-12" title="12">}</a>
<a class="sourceLine" id="cb53-13" title="13"><span class="kw">struct</span> sockaddr_in * sain = (<span class="kw">struct</span> sockaddr_in*) serverinfo-&gt;ai_addr;</a>
<a class="sourceLine" id="cb53-14" title="14"><span class="co">/* Do things with this */</span></a>
<a class="sourceLine" id="cb53-15" title="15"></a>
<a class="sourceLine" id="cb53-16" title="16">freeaddrinfo( serverinfo );</a></code></pre></div>
<p>Assuming that all went well, the <code>serverinfo</code> pointer is now pointing to a linked list of <code>struct sockaddr</code> (the generic form of <code>sockaddr_in</code>) which gives us the information we need: the IP address for the server we want to communicate with. The actual info struct is in the linked list node’s <code>ai_addr</code> attribute and the pointer to the next one is <code>ai_next</code>. Most of the time we just need the first result, though. The <code>struct sockaddr</code> structure we got out of this can be used in future calls (although we might need to cast the result to the type we need).</p>
<p>If we are interested in getting the structure for the local computer, we can manually initialize the <code>struct sockaddr_in</code> as we did before learning about how <code>getaddrinfo()</code> works. Or we can call <code>getaddrinfo()</code> with <code>NULL</code> as the <code>node</code> parameter.</p>
<p>As some further notes, it’s possible to use <code>NULL</code> for the hints if you are willing to accept the defaults (we usually are if we’re sure about the type of result we will get). To deallocate the information that has been allocated, the call is <code>freeaddrinfo()</code> as shown above.</p>
<h5 id="client-connect.">Client: Connect.</h5>
<p>Up until now, the tools we’ve learned about, <code>socket</code> and creating the <code>struct sockaddr</code> (one way or another) apply to both the client and server side in network communication. Now the paths diverge depending on whether the code we are running is the client or the server.</p>
<p>If we are the client, we’d like to connect to a server. This is the easier workflow. We just call <code>connect()</code>. This is done with <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb54" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb54-1" title="1"><span class="dt">int</span> connect( <span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t len); </a></code></pre></div>
<p>The parameters are simple enough: the first argument <code>sockfd</code> is the socket file descriptor (the <code>int</code> we got back from the call to <code>socket</code>). The second parameter is a pointer to the <code>struct sockaddr</code> that we have, whether manually created or a returned value from <code>getaddrinfo</code>). The last parameter is about the size of the second parameter. If we manually created the structure, we just use <code>sizeof</code>; if it was returned from <code>getaddrinfo()</code> then there is also an attribute <code>ai_addrlen</code> provided. Consider an example using <code>getaddrinfo</code> <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb55" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">struct</span> addrinfo hints;</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="kw">struct</span> addrinfo *res;</a>
<a class="sourceLine" id="cb55-3" title="3"><span class="dt">int</span> sockfd;</a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5">memset(&amp;hints, <span class="dv">0</span>, <span class="kw">sizeof</span>( hints ));</a>
<a class="sourceLine" id="cb55-6" title="6">hints.ai_family = AF_INET;</a>
<a class="sourceLine" id="cb55-7" title="7">hints.ai_socktype = SOCK_STREAM;</a>
<a class="sourceLine" id="cb55-8" title="8"></a>
<a class="sourceLine" id="cb55-9" title="9">getaddrinfo(<span class="st">&quot;www.uwaterloo.ca&quot;</span>, <span class="st">&quot;80&quot;</span>, &amp;hints, &amp;res);</a>
<a class="sourceLine" id="cb55-10" title="10">sockfd = socket(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);</a>
<a class="sourceLine" id="cb55-11" title="11"></a>
<a class="sourceLine" id="cb55-12" title="12"><span class="dt">int</span> status = connect(sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);</a></code></pre></div>
<p>The return value of <code>connect</code> determines whether we successfully connected or not. Zero means we were successful, anything else indicates an error. The man pages (i.e., manual pages) describing this function will tell you about specific error codes. For example, a quick search turns up <a href="http://man7.org/linux/man-pages/man2/connect.2.html">http://man7.org/linux/man-pages/man2/connect.2.html</a>. So if you are working with a system call and you get back a nonzero value, it’s worth checking the man pages to see what it means. Printing out an error code directly isn’t super helpful, but you can compare it against the constants defined in the man page. So if you check and see the status variable equals <code>ETIMEDOUT</code>, then you know the connection attempt timed out – you know what went wrong. The specifications don’t always associate a specific number with a specific error (e.g., -7 means X) so you have to check against the constants in the implementation you have.</p>
<p>Assuming that you connected successfully, you’re now ready to start using the connection. But before we do that, let’s see what happens on the server side.</p>
<h5 id="server-bind-listen-and-accept.">Server: Bind, Listen, and Accept.</h5>
<p>The overview of what steps the server is going to do is bind, listen, and accept. The bind step is how we choose what port we are going to connect to. The listen step is the part where we wait for connections from a client. Then the last step is accept, that is, establish the connection so we can start talking.</p>
<p>Step one is <code>bind()</code>: this is how we associate the socket with whatever port we want to use. When the <code>ssh</code> daemon is available for connection, it’s because it has bound itself to the port 22 using <code>bind</code>.</p>
<p>So a quick example of using <code>bind</code> then, done without using <code>getaddrinfo</code>:</p>
<div class="sourceCode" id="cb56" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb56-1" title="1"><span class="dt">int</span> socketfd = socket( AF_INET, SOCK_STREAM, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb56-2" title="2"><span class="kw">struct</span> sockaddr_in addr;</a>
<a class="sourceLine" id="cb56-3" title="3">addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb56-4" title="4">addr.sin_port = htons( <span class="dv">2520</span> );</a>
<a class="sourceLine" id="cb56-5" title="5">addr.sin_addr.s_addr = htonl( INADDR_ANY );</a>
<a class="sourceLine" id="cb56-6" title="6"></a>
<a class="sourceLine" id="cb56-7" title="7">bind( socketfd, (<span class="kw">struct</span> sockaddr*) &amp;addr, <span class="kw">sizeof</span>( addr ));</a></code></pre></div>
<p>With that done, we’ve acquired the resource of port 2520 for our use. We haven’t done anything with it yet, but we’ve taken it for ourselves. You’ll notice also this did not happen on the client side. This is because we don’t care (usually) on the client side what the outgoing port number is. So we can just skip that step, unless we have a reason to care what the outgoing port is.</p>
<p>Step two is <code>listen()</code>: int this step we wait for incoming connections. This is the simplest step and you just call:</p>
<div class="sourceCode" id="cb57" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb57-1" title="1"><span class="dt">int</span> listen(<span class="dt">int</span> sockfd, <span class="dt">int</span> backlog); </a></code></pre></div>
<p>We listen on a socket that has been bound with <code>bind</code> and we’ll allow a backlog up to <code>backlog</code> connections (which usually is limited to 20 or so, it depends on your system). If the queue is full the server system will reject additional requests.</p>
<p>So we’ve chosen a socket (got a phone number), we’ve said we’re ready to listen (our phone is turned on), and then the next step is to <code>accept()</code> incoming <code>connect</code> requests (press the green icon). The <code>accept</code> call looks like this <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb58" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1"><span class="dt">int</span> accept( <span class="dt">int</span> sockfd, <span class="kw">struct</span> sockaddr *addr, socklen_t *len ); </a></code></pre></div>
<p>The first parameter is, of course, the socket that we are listening to. The second and third parameters are the information about the client. We allocate these, pass them in, and they are updated by the call to <code>accept</code>. If we don’t care at all about who the client is you can give in <code>NULL</code> for the second and third parameters. We don’t strictly speaking need those values for communication in both directions, but it might be helpful in many contexts to know who the client is.</p>
<p>The return value is a new file descriptor which describes a new socket. Further communication takes places over that socket (and not the original one). The original socket is still used for accepting connections, and the new one is the socket used for communication with the client.</p>
<p>If <code>accept</code> is called and no requests are in the queue, the server is blocked until a request arrives. We simply wait for the connection.</p>
<p>Let’s see a quick example of how to put all the pieces together now, skipping the error checking for compactness <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb59" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1"><span class="kw">struct</span> sockaddr_in client_addr;</a>
<a class="sourceLine" id="cb59-2" title="2"><span class="dt">int</span> client_addr_size = <span class="kw">sizeof</span>( <span class="kw">struct</span> sockaddr_in );</a>
<a class="sourceLine" id="cb59-3" title="3"><span class="dt">int</span> newsockfd;</a>
<a class="sourceLine" id="cb59-4" title="4"></a>
<a class="sourceLine" id="cb59-5" title="5"><span class="dt">int</span> socketfd = socket( AF_INET, SOCK_STREAM, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb59-6" title="6"><span class="kw">struct</span> sockaddr_in server_addr;</a>
<a class="sourceLine" id="cb59-7" title="7">server_addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb59-8" title="8">server_addr.sin_port = htons( <span class="dv">2520</span> );</a>
<a class="sourceLine" id="cb59-9" title="9">server_addr.sin_addr.s_addr = htonl( INADDR_ANY );</a>
<a class="sourceLine" id="cb59-10" title="10"></a>
<a class="sourceLine" id="cb59-11" title="11">bind( socketfd, (<span class="kw">struct</span> sockaddr*) &amp;server_addr, <span class="kw">sizeof</span>( server_addr ));</a>
<a class="sourceLine" id="cb59-12" title="12">listen( socketfd, <span class="dv">5</span> );</a>
<a class="sourceLine" id="cb59-13" title="13">newsockfd = accept( socktfd, (<span class="kw">struct</span> sockaddr*) &amp;client_addr, &amp;client_addr_size );</a>
<a class="sourceLine" id="cb59-14" title="14"></a>
<a class="sourceLine" id="cb59-15" title="15"><span class="co">/* Do something useful */</span></a>
<a class="sourceLine" id="cb59-16" title="16"></a>
<a class="sourceLine" id="cb59-17" title="17">close( newsockfd );</a>
<a class="sourceLine" id="cb59-18" title="18"></a>
<a class="sourceLine" id="cb59-19" title="19"><span class="co">/* Later when all is done */</span></a>
<a class="sourceLine" id="cb59-20" title="20">close( socketfd );</a></code></pre></div>
<p>Unless communication is a one-time thing, we probably call <code>accept</code> in some sort of loop, constantly accepting new connections and doing something useful with each, before going on to the next.</p>
<p>We could save ourselves some trouble by not caring about the client address:</p>
<div class="sourceCode" id="cb60" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1"><span class="dt">int</span> newsockfd;</a>
<a class="sourceLine" id="cb60-2" title="2"></a>
<a class="sourceLine" id="cb60-3" title="3"><span class="dt">int</span> socketfd = socket( AF_INET, SOCK_STREAM, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb60-4" title="4"><span class="kw">struct</span> sockaddr_in server_addr;</a>
<a class="sourceLine" id="cb60-5" title="5">server_addr.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb60-6" title="6">server_addr.sin_port = htons( <span class="dv">2520</span> );</a>
<a class="sourceLine" id="cb60-7" title="7">server_addr.sin_addr.s_addr = htonl( INADDR_ANY );</a>
<a class="sourceLine" id="cb60-8" title="8"></a>
<a class="sourceLine" id="cb60-9" title="9">bind( socketfd, (<span class="kw">struct</span> sockaddr*) &amp;server_addr, <span class="kw">sizeof</span>( server_addr ));</a>
<a class="sourceLine" id="cb60-10" title="10">listen( socketfd, <span class="dv">5</span> );</a>
<a class="sourceLine" id="cb60-11" title="11">newsockfd = accept( socktfd, NULL, NULL );</a>
<a class="sourceLine" id="cb60-12" title="12"><span class="co">/* Do something useful */</span></a>
<a class="sourceLine" id="cb60-13" title="13"></a>
<a class="sourceLine" id="cb60-14" title="14">close( newsockfd );</a>
<a class="sourceLine" id="cb60-15" title="15"></a>
<a class="sourceLine" id="cb60-16" title="16"><span class="co">/* Later when all is done */</span></a>
<a class="sourceLine" id="cb60-17" title="17">close( socketfd );</a></code></pre></div>
<p>And then we are finally ready for the client and server to communicate (the client using its original socket file descriptor, and the server using the new file descriptor). As we’ve seen, there’s a lot of setup when we learn about sockets for the first time. It is likely that in a program that does a lot with sockets, some of the lines of boilerplate code will be put into functions which can be invoked with just a few parameters. For example, you might write a client side function like this:</p>
<div class="sourceCode" id="cb61" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1"><span class="dt">int</span> connect_to( <span class="dt">const</span> <span class="dt">char</span>* host, <span class="dt">const</span> <span class="dt">char</span>* port ); </a></code></pre></div>
<p>This function does all the initialization, gets the address info, creates the socket, calls <code>connect</code>, checks for errors, and then returns the file descriptor for writing. Convenient! But we had to learn a bit about how the magic works before we could use it...</p>
<h1 id="network-communication-1" class="unnumbered">8 — Network Communication</h1>
<h2 id="network-communication-continued" class="unnumbered">Network Communication, Continued</h2>
<p>We now have a good idea about how to establish a connection for communication, but have thus far not actually sent or received any data! Let’s assume that all the setup from before is done and we have established a connection. If we want to send datagrams, the workflow is different and we’ll come back to that afterwards.</p>
<p>Either side can send or receive data. Figuring out whose turn it is to talk and whose turn it is to listen is the job of client and server themselves. Also what the content is, and how to interpret it is the province of the client and server.</p>
<h5 id="send.">Send.</h5>
<p>The function for sending data is <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb62" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1"><span class="dt">int</span> send( <span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span>* msg, <span class="dt">int</span> length, <span class="dt">int</span> flags );</a></code></pre></div>
<p>The first parameter is the socket file descriptor and this is either the one returned by the call to <code>socket()</code> (client-side) or <code>accept()</code> (server-side). Then there is the data to send (some arbitrary bytes). The third parameter is the length of whatever we are sending. The last parameter is the flags and for a simple use case we can just give <code>0</code> to the function for this.</p>
<p>The return value of the function is the number of bytes sent. If something went wrong, this will be -1 and the <code>errno</code> variable will tell you more about what exactly went wrong. Under ideal circumstances, the number of bytes sent equals the length parameter.</p>
<p>Let’s consider a modified example from <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb63" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1"><span class="dt">char</span> *msg = <span class="st">&quot;Hello world!&quot;</span></a>
<a class="sourceLine" id="cb63-2" title="2"><span class="dt">int</span> len = strnlen( msg, <span class="dv">13</span> );</a>
<a class="sourceLine" id="cb63-3" title="3"><span class="dt">int</span> sent = send( sockfd, msg, len, <span class="dv">0</span> );</a></code></pre></div>
<p>And there you are, the data is sent! Assuming it went well. In real life it might be best to check for -1; unlike something like <code>malloc()</code> where the failure case is rare (is the memory allocator really going to be unable to give you an <code>int</code> often?), networks are tricky and can fail. Checking is worthwhile...</p>
<p>But wait a minute, we said under ideal circumstances the number of bytes is equal to the length. As you might have guessed, there is a limit to the amount of data that you can send in one chunk. The actual amount you can send in one chunk is reasonably-sized (somewhere around 1KB) but you can’t just memorize a number and assume that will always be true across all systems. So if you have a significant chunk of data to send, you’ll need to check how much was sent and then you are responsible for sending out the rest.</p>
<p>If the data being sent is large enough that this is a concern, or you are doing something that isn’t just a test/demo application, you should track the number of bytes sent and keep calling send, updating the pointer as you advance. The code below is modified from <span class="citation" data-cites="getaddrinfo"></span> that sends as many times as necessary until we’re down to 0 bytes left to send:</p>
<div class="sourceCode" id="cb64" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb64-1" title="1"><span class="dt">int</span> sendall( <span class="dt">int</span> socket, <span class="dt">char</span> *buf, <span class="dt">int</span> *len ) {</a>
<a class="sourceLine" id="cb64-2" title="2">  <span class="dt">int</span> total = <span class="dv">0</span>;        <span class="co">// how many bytes we&#39;ve sent</span></a>
<a class="sourceLine" id="cb64-3" title="3">  <span class="dt">int</span> bytesleft = *len; <span class="co">// how many we have left to send</span></a>
<a class="sourceLine" id="cb64-4" title="4">  <span class="dt">int</span> n;</a>
<a class="sourceLine" id="cb64-5" title="5"></a>
<a class="sourceLine" id="cb64-6" title="6">  <span class="cf">while</span>( total &lt; *len ) {</a>
<a class="sourceLine" id="cb64-7" title="7">    n = send( socket, buf + total, bytesleft, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb64-8" title="8">    <span class="cf">if</span> (n == -<span class="dv">1</span>) { </a>
<a class="sourceLine" id="cb64-9" title="9">      <span class="cf">break</span>; </a>
<a class="sourceLine" id="cb64-10" title="10">    }</a>
<a class="sourceLine" id="cb64-11" title="11">    total += n;</a>
<a class="sourceLine" id="cb64-12" title="12">    bytesleft -= n;</a>
<a class="sourceLine" id="cb64-13" title="13">  }</a>
<a class="sourceLine" id="cb64-14" title="14">  *len = total; <span class="co">// return number actually sent here</span></a>
<a class="sourceLine" id="cb64-15" title="15">  <span class="cf">return</span> n == -<span class="dv">1</span> ? -<span class="dv">1</span> : <span class="dv">0</span>; <span class="co">// return -1 on failure, 0 on success</span></a>
<a class="sourceLine" id="cb64-16" title="16">}</a></code></pre></div>
<h5 id="receive.">Receive.</h5>
<p>And if you’d like to receive data, the call for this is <code>recv()</code>; its signature is almost the same but not identical <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb65" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb65-1" title="1"><span class="dt">int</span> recv( <span class="dt">int</span> sockfd, <span class="dt">void</span> * buffer, <span class="dt">int</span> length, <span class="dt">int</span> flags );</a></code></pre></div>
<p>The socket file descriptor is the place to receive data from. The buffer parameter is the destination where the data goes, and the length is the maximum size of that buffer. Flags can also be 0 here.</p>
<p>The return value is the number of bytes actually read into the buffer. If you got back -1, then an error occurred and check <code>errno</code> for more details. If you got back 0, it means the other side hung up on you: they closed the socket. So no point in waiting anymore!</p>
<p>Knowing that the other side is finished sending data is not necessarily all that easy. That’s something to work out with the sender. This is why in movies when characters communicate with walkie-talkies, they say “over” when they have finished their transmission... so the recipient will know they are finished talking. In network communication, we might know in advance the size of data we are supposed to get, or we might be told as part of the (negotiated) protocol, or we might need to wait for the other side to close the connection (then we know they are definitely done).</p>
<p>Suppose we are sending more than just a string. Can we do a fancy thing and write directly to a <code>struct</code> by making the buffer location the location of that <code>struct</code> and the length the <code>sizeof</code> that type? Yes, you can but this requires that the representation you receive over the network to be exactly the same as your struct. A more sensible approach is to serialize your data in some way, and then de-serialize it on the other side.</p>
<p>Serialization is the process of converting the data to some sort of byte-representation so that it can be sent across the network (or stored in a database, or anything really) and then later reconstructed via the deserialization process. This means that no particular data format is needed and systems that don’t use the same software or architecture, even, can communicate easily.</p>
<p>In a practical scenario there’s no need to write your own (de)serialization routine; there exist libraries like <code>protobuf-c</code> that are designed explicitly for this purpose. Pick a good one and use it.</p>
<p>But anyway, this is it! That’s how we send and receive data. When we’re done, we just call <code>close()</code> on the socket and that is the end. We now know how to communicate over the network.</p>
<h3 id="datagrams" class="unnumbered">Datagrams</h3>
<p>But if you don’t want to establish a communication channel and you just want to send a message (that is, calling is for old people and we just want to text people) there are two related functions for that instead <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb66" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1"><span class="dt">int</span> sendto( <span class="dt">int</span> sockfd, <span class="dt">const</span> <span class="dt">void</span>* msg, <span class="dt">int</span> length, <span class="dt">unsigned</span> <span class="dt">int</span> flags, </a>
<a class="sourceLine" id="cb66-2" title="2">    <span class="dt">const</span> <span class="kw">struct</span> sockaddr* to, socklen_t tolength )</a>
<a class="sourceLine" id="cb66-3" title="3"></a>
<a class="sourceLine" id="cb66-4" title="4"><span class="dt">int</span> recvfrom( <span class="dt">int</span> sockfd, <span class="dt">void</span>* buffer, <span class="dt">int</span> length, <span class="dt">unsigned</span> <span class="dt">int</span> flags, </a>
<a class="sourceLine" id="cb66-5" title="5">    <span class="kw">struct</span> sockaddr* from, <span class="dt">int</span>* fromlength )</a></code></pre></div>
<p>Given what we’ve covered here nothing is really surprising. Because there’s no connection established, each send has parameters for where to send the data to and each receive tells you where the data is being received from. Send still returns the number of bytes sent and may be less than you were expecting if sending a large amount of data.</p>
<p>If you call <code>connect()</code> on a datagram socket, incidentally, you can then skip some of this and just use the regular <code>send</code> and <code>recv</code> operations – the transport is still UDP, but the source and destination don’t need to be added every time.</p>
<p>In our next lecture, we will do an in-class exercise related to using sockets. The in-class exercise will provide an opportunity to use the socket code we’ve learned in a way that is more engaging than just seeing yet another code example in the lecture notes.</p>
<h3 id="curl" class="unnumbered">cURL</h3>
<p>In most situations, however, we don’t work with sockets directly when dealing with URLs. Instead we are likely to use cURL (or similar), a network communication and transfer request library. There is an associated command-line tool, but the client-side library is the area of interest because we can build on it in our program and save ourselves a lot of hassle. The curl library can do a lot of things and communicate via a lot of different protocols. It is quite flexible in that way. But it is only for the client-side and isn’t meant to be used for server-side operations.</p>
<p>Imagine, if you will, that you want to access a webservice. Lots of things run via web service now and you are probably already somewhat familiar with them. In short, servers have “endpoints” that clients connect to via HTTP, and then the client can get a response. There are numerous examples of services that use this mechanism and they often adhere to some design principles like REST (REpresentational State Transfer). If we wished to communicate, for example, a GET request (to “get” some resource), then we can put together a connection via a socket and write the “"GET / HTTP/1.0\r\n"” into a string and send that message via <code>send()</code>. But there’s no need to do it all by hand because we can do this very easily with libcurl.</p>
<p>As you might imagine, the information in this section is based on the official libcurl documentation. We don’t cover every option or every detail, so it might be worth it to read some of the official documentation if you get stuck: <a href="https://curl.haxx.se/libcurl/c/">https://curl.haxx.se/libcurl/c/</a>.</p>
<p>This example, modified from <a href="https://curl.haxx.se/libcurl/c/https.html">https://curl.haxx.se/libcurl/c/https.html</a> outlines all the key parts we need to use the curl library. We’ll go through it and see what each of the parts do:</p>
<div class="sourceCode" id="cb67" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb67-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb67-2" title="2"><span class="pp">#include </span><span class="im">&lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb67-3" title="3"> </a>
<a class="sourceLine" id="cb67-4" title="4"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb67-5" title="5">  CURL *curl;</a>
<a class="sourceLine" id="cb67-6" title="6">  CURLcode res;</a>
<a class="sourceLine" id="cb67-7" title="7"> </a>
<a class="sourceLine" id="cb67-8" title="8">  curl_global_init(CURL_GLOBAL_DEFAULT);</a>
<a class="sourceLine" id="cb67-9" title="9"> </a>
<a class="sourceLine" id="cb67-10" title="10">  curl = curl_easy_init();</a>
<a class="sourceLine" id="cb67-11" title="11">  <span class="cf">if</span>( curl ) {</a>
<a class="sourceLine" id="cb67-12" title="12">    curl_easy_setopt(curl, CURLOPT_URL, <span class="st">&quot;https://example.com/&quot;</span> );</a>
<a class="sourceLine" id="cb67-13" title="13">    res = curl_easy_perform(curl);</a>
<a class="sourceLine" id="cb67-14" title="14">    </a>
<a class="sourceLine" id="cb67-15" title="15">  <span class="cf">if</span>( res != CURLE_OK) {</a>
<a class="sourceLine" id="cb67-16" title="16">      fprintf(stderr, <span class="st">&quot;curl_easy_perform() failed: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, curl_easy_strerror(res));</a>
<a class="sourceLine" id="cb67-17" title="17">    }</a>
<a class="sourceLine" id="cb67-18" title="18">    curl_easy_cleanup(curl);</a>
<a class="sourceLine" id="cb67-19" title="19">  }</a>
<a class="sourceLine" id="cb67-20" title="20"> </a>
<a class="sourceLine" id="cb67-21" title="21">  curl_global_cleanup();</a>
<a class="sourceLine" id="cb67-22" title="22">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb67-23" title="23">}</a></code></pre></div>
<p>Starting from the top then: we need to include the header <code>curl/curl.h</code>. If you are trying to compile and run a program on your own system and this header is not found, you need to install <code>libcurl-dev</code> on the system.</p>
<p>At the beginning of <code>main</code> there are two variables declared. The <code>CURL</code> structure is our “handle”. This needs to be, like many structures, initialized before use and cleaned up when we’re done with it. The <code>CURLcode</code> type is also a useful structure for finding out how operations went. Unlike in many other scenarios where success is assumed, remember, in the network we should always check and see what happened.</p>
<p>All the code that uses the network is bracketed in the <code>curl_global_init()</code> and <code>curl_global_cleanup()</code>. For the initialization, we take the defaults with <code>CURL_GLOBAL_DEFAULT</code> which is sufficient. If we forget to call the global initialization function then the later call to <code>curl_easy_init</code> will do it for us, but this is dangerous because having it called more than once is an issue. And of course we should not forget to clean up when done.</p>
<p>Each connection is accessed through the handle, and so the handle is initialized with <code>curl_easy_init()</code>. If something goes wrong, the handle is set to NULL (hence why it can be used in the if-statement). If everything went well then we can actually get to work. If you are wondering why there is “easy” in the function names, it’s not because there is a “hard” interface, but there is a “multi” interface that we will learn about in the future. (Whether you think the multi interface is hard is a separate discussion).</p>
<p>The next thing to do is set options for the connection. The only mandatory option its the URL to use (otherwise we don’t know where to connect to, after all). In this case it’s a dummy URL but it will do for the purposes of the code example. In the future we will need to set other options to do anything useful with a response, but for now the simple example leaves that out. There are something like 200 options, according to the documentation, so you can configure just about anything you want.</p>
<p>With all setup done, then we can perform the request with <code>curl_easy_perform</code>. This is the step that actually sends data over the network and retrieves a response. The result is stored in <code>res</code>.</p>
<p>Then we need to check and see if everything worked: <code>CURLE_OK</code> is the response code if all went well. Otherwise we get back something else and the function <code>curl_easy_strerror</code> interprets an error for us making it a little easier to understand what happened... isn’t this a lot better than having to go google what the given value of <code>errno</code> is?</p>
<p>A handle can be used multiple times if you need, although you may need to update the options that are set on it to reflect the new things you’d like to happen</p>
<p>If we wanted to re-use a handle but clear all the settings there is <code>curl_easy_reset</code>, but that’s not the case in this scenario since the example is a one-time thing. Instead, we clean up. When we’re done with a given handle we clean it up with <code>curl_easy_cleanup</code>. And then of course when all is finished there’s the global cleanup. Excellent!</p>
<h5 id="setting-up-callbacks.">Setting up Callbacks.</h5>
<p>Almost certainly, however, we want to do something useful with the data we got. Or, we might have some data that we need to send. For each direction, what we want to set up is a <em>callback</em>.</p>
<p>In case you haven’t been introduced to the concept, it’s a lot like what happens when you tell someone “when you’re finished, call me back”. They were in the middle of something when you called, and when a certain condition is fulfilled, they call you. In the context of using the cURL library, we tell the curl handle what function we would like it to call when the appropriate time comes.</p>
<p>The read callback is used when you are uploading data to the server (sometimes this is a POST operation). The write callback is used when you are receiving data from the server (this can be a GET operation). You may set up a read or write callback (or both) for an operation. There can be different callbacks for different easy handles, of course.</p>
<p>A write function has to have the following signature (according to the official documentation):</p>
<div class="sourceCode" id="cb68" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb68-1" title="1"><span class="dt">size_t</span> write_callback( <span class="dt">char</span> *ptr, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nmemb, <span class="dt">void</span> *userdata );</a></code></pre></div>
<p>The name of the function can be anything you like. The <code>size_t</code> type represents a size and can be treated like an integer. The <code>ptr</code> points to whatever data we received and <code>nmemb</code> is the size of that data. <code>size</code> is always 1 (the documentation does not explain why this is the case). And the last parameter is user data: we can pass some data to the processing function directly. This is helpful when we have some data that we would need to provide to make processing easier or possible. If, for example, we want to write the requested data to a file with a specified name, we can pass that name in the <code>userdata</code> pointer, and then our implementation of the write callback should know how to use it. Finally, the return type is also a <code>size_t</code>; the spec requires that the returned size is the number of bytes of the data successfully processed. If it’s not equal to the size of <code>nmemb</code> then the library interprets that as an error in writing.</p>
<p>A read function is very similar:</p>
<div class="sourceCode" id="cb69" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb69-1" title="1"><span class="dt">size_t</span> read_callback( <span class="dt">char</span> *buffer, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nitems, <span class="dt">void</span> *inputdata );</a></code></pre></div>
<p>Again, the function can be called whatever you like. The <code>buffer</code> is the area where you are going to put the data to send (and it can’t be any bigger than the next parameters specify). <code>size</code> here is the size of each data element and <code>nitems</code> is the number of items. In practice you will just want to calculate the maximum buffer size by multiplying these two things together. And the return value is the number of bytes successfully put there. We might need to do this in several chunks, though. If you put 0, it signals end-of-file and means no further upload will take place.</p>
<p>And to register the read and write callback respectively, there are two steps. One to register the function, and another to set the data:</p>
<div class="sourceCode" id="cb70" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb70-1" title="1">CURLcode curl_easy_setopt( CURL *handle, CURLOPT_READFUNCTION, read_callback );</a>
<a class="sourceLine" id="cb70-2" title="2">CURLcode curl_easy_setopt( CURL *handle, CURLOPT_READDATA, <span class="dt">void</span> *pointer );</a>
<a class="sourceLine" id="cb70-3" title="3"></a>
<a class="sourceLine" id="cb70-4" title="4">CURLcode curl_easy_setopt( CURL *handle, CURLOPT_WRITEFUNCTION, write_callback );</a>
<a class="sourceLine" id="cb70-5" title="5">CURLcode curl_easy_setopt( CURL *handle, CURLOPT_WRITEDATA, <span class="dt">void</span> *pointer );</a></code></pre></div>
<p>Alright, on to an example, then, modified from <a href="https://curl.haxx.se/libcurl/c/post-callback.html">https://curl.haxx.se/libcurl/c/post-callback.html</a>.</p>
<div class="sourceCode" id="cb71" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb71-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb71-2" title="2"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb71-3" title="3"><span class="pp">#include </span><span class="im">&lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb71-4" title="4">  </a>
<a class="sourceLine" id="cb71-5" title="5"><span class="dt">const</span> <span class="dt">char</span> data[]=<span class="st">&quot;Lorem ipsum dolor sit amet, consectetur adipiscing &quot;</span></a>
<a class="sourceLine" id="cb71-6" title="6">  <span class="st">&quot;elit. Sed vel urna neque. Ut quis leo metus. Quisque eleifend, ex at &quot;</span></a>
<a class="sourceLine" id="cb71-7" title="7">  <span class="st">&quot;laoreet rhoncus, odio ipsum semper metus, at tempus ante urna in mauris. &quot;</span></a>
<a class="sourceLine" id="cb71-8" title="8">  <span class="st">&quot;Suspendisse ornare tempor venenatis. Ut dui neque, pellentesque a varius &quot;</span></a>
<a class="sourceLine" id="cb71-9" title="9">  <span class="st">&quot;eget, mattis vitae ligula. Fusce ut pharetra est. Ut ullamcorper mi ac &quot;</span></a>
<a class="sourceLine" id="cb71-10" title="10">  <span class="st">&quot;sollicitudin semper. Praesent sit amet tellus varius, posuere nulla non, &quot;</span></a>
<a class="sourceLine" id="cb71-11" title="11">  <span class="st">&quot;rhoncus ipsum.&quot;</span>;</a>
<a class="sourceLine" id="cb71-12" title="12"> </a>
<a class="sourceLine" id="cb71-13" title="13"><span class="kw">struct</span> data {</a>
<a class="sourceLine" id="cb71-14" title="14">  <span class="dt">char</span> *readptr;</a>
<a class="sourceLine" id="cb71-15" title="15">  <span class="dt">size_t</span> sizeleft;</a>
<a class="sourceLine" id="cb71-16" title="16">};</a>
<a class="sourceLine" id="cb71-17" title="17"> </a>
<a class="sourceLine" id="cb71-18" title="18"><span class="dt">size_t</span> read_callback( <span class="dt">void</span> *dest, <span class="dt">size_t</span> size, <span class="dt">size_t</span> nmemb, <span class="dt">void</span> *userp ) {</a>
<a class="sourceLine" id="cb71-19" title="19">  <span class="kw">struct</span> data *d = (<span class="kw">struct</span> data *) userp;</a>
<a class="sourceLine" id="cb71-20" title="20">  <span class="dt">size_t</span> buffer_size = size * nmemb;</a>
<a class="sourceLine" id="cb71-21" title="21"> </a>
<a class="sourceLine" id="cb71-22" title="22">  <span class="cf">if</span>( d-&gt;sizeleft &gt; <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb71-23" title="23">    <span class="co">/* copy as much as possible from the source to the destination */</span> </a>
<a class="sourceLine" id="cb71-24" title="24">    <span class="dt">size_t</span> copy_this_much = d-&gt;sizeleft;</a>
<a class="sourceLine" id="cb71-25" title="25">    <span class="cf">if</span> ( copy_this_much &gt; buffer_size ) {</a>
<a class="sourceLine" id="cb71-26" title="26">       copy_this_much = buffer_size;</a>
<a class="sourceLine" id="cb71-27" title="27">    }</a>
<a class="sourceLine" id="cb71-28" title="28">    memcpy(dest, d-&gt;readptr, copy_this_much);</a>
<a class="sourceLine" id="cb71-29" title="29"> </a>
<a class="sourceLine" id="cb71-30" title="30">    d-&gt;readptr += copy_this_much;</a>
<a class="sourceLine" id="cb71-31" title="31">    d-&gt;sizeleft -= copy_this_much;</a>
<a class="sourceLine" id="cb71-32" title="32">    <span class="cf">return</span> copy_this_much; </a>
<a class="sourceLine" id="cb71-33" title="33">  }</a>
<a class="sourceLine" id="cb71-34" title="34">  <span class="cf">return</span> <span class="dv">0</span>; <span class="co">/* no more data left to deliver */</span> </a>
<a class="sourceLine" id="cb71-35" title="35">}</a>
<a class="sourceLine" id="cb71-36" title="36"> </a>
<a class="sourceLine" id="cb71-37" title="37"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb71-38" title="38">  CURL *curl;</a>
<a class="sourceLine" id="cb71-39" title="39">  CURLcode res;</a>
<a class="sourceLine" id="cb71-40" title="40">  <span class="kw">struct</span> data * d = malloc( <span class="kw">sizeof</span>( <span class="kw">struct</span> data ) );</a>
<a class="sourceLine" id="cb71-41" title="41"> </a>
<a class="sourceLine" id="cb71-42" title="42">  d-&gt;readptr = data;</a>
<a class="sourceLine" id="cb71-43" title="43">  d-&gt;sizeleft = strlen( data );</a>
<a class="sourceLine" id="cb71-44" title="44"> </a>
<a class="sourceLine" id="cb71-45" title="45">  res = curl_global_init( CURL_GLOBAL_DEFAULT );</a>
<a class="sourceLine" id="cb71-46" title="46">  <span class="cf">if</span> ( res != CURLE_OK ) {</a>
<a class="sourceLine" id="cb71-47" title="47">    fprintf( stderr, <span class="st">&quot;curl_global_init() failed: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, curl_easy_strerror( res ) );</a>
<a class="sourceLine" id="cb71-48" title="48">    <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb71-49" title="49">  }</a>
<a class="sourceLine" id="cb71-50" title="50"> </a>
<a class="sourceLine" id="cb71-51" title="51">  curl = curl_easy_init();</a>
<a class="sourceLine" id="cb71-52" title="52">  <span class="cf">if</span> ( curl ) {</a>
<a class="sourceLine" id="cb71-53" title="53">    curl_easy_setopt( curl, CURLOPT_URL, <span class="st">&quot;https://example.com/index.cgi&quot;</span> );</a>
<a class="sourceLine" id="cb71-54" title="54"> </a>
<a class="sourceLine" id="cb71-55" title="55">    <span class="co">/* Now specify we want to POST data */</span> </a>
<a class="sourceLine" id="cb71-56" title="56">    curl_easy_setopt( curl, CURLOPT_POST, <span class="dv">1</span><span class="bu">L</span> );</a>
<a class="sourceLine" id="cb71-57" title="57"> </a>
<a class="sourceLine" id="cb71-58" title="58">    curl_easy_setopt( curl, CURLOPT_READFUNCTION, read_callback );</a>
<a class="sourceLine" id="cb71-59" title="59">    curl_easy_setopt (curl, CURLOPT_READDATA, d );</a>
<a class="sourceLine" id="cb71-60" title="60"> </a>
<a class="sourceLine" id="cb71-61" title="61">    res = curl_easy_perform(curl);</a>
<a class="sourceLine" id="cb71-62" title="62">    <span class="co">/* Check for errors */</span> </a>
<a class="sourceLine" id="cb71-63" title="63">    <span class="cf">if</span>(res != CURLE_OK) {</a>
<a class="sourceLine" id="cb71-64" title="64">      fprintf( stderr, <span class="st">&quot;curl_easy_perform() failed: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, curl_easy_strerror( res ) );</a>
<a class="sourceLine" id="cb71-65" title="65">    }  </a>
<a class="sourceLine" id="cb71-66" title="66">    curl_easy_cleanup( curl );</a>
<a class="sourceLine" id="cb71-67" title="67">  }</a>
<a class="sourceLine" id="cb71-68" title="68">  free( d );</a>
<a class="sourceLine" id="cb71-69" title="69">  curl_global_cleanup();</a>
<a class="sourceLine" id="cb71-70" title="70">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb71-71" title="71">}</a></code></pre></div>
<p>A brief explanation is in order. Up at the top there is <code>data</code>, some amount of sample data and a little structure that is used to reference the data and to keep track of how much data there is to send. This is going to be important in the read callback function. And then there is of course the read callback function itself.</p>
<p>That function conforms, as you would expect, to the function signature as expected. If we are fortunate then it is possible to send the data in one chunk. But in this example we have intentionally made the data large. So we will now figure out how much we can actually fit in there by figuring out the size of the buffer and seeing if the data to be sent is bigger than the available space. Once we’ve figured out the limit, we can copy the data with <code>memcpy</code> to the buffer. Then we update where we are reading from and how much space is left. Then we return the amount copied. When all data has been copied, we return 0.</p>
<p>A large amount of the code of <code>main</code> is the same as in the previous example. Some new things of note, are obviously the initialization of the structure <code>d</code>. We set the option for the operation to be POST (upload data) since the default is GET (fetch some data), and then we have to register the read callback as well as send the data to be used when the read function runs.</p>
<p>In these examples and our brief overview, we have really only scratched the surface of what the curl library can do. But this is enough to get the flavour of how it works and to begin to do useful work with it.</p>
<h1 id="rogue-one-a-star-wars-story" class="unnumbered">9 — Rogue One: A Star Wars Story</h1>
<h2 id="in-class-exercise-scarif-dont-like-it" class="unnumbered">In Class Exercise: Scarif Don’t Like It</h2>
<h5 id="background.">Background.</h5>
<p>You are Jyn Erso, a traitor to His Majesty the Emperor, a member of the vile rebellion. You are trapped on the planet Scarif, having stolen the plans for the Death Star, and you plan to transmit them to the rebel fleet above. Time is short, because Lord Vader is on his way... and you know how he deals with traitors. You need to upload the plans, in the hopes that the rebellion can analyze them and possibly find a weakness. Upon transmission of the plans you’ll receive an answer from the command ship indicating whether or not the transmission was successful. Furthermore, the Death Star has just dropped out of hyperspace – and Grand Moff Tarkin is keen to open fire on the facility.</p>
<h5 id="primary-objective.">Primary Objective.</h5>
<p>The primary objective of this exercise is to practice communicating with a remote server using socket communication in C.</p>
<h5 id="secondary-objectives.">Secondary Objective(s).</h5>
<p>You will also gain some more experience using the toolchain (gcc mostly) that should have been introduced in the labs for this course. This may also be your first introduction to git and gitlab.</p>
<h5 id="starter-code.">Starter Code.</h5>
<p>The starter code can be found at <a href="https://git.uwaterloo.ca/ece252-1195/ece252-e1">https://git.uwaterloo.ca/ece252-1195/ece252-e1</a> – fork this repository to your own space. See the guide for the in-class exercises for first time setup and guidance!</p>
<h5 id="submitting-your-code.">Submitting Your Code.</h5>
<p>When you’re done, use the command <code>git commit -a</code> to add all files to your commit and enter a commit message. Make sure the <code>output.txt</code> file is included and has the answer you got back from the server. Then <code>git push</code> to upload your changes to your repository. You can commit and push as many times as you like; we’ll look at whatever was last pushed. And check that you gave the course staff permissions!</p>
<h5 id="grading.">Grading.</h5>
<p>Binary grading: 1 if you have made a meaningful attempt at implementing the code; 0 otherwise.</p>
<h5 id="description-of-behaviour.">Description of Behaviour.</h5>
<p>The goal is to implement the program so that the following behaviour occurs:</p>
<ul>
<li><p>Your program should take in the IP of the rebel command ship (remote server) as the first argument. So if the IP to use is <code>127.0.0.1</code> then the program is invoked like <code>./rogue-one 127.0.0.1</code>.</p></li>
<li><p>Establish a TCP/stream connection to the command ship (actual IP will be given in the class because these things can and do change with time!). This is the client-side, so you need to get the address information (<code>getaddrinfo()</code>), create a socket (<code>socket()</code>), and then <code>connect()</code> to the remote server.</p></li>
<li><p>Once connected, transmit the plans for the Death Star! The plans are loaded for you in the <code>load_plans</code> function (which loads the file into memory for you – remember to deallocate the data when done). The plans are large, so you probably cannot send it all in one call to <code>send</code>; so check the results and send repeatedly as needed.</p></li>
<li><p>After you make your transmission, try to receive (using <code>recv()</code>) a response that could be up to 64 characters long. If your upload was unsuccessful you will get an error of some sort, otherwise you will get back a message that indicates success. You should print this message so you can see what it says. If it says “Success”, it worked!</p></li>
<li><p>Close the connection.</p></li>
<li><p>Your program should not leak memory; be sure to destroy/deallocate anything initialized/allocated.</p></li>
</ul>
<h5 id="hints-debugging-guidance.">Hints &amp; Debugging Guidance.</h5>
<p>All the steps you need to take to set up the communication, and send/receive the answer have been described in the previous lectures on sockets and network communication. If you read through those, it gives you the step by step as well as the syntax. You might also find the textbook(<span class="citation" data-cites="apunix"></span>) helpful.</p>
<p>Some general guidance is below. If you’re having trouble, try checking these things, and it may resolve your problem. If you’re still stuck you can ask a neighbour or the course staff.</p>
<ul>
<li><p>Check the documentation for how functions work if you are unfamiliar with them (google is your friend!)</p></li>
<li><p>Check return values (and possibly <code>errno</code>) for network functions if things are going wrong.</p></li>
<li><p>Have you initialized all variables? It is easy to forget; <code>malloc</code> does not initialize the value...</p></li>
<li><p>Pay attention to compiler warnings. Warnings can sometimes be ignored, but may be a hint about a semantic error that you will want to resolve. If the compiler is trying to tell you something, listen.</p></li>
<li><p>You need a buffer for receiving the data, and the receive function tells you how many bytes the server sent.</p></li>
<li><p>Don’t forget null terminators for strings! Especially one you received via the socket.</p></li>
<li><p>Is there a missing or extra <code>*</code> (dereference) on a pointer somewhere?</p></li>
<li><p>Does every memory allocation have a matching deallocation?</p></li>
<li><p>It may be helpful to put <code>printf()</code> statements to follow along what the program is doing and it may help you narrow down where the issue is.</p></li>
<li><p>Don’t be shy about asking for help; the TAs and instructor are here to help you get it done and will help you as much as is reasonable.</p></li>
</ul>
<h1 id="pipes-and-shared-memory" class="unnumbered">10 — Pipes and Shared Memory</h1>
<h2 id="ipc-same-system" class="unnumbered">IPC: Same System</h2>
<p>In addition to the message-passing mechanisms thus far seen (signals, network), we can also use pipes and shared memory. Pipes share some significant similarity with both message-passing and shared memory, so it makes for a nice way to transition from one to the other.</p>
<h3 id="unix-pipes" class="unnumbered">UNIX Pipes</h3>
<p>In UNIX, we can create a <em>pipe</em> to set up communication between a producer and consumer. The producer writes in one end of the pipe and the consumer receives it on the other. This is unidirectional, so if bidirectional communication is desired, two pipes must be used (going in different directions). The UNIX method for creating a pipe is <code>pipe</code> and it is constructed with the call <code>pipe( int fileDescriptors[])</code> where <code>fileDescriptors[0]</code> is the read-end and <code>fileDescriptors[1]</code> is the write-end <span class="citation" data-cites="osc"></span>. Yes, <code>fileDescriptors</code> means that UNIX thinks of a pipe as a file (UNIX thinks <em>everything</em> is a file...) even though it is in memory.</p>
<p><img src="images/unix-pipe.png" alt="image" style="width:50.0%" /><br />
A UNIX Pipe <span class="citation" data-cites="osc"></span>.</p>
<p>The pipe itself is a block of main memory that is interpreted as a circular queue, and each entry in the queue is fixed in size and usually one character. The sender may place the message into the queue in small chunks, but the receiver gets data one character at a time. Thus, the sender and receiver need to know when the message is finished. This may be through the use of a designated termination character (e.g., the line feed or null character), or the message may begin with an explicit value of the number of characters the message will be <span class="citation" data-cites="mte241"></span>.</p>
<p>A UNIX pipe may be stored on disk. When this happens, we call it a <em>named pipe</em>. Unless we make it a named pipe, a pipe exists only as long as the processes are communicating. Furthermore, regular pipes depend on file descriptors, so a parent-child relationship is required to get the descriptors from one process to another. The named pipe, however, might be used by any process and will persist even after the creating process has terminated. Another nice bonus of named pipes is that they can be bidirectional, so we do not need two pipes for communication to go in both directions. With that said, communication can only go in one direction at a time; if concurrent communication is required, a second pipe is needed after all.</p>
<p>You may have worked with pipes on the UNIX command line. A command like <code> cat fork.c | less </code> creates a pipe that takes the output of the <code>cat</code> program and delivers it as input to the program <code>less</code> which allows for scrolling and pagination of that data.</p>
<h5 id="unix-pipes-code-example">UNIX Pipes: Code Example</h5>
<p>Let’s consider an example from <span class="citation" data-cites="osc"></span> that combines the pipe concept with what we’ve seen before: using <code>fork</code> to spawn a new child process and then setting up a communication pipe between the parent and child. We will send a message “Greetings” from the parent to the child.</p>
<div class="sourceCode" id="cb72" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb72-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span><span class="pp"> </span></a>
<a class="sourceLine" id="cb72-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp"> </span></a>
<a class="sourceLine" id="cb72-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span><span class="pp"> </span></a>
<a class="sourceLine" id="cb72-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb72-5" title="5"></a>
<a class="sourceLine" id="cb72-6" title="6"><span class="pp">#define BUFFER_SIZE 25</span></a>
<a class="sourceLine" id="cb72-7" title="7"><span class="pp">#define READ_END 0 </span></a>
<a class="sourceLine" id="cb72-8" title="8"><span class="pp">#define WRITE_END 1</span></a>
<a class="sourceLine" id="cb72-9" title="9"></a>
<a class="sourceLine" id="cb72-10" title="10"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb72-11" title="11">  <span class="dt">char</span> write_msg[BUFFER_SIZE] = <span class="st">&quot;Greetings&quot;</span>; </a>
<a class="sourceLine" id="cb72-12" title="12">  <span class="dt">char</span> read_msg[BUFFER_SIZE];</a>
<a class="sourceLine" id="cb72-13" title="13">  <span class="dt">int</span> fd[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb72-14" title="14">  pid_t pid;</a>
<a class="sourceLine" id="cb72-15" title="15"></a>
<a class="sourceLine" id="cb72-16" title="16">  <span class="cf">if</span> (pipe(fd) == -<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb72-17" title="17">    fprintf(stderr,<span class="st">&quot;Pipe failed&quot;</span>);</a>
<a class="sourceLine" id="cb72-18" title="18">    <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb72-19" title="19">  }</a>
<a class="sourceLine" id="cb72-20" title="20">  </a>
<a class="sourceLine" id="cb72-21" title="21">  pid = fork();</a>
<a class="sourceLine" id="cb72-22" title="22">  <span class="cf">if</span> (pid &lt; <span class="dv">0</span>) { <span class="co">/* error occurred */</span> </a>
<a class="sourceLine" id="cb72-23" title="23">    fprintf(stderr, <span class="st">&quot;Fork Failed&quot;</span>); </a>
<a class="sourceLine" id="cb72-24" title="24">    <span class="cf">return</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb72-25" title="25">  }</a>
<a class="sourceLine" id="cb72-26" title="26"></a>
<a class="sourceLine" id="cb72-27" title="27">  <span class="cf">if</span> (pid &gt; <span class="dv">0</span>) { <span class="co">/* parent process */</span></a>
<a class="sourceLine" id="cb72-28" title="28">    <span class="co">/* close the unused end of the pipe */</span> </a>
<a class="sourceLine" id="cb72-29" title="29">    close(fd[READ_END]);</a>
<a class="sourceLine" id="cb72-30" title="30">    </a>
<a class="sourceLine" id="cb72-31" title="31">    <span class="co">/* write to the pipe */</span></a>
<a class="sourceLine" id="cb72-32" title="32">    write(fd[WRITE_END], write_msg, strlen(write_msg)+<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb72-33" title="33">    </a>
<a class="sourceLine" id="cb72-34" title="34">    <span class="co">/* close the write end of the pipe */</span></a>
<a class="sourceLine" id="cb72-35" title="35">    close(fd[WRITE_END]);</a>
<a class="sourceLine" id="cb72-36" title="36">    </a>
<a class="sourceLine" id="cb72-37" title="37">  } <span class="cf">else</span> { <span class="co">/* child process */</span></a>
<a class="sourceLine" id="cb72-38" title="38">    <span class="co">/* close the unused end of the pipe */</span> </a>
<a class="sourceLine" id="cb72-39" title="39">    close(fd[WRITE_END]);</a>
<a class="sourceLine" id="cb72-40" title="40">    </a>
<a class="sourceLine" id="cb72-41" title="41">    <span class="co">/* read from the pipe */</span></a>
<a class="sourceLine" id="cb72-42" title="42">    read(fd[READ_END], read_msg, BUFFER_SIZE); </a>
<a class="sourceLine" id="cb72-43" title="43">    printf(<span class="st">&quot;read %s&quot;</span>,read_msg);</a>
<a class="sourceLine" id="cb72-44" title="44">     <span class="co">/* close the write end of the pipe */</span></a>
<a class="sourceLine" id="cb72-45" title="45">     close(fd[READ_END]);</a>
<a class="sourceLine" id="cb72-46" title="46">  }</a>
<a class="sourceLine" id="cb72-47" title="47">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb72-48" title="48">}</a></code></pre></div>
<p>In some of the runs of this program we sometimes get a random character after the “Greetings” message. What gives? Remember that in C a string is NULL terminated. So a <code>printf</code> routine with a <code>%s</code> qualifier will just keep going until it gets to a 0-byte somewhere. We are supposed to put the null terminator where it belongs, but this may not suffice. When we have a buffer (as we do here), it makes sense to initialize the buffer to 0. So, in this code, we should add a call to <code>memset</code> to initialize the <code>read_msg</code> variable to 0s.</p>
<p>If we wanted to create a named pipe, the system call for that is <code>mkfifo</code> (make first-in-first-out) because sometimes a named pipe is called a FIFO. As it is a file, it can be manipulated with the usual UNIX file system calls: <code>open</code>, <code>read</code>, <code>write</code>, and <code>close</code> <span class="citation" data-cites="osc"></span>.</p>
<h3 id="shared-memory" class="unnumbered">Shared Memory</h3>
<p>Conceptually, the idea of shared memory is very simple. A particular region of memory is designated as being shared between multiple processes, all of whom may read and write to that location. To share an area of memory, the OS must be notified.</p>
<p>Normally, a region of memory is associated with exactly one process (its owner) and that process may read and write that location, but other processes may not. If a second process attempts to do so, the operating system will intervene and that will be an error. If a process wants to designate memory as shared, it needs to tell the operating system it is okay for the other process to have access to that area. Furthermore, the OS needs to know that the memory is referenced by two processes: if the first one terminates and is reaped, the memory may still be in use by the second process, so that previously-shared region should not be considered free as long as the second process is still using it. Once the area of memory is shared, when either process attempts to access it, it is just a normal memory access. The kernel is only involved in the setup and cleanup of that shared area.</p>
<p>This situation is shown in the diagram below.</p>
<p><img src="images/shared-memory.png" alt="image" style="width:20.0%" /><br />
A view of memory when a block is designated as shared <span class="citation" data-cites="osc"></span>.</p>
<p>Note that in the diagram the shared memory area appears in between the memory for processes <span class="math inline">A</span> and <span class="math inline">B</span>; this is not necessarily the case (the shared block could be anywhere). It tends to be in the block for the process that creates the shared memory in the first place. This makes sense, because Process <span class="math inline">A</span> will request the memory from the operating system and then ask the OS to consider a particular block <span class="math inline">A</span> already owns to be shared.</p>
<p>When a section of memory is shared, there exists the possibility that one process will overwrite another’s changes. To prevent this sort of problem, we will need a mechanism for co-ordination... a subject we will return to later.</p>
<p>Suppose we want to share a section of memory. We need to obtain a <em>key</em> that identifies a specific memory segment. Keys are just integer values, so we would like them to be unique (or at least close to it).</p>
<p>One method is to generate the key with the “file to key” function found in <code>sys/ipc.h</code> <span class="citation" data-cites="lpi"></span>:</p>
<div class="sourceCode" id="cb73" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb73-1" title="1">key_t ftok( <span class="dt">char</span> *pathname, <span class="dt">int</span> proj )</a></code></pre></div>
<p>The key is generated from the given file name (<code>pathname</code>) and the value <code>proj</code>. The file does have to exist, because the function uses a given inode. And the integer argument allows generating multiple IPC objects based off the same file. There is a very small risk of duplicate numbers if we are unlucky, but the risk is small enough that we consider it acceptable.</p>
<p>Another way we can get a key is using the constant <code>IPC_PRIVATE</code>. If we give the constant in where a <code>key_t</code> is expected then a guaranteed unique key is returned.</p>
<p>The functions we need are in <code>sys/shm.h</code>. The workflow for using shared memory is as follows (with details obviously after)  <span class="citation" data-cites="lpi"></span>:</p>
<ul>
<li><p>Create a new shared memory segment – <code>shmget</code>.</p></li>
<li><p>Attach the shared memory segment (add the shared segment to the process calling attach) – <code>shmat</code>.</p></li>
<li><p>Then the process can use the shared memory.</p></li>
<li><p>Detach, from the shared memory segment (like deallocation, if forgotten then it will happen automatically when a process ends) – <code>shmdt</code>.</p></li>
<li><p>Delete the shared memory segment (after all currently attached processes have detached), done by one process only – <code>shmctl</code>.</p></li>
</ul>
<p>The functions are:</p>
<div class="sourceCode" id="cb74" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb74-1" title="1"><span class="dt">int</span> shmget( key_t key, <span class="dt">size_t</span> size, <span class="dt">int</span> shmflg );</a>
<a class="sourceLine" id="cb74-2" title="2"><span class="dt">void</span>* shmat( <span class="dt">int</span> shmid, <span class="dt">const</span> <span class="dt">void</span>* shmaddr, <span class="dt">int</span> shmflg );</a>
<a class="sourceLine" id="cb74-3" title="3"><span class="dt">int</span> shmdt( <span class="dt">const</span> <span class="dt">void</span>* shmaddr );</a>
<a class="sourceLine" id="cb74-4" title="4"><span class="dt">int</span> shmctl( <span class="dt">int</span> shmid, <span class="dt">int</span> cmd, <span class="kw">struct</span> shmid_ds *buf )</a></code></pre></div>
<p>To create a shared memory segment, or get a reference to an existing one, we use <code>shmget</code>. The first argument is the key, which can be either the result of a <code>ftok()</code> call or the constant <code>IPC_PRIVATE</code>. The second argument is obviously the number of bytes the shared memory should be. The third argument is the access permissions that follow the UNIX permission standards, e.g. <code>0600</code>.</p>
<p>The flags can also add <code>IPC_CREAT</code> (if no segment with the given key exists, create it) and <code>IPC_EXCL</code> (if “create” was used, fail if a segment with the given key exists). These are be combined with the permissions, and each other, with bitwise OR operator, like opening a file.</p>
<p>The return value of the function is the integer identifier of the shared memory segment. Given this identifier, it’s possible to then attach that segment: add the shared memory to the running process.</p>
<p>When calling <code>shmat</code>, the first argument is the ID of the shared memory returned by <code>shmget</code>. The second parameter is where to put the memory, but in this case you should always use NULL and let the kernel decide where to put it. If you don’t, your program may not work as expected on different machines (or even at different times!) because that memory might be in use. As for flags, we could use <code>SHM_RDONLY</code> which would prevent writing (actually an attempt would result in a segmentation fault) <span class="citation" data-cites="lpi"></span>.</p>
<p>The return value of the call to <code>shmat</code> is a standard C pointer, containing the address of the shared memory. That’s how we know where it is. Now we can read or write (if allowed) the data. At this point we are able to use the shared memory just like any other memory. Nothing special is needed – no read or write calls – just read and assign variables like any other memory.</p>
<p>Of course, a process that wants to attach to the memory has to know the key (or ID) to find it. If we created the segment ourselves, we obviously know where it is. But presumably you want some other process to have it as well. If two processes use the same input values for <code>ftok()</code> they will get the same result, so that’s one method. Or, if a parent attaches a shared memory segment and then calls <code>fork()</code>, the child inherits the shared memory segments, so it’s is already set up.</p>
<p>When we are done with a segment we can detach from it with <code>shmdt</code>, and it takes as an argument the value returned by <code>shmat</code>. It could have been the ID value, in my opinion, but this works as well. If we forget to do this, then it will happen automatically at process termination, but it is good programming practice to deallocate memory when you no longer need it, and similarly to detach from a shared memory segment when we are done.</p>
<p>To delete a shared memory segment, we use <code>shmctl</code>. This function can do a lot more than delete it, such as modify properties of the data structure that is used to control shared memory. But we just need to, at a minimum, delete the segment. To do so, call the function with the shared memory ID, and the command is <code>IPC_RMID</code> (“remove ID”). We must leave the last argument as <code>NULL</code> for this deletion.</p>
<p>Using the <code>shmctl</code> function with the deletion command doesn’t (immediately) the segment. As long as it’s still attached somewhere, the memory can’t be cleaned up. In this respect, it’s like a file in UNIX – if it’s open then it can’t be removed until the last process closes it. In Linux it’s possible to attach to a still-existing segment if it’s been marked for deletion, but this is not consistent behaviour across all UNIX systems and should not be done <span class="citation" data-cites="lpi"></span>.</p>
<p>Consider a minimal (working) example where shared memory is employed to deliver a message from a child process to a parent.</p>
<div class="sourceCode" id="cb75" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb75-1" title="1"><span class="pp">#define _XOPEN_SOURCE</span></a>
<a class="sourceLine" id="cb75-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb75-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb75-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/shm.h&gt;</span></a>
<a class="sourceLine" id="cb75-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb75-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb75-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb75-8" title="8"></a>
<a class="sourceLine" id="cb75-9" title="9"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb75-10" title="10"></a>
<a class="sourceLine" id="cb75-11" title="11">    <span class="dt">int</span> shmid = shmget( IPC_PRIVATE, <span class="dv">32</span>, IPC_CREAT | <span class="bn">0666</span>  );  </a>
<a class="sourceLine" id="cb75-12" title="12"></a>
<a class="sourceLine" id="cb75-13" title="13">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb75-14" title="14">    <span class="cf">if</span> ( pid &gt; <span class="dv">0</span> ) { <span class="co">/* Parent */</span></a>
<a class="sourceLine" id="cb75-15" title="15">        waitpid( pid, NULL, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb75-16" title="16">        <span class="dt">void</span>* mem = shmat( shmid, NULL, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb75-17" title="17">        printf(<span class="st">&quot;The message the parent received from the child is %s.</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">char</span>*) mem );</a>
<a class="sourceLine" id="cb75-18" title="18">        shmdt( mem );</a>
<a class="sourceLine" id="cb75-19" title="19">        shmctl( shmid, IPC_RMID, NULL );</a>
<a class="sourceLine" id="cb75-20" title="20">    } <span class="cf">else</span> <span class="cf">if</span> ( pid == <span class="dv">0</span> ) { <span class="co">/* Child */</span></a>
<a class="sourceLine" id="cb75-21" title="21">        <span class="dt">void</span>* mem = shmat( shmid, NULL, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb75-22" title="22">        memset( mem, <span class="dv">0</span>, <span class="dv">32</span> );</a>
<a class="sourceLine" id="cb75-23" title="23">        sprintf( mem, <span class="st">&quot;Hello World&quot;</span> );</a>
<a class="sourceLine" id="cb75-24" title="24">        shmdt( mem );</a>
<a class="sourceLine" id="cb75-25" title="25">    }   </a>
<a class="sourceLine" id="cb75-26" title="26"></a>
<a class="sourceLine" id="cb75-27" title="27">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb75-28" title="28">}</a></code></pre></div>
<h5 id="alternatively-mmap.">Alternatively: <code>mmap</code>.</h5>
<p>An alternative approach for shared memory involves the use of <code>mmap()</code>, a function nominally used to map a file into memory. This is neat – it would allow us to map some disk file to a buffer, so when we fetch data from that buffer, the data is read and when we write into the buffer the data is written to the file. It allows us to read and write files as if they were memory accesses. Very convenient. But we can also use this for IPC, hence its introduction here. But first, the functions need to be introduced. As in <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb76" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb76-1" title="1"><span class="dt">void</span>* mmap( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> protection, <span class="dt">int</span> flag, <span class="dt">int</span> fd, off_t offset );</a>
<a class="sourceLine" id="cb76-2" title="2"><span class="dt">int</span> mprotect( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> prot );</a>
<a class="sourceLine" id="cb76-3" title="3"><span class="dt">int</span> msync( <span class="dt">void</span>* address, <span class="dt">size_t</span> length, <span class="dt">int</span> flags );</a>
<a class="sourceLine" id="cb76-4" title="4"><span class="dt">int</span> munmap( <span class="dt">void</span>* address, <span class="dt">size_t</span> length );</a></code></pre></div>
<p>The first argument is the address for where you want the mapped region to go in memory; unless you have a very good reason to do otherwise, let the system choose by supplying <code>NULL</code>. The next argument is the number of bytes we want to map. The third argument is the protection rules — read, write execute, and none – that apply (details below). The flag argument indicates the mode that the memory will be mapped in. The second-last argument is the file descriptor of the file we wish to map, and the last argument is the offset from the start of the file where the segment begins.</p>
<p>The return value is a pointer to the starting address of the memory area where the file is mapped.</p>
<p>Okay, so about the protection flags: valid values are <code>PROT_NONE</code>, <code>PROT_READ</code>, <code>PROT_WRITE</code>, and <code>PROT_EXECUTE</code>, which can be combined using the bitwise OR operator (as always). The read, write, and execute ones look as expected, but whatever flags you choose have to be consistent with how the file was opened with <code>open</code>. So you can’t use <code>open</code> as readonly and then somehow use <code>mmap</code> with the write flag. And <code>PROT_NONE</code> forbids all access; any attempt to access that memory results in a segmentation fault.</p>
<p>Digression: why would you ever use <code>PROT_NONE</code>? What’s the point of mapping a segment of the file and then forbidding all access...? A possible use of this is to put “guards” at the start and end of a region of memory. If the process accidentally goes outside the bounds, then a segmentation fault is generated, thus enforcing the ends of the area <span class="citation" data-cites="lpi"></span>.</p>
<p>And lastly, you have two flag options. The first is <code>MAP_PRIVATE</code> – modifications are not visible to other processes mapping the same file and are not written out to the underlying file. The other is <code>MAP_SHARED</code> – modifications are visible to other processes and are written to the underlying file (although perhaps not instantly – there is a function to make sure we all agree).</p>
<p>As you can imagine, the private option is for when we just want to work with a file ourselves and the shared option is for use in an IPC scenario.</p>
<p><img src="images/memory-mapped-file.png" alt="image" style="width:50.0%" /><br />
Conceptual diagram of a memory mapped file <span class="citation" data-cites="apunix"></span>.</p>
<p>If we wish to change the protection rules for a section, we use <code>mprotect</code>, which takes as arguments the address, the size, and the new access rules.</p>
<p>When a piece of the file is loaded in memory in the shared mode, file changes are not necessarily written out to the underlying file immediately. This is (partly) a performance enhancement but can mean that not everybody agrees on the content of the file because a change has not yet been written to disk. For this, the <code>msync</code> function is used: the address and length parameters are self explanatory. For flags we’ll just say use <code>MS_SYNC</code> which makes this a blocking call. There are other more advanced options but we will not discuss that here. Also, this function does nothing if the file is mapped in private.</p>
<p>Finally, when we’re done with a segment, we can unmap it with <code>munmap</code>, which takes the same arguments of the address and length. A segment would be unmapped automatically when a process exits, but as always it is polite to unmap it as soon as you know that you are done with it.</p>
<p>Let’s do a quick example. Suppose I have a file <code>example.txt</code> that contains the text “This is sample text.” We are going to overwrite it with “It is now overwritten” in a child process and the parent will see the updated message.</p>
<div class="sourceCode" id="cb77" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb77-1" title="1"><span class="pp">#define _XOPEN_SOURCE</span></a>
<a class="sourceLine" id="cb77-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb77-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb77-4" title="4"><span class="pp">#include </span><span class="im">&lt;sys/shm.h&gt;</span></a>
<a class="sourceLine" id="cb77-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb77-6" title="6"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb77-7" title="7"><span class="pp">#include </span><span class="im">&lt;sys/wait.h&gt;</span></a>
<a class="sourceLine" id="cb77-8" title="8"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb77-9" title="9"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb77-10" title="10"><span class="pp">#include </span><span class="im">&lt;sys/mman.h&gt;</span></a>
<a class="sourceLine" id="cb77-11" title="11"></a>
<a class="sourceLine" id="cb77-12" title="12"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb77-13" title="13"></a>
<a class="sourceLine" id="cb77-14" title="14">    <span class="dt">int</span> fd = open( <span class="st">&quot;example.txt&quot;</span>, O_RDWR );</a>
<a class="sourceLine" id="cb77-15" title="15">    </a>
<a class="sourceLine" id="cb77-16" title="16">    <span class="kw">struct</span> stat st; </a>
<a class="sourceLine" id="cb77-17" title="17">    stat( <span class="st">&quot;example.txt&quot;</span>, &amp;st );</a>
<a class="sourceLine" id="cb77-18" title="18">    <span class="dt">ssize_t</span> size = st.st_size;</a>
<a class="sourceLine" id="cb77-19" title="19">    <span class="dt">void</span>* mapped = mmap( NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="dv">0</span> );  </a>
<a class="sourceLine" id="cb77-20" title="20">    </a>
<a class="sourceLine" id="cb77-21" title="21">    <span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb77-22" title="22">    <span class="cf">if</span> ( pid &gt; <span class="dv">0</span> ) { <span class="co">/* Parent */</span></a>
<a class="sourceLine" id="cb77-23" title="23">        waitpid( pid, NULL, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb77-24" title="24">        printf(<span class="st">&quot;The new content of the file is: %s.</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dt">char</span>*) mapped);</a>
<a class="sourceLine" id="cb77-25" title="25">        munmap( mapped, size );</a>
<a class="sourceLine" id="cb77-26" title="26">    } <span class="cf">else</span> <span class="cf">if</span> ( pid == <span class="dv">0</span> ) { <span class="co">/* Child */</span></a>
<a class="sourceLine" id="cb77-27" title="27">       memset( mapped, <span class="dv">0</span>, size ); <span class="co">/* Erase what&#39;s there */</span></a>
<a class="sourceLine" id="cb77-28" title="28">       sprintf( mapped, <span class="st">&quot;It is now Overwritten&quot;</span>);</a>
<a class="sourceLine" id="cb77-29" title="29">       <span class="co">/* Ensure data is synchronized */</span></a>
<a class="sourceLine" id="cb77-30" title="30">       msync( mapped, size, MS_SYNC );</a>
<a class="sourceLine" id="cb77-31" title="31">       munmap( mapped, size );</a>
<a class="sourceLine" id="cb77-32" title="32">    }</a>
<a class="sourceLine" id="cb77-33" title="33"></a>
<a class="sourceLine" id="cb77-34" title="34">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb77-35" title="35">}</a></code></pre></div>
<p>The example works acceptably in the sense that we successfully overwrite the data with the new data and the parent process sees the change. But things get weird if we tried to write fewer bytes than the original message was. In general, the mapped area size cannot change. So if we want to write more data than is in the file, we can’t make the content of the file larger (and things look strange when we write fewer). In Linux there is the <code>mremap</code> call but this is not portable (ie does not work on all systems). But this would be great for something like sorting an array, wouldn’t it? The sorted array is the same size as the input and we could share the work...</p>
<h1 id="threads" class="unnumbered">11 — Threads</h1>
<h2 id="threads-1" class="unnumbered">Threads</h2>
<p>Not very long ago we discussed what makes a process. A process has three major components: an executable program, the data created or needed by the program, and the execution context of the program (files opened, resources allocated, et cetera). A process has at least one <em>thread</em>, and can have many.</p>
<p>The term “thread” is a short form of <em>Thread of Execution</em>. A thread of execution is a sequence of executable commands that can be scheduled to run on the CPU. Threads also have some state (where in the sequence of executable commands the program is) and some local variables. Most programs you have written until now probably had only one thread; that is, your program’s code is executed one statement at a time, sequentially in some order.</p>
<p>A multithreaded program is one that uses more than one thread, at least some of the time. When a program is started, it begins with an initial thread (where the <code>main</code> function is) and that main thread can create some additional threads if needed. Note that threads can be created and destroyed within a program dynamically: a thread can be created to handle a specific background task, like writing changes to the database, and will terminate when it is done. Or a created thread might be persistent.</p>
<p>In a process that has multiple threads, each thread has its own <span class="citation" data-cites="osi"></span>:</p>
<ol>
<li><p>Thread execution state (like process state: running, ready, blocked...).</p></li>
<li><p>Saved thread context when not running.</p></li>
<li><p>Execution stack.</p></li>
<li><p>Local variables.</p></li>
<li><p>Access to the memory and resources of the process (shared with all threads in that process).</p></li>
</ol>
<p>Or, to represent this visually:</p>
<p><img src="images/mthread2.png" alt="image" style="width:62.5%" /><br />
A single threaded and a multithreaded process compared side-by-side <span class="citation" data-cites="osc"></span>.</p>
<p>All the threads of a process share the state and resources of the process. If one thread opens a file, other threads in that process can also access that file.</p>
<p>The way programs are written now, there are few if any that are not in some way multithreaded. One common way of dividing up the program into threads is to separate the user interface from a time-consuming action. Consider a file-transfer program. If the user interface and upload function share a thread, once a file upload has started, the user will not be able to use the UI anymore (and Windows will put the dreaded “(Not Responding)” at the end of its dialog title), even to click the button that cancels the upload. For some reason, users hate that.</p>
<p>We have two options for how to alleviate this problem: when an upload is ready to start, we can call <code>fork</code> and create a new process to do the upload, or we can spawn new thread. In either case, the newly created entity will handle the upload of the file. The UI remains responsive, because the UI thread is not waiting for the upload function to complete.</p>
<h3 id="motivation-for-threads" class="unnumbered">Motivation for Threads</h3>
<p>Why choose threads rather than creating a new process? The primary, but not sole, motivation is performance:</p>
<ol>
<li><p>Creating a new thread is much faster than creating a new process. In fact, thread creation is on the order of ten times faster <span class="citation" data-cites="machThreads"></span>.</p></li>
<li><p>Terminating and cleaning up a thread is faster than terminating and cleaning up a process.</p></li>
<li><p>It takes less time to switch between two threads within the same process (because less data needs to be stored/restored). In Solaris, for example, switching between processes is about five times slower than switching between threads <span class="citation" data-cites="osc"></span>.</p></li>
<li><p>Because threads share the same memory space, for two threads to communicate, they do not have to use any of the IPC mechanisms; they can just communicate directly. This is a bigger item than it might seem like, because inter-task communication can be very expensive.</p></li>
<li><p>As in the file transfer program, use of threads allows the program to be responsive even when a part of the program is blocked.</p></li>
</ol>
<p>This last advantage, background work, is one of four common examples of the uses of threads in a general purpose operating system <span class="citation" data-cites="insideOS2"></span>:</p>
<ol>
<li><p><strong>Foreground and Background Work:</strong> as already examined, the ability to run something in the background to keep the program responsive.</p></li>
<li><p><strong>Asynchronous processing</strong>: for example, to protect against power failure or a crash, a word processor may write the document data in main memory to disk periodically. This can be done as a background task so it does not disrupt the user’s workflow. You’ve probably experienced this in Microsoft Word, for example, if a document is “recovered”.</p></li>
<li><p><strong>Speed of Execution:</strong> a multithreaded program can get more done in the same amount of time. Just as the OS can run a different program when the executing program gets blocked (say, on a disk read), if one thread is blocked, another thread may execute. But also, we probably have a computer with many cores, so we can put them all to use.</p></li>
<li><p><strong>Modular Structure:</strong> a program that does several different things may be given structure through threads. Threads have specific “jobs” and they each step in and do their job when it is appropriate for them to do so.</p></li>
</ol>
<p>There are some drawbacks, however: there is no protection between threads in the same process: so one thread can easily mess with the memory being used by another thread. This once again brings us to the subject of co-ordination, which will follow the discussion of threads.</p>
<p>Also, if any thread encounters an error (such as a division by zero or Segmentation Fault), the whole process might be terminated by the operating system. If the program has multiple processes for different parts, then the other processes will not be affected; if the program has multiple threads and they all share the same process, then any thread encountering an error might bring all of them to a halt.</p>
<h3 id="thread-states" class="unnumbered">Thread States</h3>
<p>Each individual thread will have its own state. We said earlier that a process may have seven states, but the model for thread state will be the somewhat simpler five-state model. If a process is swapped out of memory, all its threads will be swapped out; when that process is swapped in to memory, all the threads will be swapped in. Therefore we do not need to consider whether a thread is in memory or swapped; hence the five-state model, reproduced once again below:</p>
<p><img src="images/5-state-model.png" alt="image" style="width:85.0%" /><br />
State diagram for the five-state model.</p>
<p>The transitions work the same way as the state transitions for a process. As with a process, a thread in any state can transition to terminated even though that is not shown on the diagram. When a process is terminated, all its threads are terminated, regardless of what state it is in. The example we started with, the file transfer upload being cancelled, is an example of termination we should consider: thread cancellation.</p>
<h2 id="posix-threads" class="unnumbered">POSIX Threads</h2>
<p>The term <code>pthread</code> refers to the POSIX standard (also known as the IEEE 1003.1c standard) that defines thread behaviour in UNIX and UNIX-like systems (Linux, Mac OS X, Solaris...). This is a specification document that says how threads should behave. This standard lets code for one UNIX-like system (e.g., Solaris) run easily on another (e.g., Linux). The POSIX standard for pthreads defines something like 100 function calls, but we need not examine all of them. Let us focus on a few of the important ones and we can see they have some similarity to what we saw with parent and child processes <span class="citation" data-cites="mos"></span>:</p>
<ul>
<li><p><code>pthread_create</code> – Create a new thread. This works a lot like <code>fork</code>.</p></li>
<li><p><code>pthread_exit</code> – Terminate the calling thread. This is like <code>exit</code> in that it ends execution and returns a value.</p></li>
<li><p><code>pthread_join</code> – Wait for a specific thread to exit. This is like <code>wait</code>: the caller cannot proceed until the thread it is waiting for calls <code>pthread_exit</code>. Note that it is an error to join a thread that has already been joined.</p></li>
<li><p><code>pthread_detach</code> – If we want to make it so that a thread cannot be joined, then we can make it a “detached” thread with this function.</p></li>
<li><p><code>pthread_yield</code> – Release the CPU and let another thread run. As they all belong to the same program, we expect that threads want to co-operate rather then compete for CPU time and threads can make decisions about when it would be ideal to let some other thread run instead.</p></li>
<li><p><code>pthread_attr_init</code> – Create and initialize a thread’s attributes. The attributes contain things like the priority of the thread. (“After you, sir.” “Oh no, after you.”)</p></li>
<li><p><code>pthread_attr_destroy</code> – Remove a thread’s attributes. Free up the memory holding the thread’s attributes. This does not terminate the threads.</p></li>
<li><p><code>pthread_cancel</code> – Signal cancellation to a thread; this can be asynchronous or deferred, depending on the thread’s attributes.</p></li>
<li><p><code>pthread_testcancel</code> – A thread can check to see if it has been cancelled. If that is the case, this function terminates the calling thread.</p></li>
</ul>
<p>This list of functions gives us an overview of the toolkit we have, but we need to elaborate with some examples to fully understand how they work.</p>
<h5 id="creating-a-new-thread.">Creating a New Thread.</h5>
<p>When we want to start a new thread, we have to say what that new thread is supposed to do. The function signature for <code>pthread_create</code> looks like:</p>
<div class="sourceCode" id="cb78" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb78-1" title="1">pthread_create( pthread_t *thread, <span class="dt">const</span> pthread_attr_t * attr, <span class="dt">void</span> *(*start_routine)( <span class="dt">void</span> * ), <span class="dt">void</span> *arg );</a></code></pre></div>
<p>Where: <code>thread</code> is a pointer to a <code>pthread</code> identifier and will be assigned a value when the thread is created. The attributes <code>attr</code> may contain various characteristics (but you may supply <code>NULL</code> if you want the defaults). The third parameter is the function to run, but it requires a little more explanation.The last parameter, <code>arguments</code> is the argument passed to the <code>start_routine</code>. But that second last one is weird.</p>
<p>The <code>start_routine</code> parameter is the name of any function that takes a single untyped pointer and returns an untyped pointer. That is, the function signature has to match those two conditions. The name of the function (and the name of the argument) can be anything you like. See the example below:</p>
<div class="sourceCode" id="cb79" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb79-1" title="1"><span class="dt">void</span>* do_something( <span class="dt">void</span>* start_params )</a></code></pre></div>
<p>After the new thread has been created, the process has two threads in it. The OS makes no guarantee about which thread will be executing after the new one is created; this is a matter of scheduling. It could be either of the threads of the process, both of them at the same time, or a different process entirely.</p>
<p>Our experience with C-like languages suggests it is normal to have a single return value from a function, but usually we can have multiple input parameters. It seems limiting to be able to put in just one. There are two ways to get around this: with an array or with structures. In the case of the array, the argument provided to <code>pthread_create</code> is just a pointer to the array. This is also, incidentally, how you can get multiple return values out of a function in Java or C# (<code>public Object[] foo()</code>), but I don’t recommend it as a good programming practice. The other way to do it is to use the <code>struct</code>, defining a structure for the parameter type and one for the return type.</p>
<p>The function that is to run in the new thread must expect a pointer to the arguments and then it will need to be cast to the appropriate (actual) type:</p>
<div class="sourceCode" id="cb80" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb80-1" title="1"><span class="dt">void</span>* function( <span class="dt">void</span> * void_arg ) {</a>
<a class="sourceLine" id="cb80-2" title="2">  parameters_t *arguments = (parameters_t*) args;</a>
<a class="sourceLine" id="cb80-3" title="3">  <span class="co">/* continue after this */</span></a>
<a class="sourceLine" id="cb80-4" title="4">}</a></code></pre></div>
<p>This does imply that the caller of the <code>pthread_create</code> function has to know what kind of argument is expected in the function being called. That is fairly normal; we do have to know what the arguments mean when we pass them in to any function, but in this case we don’t have the “hints” that the types provide.</p>
<p>What about the thread attributes? They can be used to set whether a thread is detached or joinable, scheduling policy, etc. By default, new threads are usually joinable (that is to say, that some other thread can call <code>pthread_join</code> on them). As noted before, it is a logical error to attempt multiple joins on the same thread. To prevent a thread from ever being joined, it can be created in the detached state (or the method <code>pthread_detach</code> can be called on a joinable thread). Trying to join a detached thread is also a logical error <span class="citation" data-cites="pthreads"></span>. For virtually all scenarios that we will consider in this course the default values will be fine.</p>
<p>Once we do that, the new thread we created is running. It does whatever its code does, so everything proceeds as expected, until of course the thread gets to the end. Usually, it will terminate with <code>pthread_exit</code>. The use of <code>pthread_exit</code> is not the only way that a thread may be terminated. Sometimes we want the thread to persist (hang around), but if we want to get a return value from the thread, then we need it to exit.</p>
<h5 id="returning-values.">Returning Values.</h5>
<p>If a thread has no return values, it can just <code>return NULL;</code> which will have the same effect as <code>pthread_exit</code> and send <code>NULL</code> back to the thread that has joined it. If the function that is called as a task returns normally rather than calling the exit routine, the thread will still be terminated.</p>
<p>Another way a thread might terminate is if the <code>pthread_cancel</code> function is called with it as the target. As before, if the termination is deferred rather than asynchronous, the thread is responsible for cleaning up after itself before it stops.</p>
<p>A thread may also be terminated indirectly: if the entire process is terminated or if <code>main</code> finishes first (without calling <code>pthread_exit</code> itself). Indeed, <code>main</code> can use <code>pthread_exit</code> as the last thing that it does. Without that, <code>main</code> will not wait for other, unjoined threads to finish and they will all get suddenly terminated. If <code>main</code> calls <code>pthread_exit</code> then it will be blocked until the threads it has spawned have finished <span class="citation" data-cites="pthreads"></span>.</p>
<h5 id="collecting-returned-values.">Collecting Returned Values.</h5>
<p>Like the <code>wait</code> system call, the <code>pthread_join</code> is how we get a value out of the spawned thread:</p>
<div class="sourceCode" id="cb81" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb81-1" title="1">pthread_join( pthread_t thread, <span class="dt">void</span>** retval );</a></code></pre></div>
<p>The first parameter specifies the thread that you want to join. The second parameter is... wait... two stars? What we are looking for is a pointer to a void pointer. That is, we are going to supply a pointer that the join function will update to be pointing to the value returned by that function. Typically we supply the address of a pointer. This will be hopefully clearer in the example:</p>
<div class="sourceCode" id="cb82" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb82-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb82-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb82-3" title="3"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb82-4" title="4"></a>
<a class="sourceLine" id="cb82-5" title="5"><span class="dt">void</span> * run( <span class="dt">void</span> * argument ) { </a>
<a class="sourceLine" id="cb82-6" title="6">  <span class="dt">char</span>* a = (<span class="dt">char</span>*) argument;</a>
<a class="sourceLine" id="cb82-7" title="7">  printf(<span class="st">&quot;Provided argument is %s!</span><span class="sc">\n</span><span class="st">&quot;</span>, a); </a>
<a class="sourceLine" id="cb82-8" title="8">  <span class="dt">int</span> * return_val = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> )); </a>
<a class="sourceLine" id="cb82-9" title="9">  *return_val = <span class="dv">99</span>; </a>
<a class="sourceLine" id="cb82-10" title="10">  pthread_exit( return_val );</a>
<a class="sourceLine" id="cb82-11" title="11">}</a>
<a class="sourceLine" id="cb82-12" title="12"></a>
<a class="sourceLine" id="cb82-13" title="13"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb82-14" title="14">  <span class="cf">if</span> (argc != <span class="dv">2</span>) {</a>
<a class="sourceLine" id="cb82-15" title="15">      printf(<span class="st">&quot;Invalid args.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb82-16" title="16">      <span class="cf">return</span> -<span class="dv">1</span>; </a>
<a class="sourceLine" id="cb82-17" title="17">  }</a>
<a class="sourceLine" id="cb82-18" title="18">  pthread_t t;</a>
<a class="sourceLine" id="cb82-19" title="19">  <span class="dt">void</span>* vr; </a>
<a class="sourceLine" id="cb82-20" title="20">  </a>
<a class="sourceLine" id="cb82-21" title="21">  pthread_create( &amp;t, NULL, run, argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb82-22" title="22">  pthread_join( t, &amp;vr );</a>
<a class="sourceLine" id="cb82-23" title="23">  <span class="dt">int</span>* r = (<span class="dt">int</span>*) vr; </a>
<a class="sourceLine" id="cb82-24" title="24">  printf(<span class="st">&quot;The other thread returned %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, *r);</a>
<a class="sourceLine" id="cb82-25" title="25">  free( vr );</a>
<a class="sourceLine" id="cb82-26" title="26">  pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb82-27" title="27">}</a></code></pre></div>
<h1 id="threads-and-concurrency" class="unnumbered">12 — Threads and Concurrency</h1>
<h2 id="more-on-threads" class="unnumbered">More on Threads</h2>
<p>We got a brief introduction to working with threads and learned how to create a new thread, how one exits (returning a value or not) and how to collect a value from it. Let’s take a moment to consider cancellation.</p>
<h5 id="thread-cancellation.">Thread Cancellation.</h5>
<p>Thread cancellation is exactly what it sounds like: a running thread will be terminated before it has finished its work. Once the user presses the cancel button on the file upload, we want to stop the upload task that was in progress. The thread that we are going to cancel is called the <em>target</em> (because we shoot targets, I guess) and there are two ways a thread might get cancelled <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p><strong>Asynchronous Cancellation:</strong> One thread immediately terminates the target.</p></li>
<li><p><strong>Deferred Cancellation:</strong> The target is informed that it is cancelled; the target is responsible for checking regularly if it is terminated, allowing it to clean itself up properly.</p></li>
</ol>
<p>The pthread attributes can be used to set the cancellation type before it is created. A thread can declare its own cancellation type through the use of the function:</p>
<div class="sourceCode" id="cb83" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb83-1" title="1">pthread_setcanceltype( <span class="dt">int</span> type, <span class="dt">int</span> *oldtype )</a></code></pre></div>
<p>The first parameter is the new state we’d like this thread to take on, which would be one of the constants <code>PTHREAD_CANCEL_DEFERRED</code> or <code>PTHREAD_CANCEL_ASYNCHRONOUS</code>. The second parameter will be updated to point to what the previous state was (although we might not care).</p>
<p>In deferred cancellation, a thread is responsible for checking if it has been cancelled, and if so, and stopping its activity and cleaning up (closing open files, etc.) before it terminates. It’s possible, though generally poor programming practice (and very difficult), to never check for cancellation.</p>
<p>Given that a thread can effectively ignore a cancellation if it is the deferred cancellation type, why would we ever choose that over asynchronous cancellation? Suppose the thread we are cancelling has some resources. If the thread is terminated in a disorderly fashion, the operating system may not reclaim all resources from that thread. Thus a resource may appear to be in use even though it is not, denying that resource to other threads and processes that may want to use it <span class="citation" data-cites="osc"></span>.</p>
<p>The pthread command to cancel a thread is <code>pthread_cancel</code> and it takes one parameter (the thread identifier). By default, a pthread is set up for deferred cancellation. In the function that runs as a thread, to check if the thread has been cancelled, the function call is <code>pthread_testcancel</code> which takes no parameters.</p>
<p>Suppose your background task is to upload a bunch of files, consecutively. It is good programming practice to check <code>pthread_testcancel</code> at the start or end of each iteration of the loop, and if cancellation has been signalled, clean up open files and network connections, and then <code>pthread_exit</code>. Thus, if the thread has been told to cancel, it will do as it is told within a fairly short period of time.</p>
<p>It is noteworthy that a large number of functions are <em>cancellation points</em>; that is, the POSIX specification requires there is an implicit check for cancellation when calling one of those functions. There is an even larger number of functions that are “potential cancellation points”, where the specification says that they could be cancellation points (but maybe aren’t). You’ll have to check the spec to see if that is the case for a specific function if there is a scenario where unexpected cancellation is a problem.</p>
<h5 id="nows-not-a-good-time">Now’s not a good time!</h5>
<p>With the presence of cancellation points or asynchronous cancellation, sometimes a thread can be terminated before it has cleaned up some resources. This is undesirable. One way that we can guard against this is to register cleanup handlers for that thread. If, say, our thread allocated some memory, it would be wise to register a cleanup handler that deallocates that memory in case the thread should die unceremoniously. The function signatures are:</p>
<div class="sourceCode" id="cb84" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb84-1" title="1">pthread_cleanup_push( <span class="dt">void</span> (*routine)(<span class="dt">void</span>*), <span class="dt">void</span> *argument ); <span class="co">/* Register cleanup handler, with argument */</span> </a>
<a class="sourceLine" id="cb84-2" title="2">pthread_cleanup_pop( <span class="dt">int</span> execute ); <span class="co">/* Run if execute is non-zero */</span> </a></code></pre></div>
<p>To add a cleanup handler, the push function is used. Its two arguments are the function that is supposed to run, and a pointer to the argument that cleanup function will need.</p>
<p>The push function always needs to be paired with the pop function at the same level in your program (where level is defined by the curly braces). You should think of them as being like the opening curly brace at the start of a statement and the closing curly brace at the end; they have to be correctly matched up. The pop function takes one argument: whether it should run or not. If the thread is cancelled, the cleanup function will run; if it continues to the pop function, then you get to choose whether it runs or not.</p>
<p>Consider the following code:</p>
<div class="sourceCode" id="cb85" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb85-1" title="1"><span class="dt">void</span>* do_work( <span class="dt">void</span>* argument ) {</a>
<a class="sourceLine" id="cb85-2" title="2">  <span class="kw">struct</span> job * j = malloc( <span class="kw">sizeof</span>( <span class="kw">struct</span> job ) );</a>
<a class="sourceLine" id="cb85-3" title="3">  <span class="co">/* Do something useful with this structure */</span></a>
<a class="sourceLine" id="cb85-4" title="4">  <span class="co">/* Actual work to do not shown */</span></a>
<a class="sourceLine" id="cb85-5" title="5">  free( j );</a>
<a class="sourceLine" id="cb85-6" title="6">  pthread_exit( NULL );</a></code></pre></div>
<p>Suppose that the thread is cancelled during the block operating on <code>j</code> and it is set up for asynchronous cancellation. This means that the code will never get to the <code>free()</code> call, which means that the memory allocated at the beginning is leaked! We can remedy this with application of a cleanup handler:</p>
<div class="sourceCode" id="cb86" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb86-1" title="1"><span class="dt">void</span> cleanup( <span class="dt">void</span>* mem ) {</a>
<a class="sourceLine" id="cb86-2" title="2">  free( mem );</a>
<a class="sourceLine" id="cb86-3" title="3">}</a>
<a class="sourceLine" id="cb86-4" title="4"></a>
<a class="sourceLine" id="cb86-5" title="5"><span class="dt">void</span>* do_work( <span class="dt">void</span>* argument ) {</a>
<a class="sourceLine" id="cb86-6" title="6">  <span class="kw">struct</span> job * j = malloc( <span class="kw">sizeof</span>( <span class="kw">struct</span> job ) );</a>
<a class="sourceLine" id="cb86-7" title="7">  pthread_cleanup_push( cleanup, j );</a>
<a class="sourceLine" id="cb86-8" title="8">  <span class="co">/* Do something useful with this structure */</span></a>
<a class="sourceLine" id="cb86-9" title="9">  <span class="co">/* Actual work to do not shown */</span></a>
<a class="sourceLine" id="cb86-10" title="10">  free( j );</a>
<a class="sourceLine" id="cb86-11" title="11">  pthread_cleanup_pop( <span class="dv">0</span> ); <span class="co">/* Don&#39;t run */</span></a>
<a class="sourceLine" id="cb86-12" title="12">  pthread_exit( NULL );</a></code></pre></div>
<p>And you may note that you could actually save a line of code by removing the <code>free()</code> call and changing the argument to the pop function to be 1: this means the cleanup function runs and it does free the memory allocated. Nice!</p>
<h5 id="attributes-and-using-memory-to-pass-data.">Attributes and Using Memory to Pass Data.</h5>
<p>The earlier example used the return value of a thread. Sometimes, of course, we don’t want to do that. One of the advantages of the use of threads is that data can be passed between threads using memory directly. In this case, because there is no return value that we care about, we can use <code>NULL</code> in the call to join. This example also shows how to initialize and the attributes, although it doesn’t override any of the defaults.</p>
<div class="sourceCode" id="cb87" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb87-1" title="1"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb87-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb87-3" title="3"></a>
<a class="sourceLine" id="cb87-4" title="4"><span class="dt">int</span> sum; <span class="co">/* Shared Data */</span></a>
<a class="sourceLine" id="cb87-5" title="5"></a>
<a class="sourceLine" id="cb87-6" title="6"><span class="dt">void</span> *runner(<span class="dt">void</span> *param);</a>
<a class="sourceLine" id="cb87-7" title="7"></a>
<a class="sourceLine" id="cb87-8" title="8"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span> **argv ) {</a>
<a class="sourceLine" id="cb87-9" title="9"></a>
<a class="sourceLine" id="cb87-10" title="10">  pthread_t tid; <span class="co">/* the thread identifier */</span></a>
<a class="sourceLine" id="cb87-11" title="11">  pthread_attr_t attr; <span class="co">/* set of thread attributes */</span></a>
<a class="sourceLine" id="cb87-12" title="12"></a>
<a class="sourceLine" id="cb87-13" title="13">  <span class="cf">if</span> ( argc != <span class="dv">2</span> ) {</a>
<a class="sourceLine" id="cb87-14" title="14">    fprintf(stderr,<span class="st">&quot;usage: %s &lt;integer value&gt;</span><span class="sc">\n</span><span class="st">&quot;</span>, argv[<span class="dv">0</span>]); </a>
<a class="sourceLine" id="cb87-15" title="15">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb87-16" title="16">  }</a>
<a class="sourceLine" id="cb87-17" title="17">  <span class="cf">if</span> ( atoi( argv[<span class="dv">1</span>] ) &lt; <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb87-18" title="18">    fprintf(stderr, <span class="st">&quot;%d must be &gt;= 0</span><span class="sc">\n</span><span class="st">&quot;</span>, atoi(argv[<span class="dv">1</span>])); </a>
<a class="sourceLine" id="cb87-19" title="19">    <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb87-20" title="20">  }</a>
<a class="sourceLine" id="cb87-21" title="21"></a>
<a class="sourceLine" id="cb87-22" title="22">  <span class="co">/* set the default attributes */</span></a>
<a class="sourceLine" id="cb87-23" title="23">  pthread_attr_init( &amp;attr );</a>
<a class="sourceLine" id="cb87-24" title="24">  <span class="co">/* create the thread */</span></a>
<a class="sourceLine" id="cb87-25" title="25">  pthread_create( &amp;tid, &amp;attr, runner, argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb87-26" title="26">  pthread_join( tid, NULL ); </a>
<a class="sourceLine" id="cb87-27" title="27">  printf( <span class="st">&quot;sum = %d</span><span class="sc">\n</span><span class="st">&quot;</span>, sum );</a>
<a class="sourceLine" id="cb87-28" title="28">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb87-29" title="29">}</a>
<a class="sourceLine" id="cb87-30" title="30"></a>
<a class="sourceLine" id="cb87-31" title="31"><span class="dt">void</span> *runner( <span class="dt">void</span> *param ) {</a>
<a class="sourceLine" id="cb87-32" title="32">  <span class="dt">int</span> upper = atoi( param );</a>
<a class="sourceLine" id="cb87-33" title="33">  sum = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb87-34" title="34">  <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= upper; i++ ) {</a>
<a class="sourceLine" id="cb87-35" title="35">    sum += i;</a>
<a class="sourceLine" id="cb87-36" title="36">  }</a>
<a class="sourceLine" id="cb87-37" title="37">  pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb87-38" title="38">}</a></code></pre></div>
<p>In this example, both threads are sharing the global variable <code>sum</code>. We have some form of co-ordination here because the parent thread will join the newly-spawned thread (i.e., wait until it is finished) before it tries to print out the value. If it did not join the spawned thread, the parent thread would print out the sum early.</p>
<h5 id="count-to-10...">Count to 10...</h5>
<p>Let’s do a different take on that program:</p>
<div class="sourceCode" id="cb88" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb88-1" title="1"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb88-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb88-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb88-4" title="4"></a>
<a class="sourceLine" id="cb88-5" title="5"><span class="dt">int</span> sum = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb88-6" title="6"></a>
<a class="sourceLine" id="cb88-7" title="7"><span class="dt">void</span>* runner( <span class="dt">void</span> *param ) {</a>
<a class="sourceLine" id="cb88-8" title="8">    <span class="dt">int</span> upper = atoi( param );</a>
<a class="sourceLine" id="cb88-9" title="9">    <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= upper; i++ ) {</a>
<a class="sourceLine" id="cb88-10" title="10">        sum += i;</a>
<a class="sourceLine" id="cb88-11" title="11">    }</a>
<a class="sourceLine" id="cb88-12" title="12">    pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb88-13" title="13">}</a>
<a class="sourceLine" id="cb88-14" title="14"></a>
<a class="sourceLine" id="cb88-15" title="15"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb88-16" title="16"></a>
<a class="sourceLine" id="cb88-17" title="17">    pthread_t tid[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb88-18" title="18"></a>
<a class="sourceLine" id="cb88-19" title="19">    <span class="cf">if</span> ( argc != <span class="dv">2</span> ) {</a>
<a class="sourceLine" id="cb88-20" title="20">        printf(<span class="st">&quot;An integer value is required as an argument.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb88-21" title="21">        <span class="cf">return</span> -<span class="dv">1</span>; </a>
<a class="sourceLine" id="cb88-22" title="22">    }   </a>
<a class="sourceLine" id="cb88-23" title="23">    <span class="cf">if</span> ( atoi( argv[<span class="dv">1</span>]) &lt; <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb88-24" title="24">        printf( <span class="st">&quot;%d must be &gt;= 0.</span><span class="sc">\n</span><span class="st">&quot;</span>, atoi(argv[<span class="dv">1</span>]) );</a>
<a class="sourceLine" id="cb88-25" title="25">    }   </a>
<a class="sourceLine" id="cb88-26" title="26"></a>
<a class="sourceLine" id="cb88-27" title="27">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">3</span>; ++i ) { </a>
<a class="sourceLine" id="cb88-28" title="28">        pthread_create( &amp;tid[i], NULL, runner, argv[<span class="dv">1</span>] );</a>
<a class="sourceLine" id="cb88-29" title="29">    }   </a>
<a class="sourceLine" id="cb88-30" title="30">    <span class="cf">for</span> ( <span class="dt">int</span> j = <span class="dv">0</span>; j &lt; <span class="dv">3</span>; ++j ) { </a>
<a class="sourceLine" id="cb88-31" title="31">        pthread_join( tid[j], NULL );</a>
<a class="sourceLine" id="cb88-32" title="32">    }   </a>
<a class="sourceLine" id="cb88-33" title="33">    printf( <span class="st">&quot;sum = %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, sum );</a>
<a class="sourceLine" id="cb88-34" title="34">    </a>
<a class="sourceLine" id="cb88-35" title="35">    pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb88-36" title="36">}</a></code></pre></div>
<p>What’s going wrong here? For very small values of the argument, nothing, but for a large number we get some strange and inconsistent results. Why? There are three threads that are modifying <code>sum</code>. And, it turns out, that this is a problem – if threads are trying to write to the same place at the same time, things can go wrong. But what does “at the same time” mean in the context of a program? To understand that, we need to think about how the hardware behaves and how the OS schedules the work.</p>
<h2 id="concurrency-1" class="unnumbered">Concurrency</h2>
<p>Not that long ago, a typical computer had one processor with one core. It could accordingly do exactly one thing at a time. When we say there is one processor, it’s one general purpose processor that executes user processes. There may be additional special-purpose processors in the system (e.g., a RAID controller<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>) but there is only one general purpose processor so we call it a uniprocessor system.</p>
<p>Now, desktops, laptops, and even cell phones are almost certainly using multi-core processors. A quad-core processor may be executing four different instructions from four different threads at the same time. In theory, multiple processors may mean that we can get more work done in the same amount of (wall clock) time, but this is not a guarantee.</p>
<p>Terminology note: we often refer to a logical processing unit as a <em>core</em>. The term CPU may refer to a physical chip that contains one or more logical processing units. As far as the operating system is concerned, it does not much matter if a system has four cores in four physical chips or four cores in one chip; either way, there are four units that can execute instructions.</p>
<p>If there is exactly one process with one thread running in the system, then it does not matter how many cores are available: at most one core will be used to execute this task. If there are multiple processes, each process can execute on a different core. But what do we do if there are more processes and threads than available cores? We can hope that the processes get blocked frequently enough and long enough so that all processes get to run, but this is not something we can count on.</p>
<p>Our solution is that the CPU should switch between the different tasks via a procedure we call <em>time slicing</em>. So thread 1 would execute for a designated period, such as 20 ms, then thread 2 for 20 ms, then thread 3 for 20 ms, then back to thread 1 for 20 ms. To the user, it seems like threads 1, 2, and 3 are being executed in parallel, because 20 ms is fast enough that the user does not notice the difference.</p>
<p><img src="images/single-core-execution.png" alt="image" style="width:85.0%" /><br />
Execution of different Threads <span class="math inline">T_{1}</span> through <span class="math inline">T_{4}</span> on a single core <span class="citation" data-cites="osc"></span>.</p>
<p>Time slicing of execution will still occur, if necessary. Continuing our example, if there are four threads running on a dual-core system, time slicing is necessary to run all those programs.</p>
<p><img src="images/dual-core-execution.png" alt="image" style="width:70.0%" /><br />
Execution of different Threads <span class="math inline">T_{1}</span> through <span class="math inline">T_{4}</span> on two cores <span class="citation" data-cites="osc"></span>.</p>
<h3 id="parallelism-and-speedup" class="unnumbered">Parallelism and Speedup</h3>
<p>No doubt it has occurred to you that if there are multiple threads running at the same time, it means a task will get completed faster, right? Well... maybe. It depends a lot on what the task is. There is some overhead involved in splitting a task up and re-combining the results (if necessary), but in most circumstances the overhead is negligible compared to the amount of time working on the task.</p>
<p>If a task can be fully parallelized, it means the task can be split up in such a way that adding a second executing thread would double the speed of execution. Imagine painting an apartment. It would take one person 12 hours to paint the whole apartment and two people could complete the job in 6 hours. The pattern continues: three people can complete the job in 4 hours, four people in 3 hours, et cetera. This is the ideal, but in the real world there will be a limit to how many additional workers you can add and continue to have this speedup characteristic. At some point, the overhead of adding more threads is no longer negligible. In theory, you could hire 720 painters and finish the job in 1 minute, but at some point you cannot physically fit any more painters into the room.</p>
<p>If a task can be partially parallelized, it means the task can be divided, but doubling the workers doesn’t result in completing the job in half the time. Two chefs working together in a kitchen might take 75% of the time it would take one chef to cook a meal. Adding the extra worker to the kitchen improved the speed at which food was prepared, but it’s not doubled. The chefs can work independently some of the time, but at other times one has to wait for the other; the sauce cannot be put on the chicken until the chicken comes out of the oven.</p>
<p>If a task cannot be parallelized at all, then no amount of extra workers will speed it up. Some tasks can only be done sequentially. You can’t cook the steak in one minute by putting it in five ovens (this makes the chef very mad).</p>
<p>Let us consider an example from <span class="citation" data-cites="mte241"></span>: Suppose we have a task that can be executed in 5 s and this task contains a loop that can be parallelized. Let us also say initialization and recombination code in this routine requires 400 ms. So with one processor executing, it would take about 4.6 s to execute the loop. If we split it up and execute on two processors it will take about 2.3 s to execute the loop. Add to that the setup and cleanup time of 0.4 s and we get a total time of 2.7 s. Completing the task in 2.7 s rather than 5 s represents a speedup of about 46%.</p>
<p>A smart fellow by the name of Gene Amdahl came up with a formula for the general case of how much faster a task can be completed based on how many processors we have available. Let us define <span class="math inline">S</span> as the portion of the application that must be performed serially and <span class="math inline">N</span> as the number of processing cores available. Amdahl’s Law:</p>
<p>speedup <span class="math inline">\leq</span> <span><span class="math inline">\frac{1}{S + \frac{1-S}{N}}</span></span></p>
<p>This is a math formula, after all, and you can do things like take the limit as <span class="math inline">N</span> approaches infinity and you will find the speedup converges to <span class="math inline">\frac{1}{S}</span>. So the limiting factor on how much additional processors help is, of course, the size of the <span class="math inline">S</span> term in the equation. That squares well with our intuition about how this should work. If the task is completely sequential (cannot be parallelized at all), we cannot make it faster and <span class="math inline">\frac{1}{1 + 0}</span> will produce a maximum speedup of 1; or in other words... no speedup at all.</p>
<p>Applying this formula to the example from earlier, we get the following run times:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Processors</strong></th>
<th style="text-align: left;"><strong>Run Time (s)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">2.7</td>
</tr>
<tr class="odd">
<td style="text-align: left;">4</td>
<td style="text-align: left;">1.55</td>
</tr>
<tr class="even">
<td style="text-align: left;">8</td>
<td style="text-align: left;">0.975</td>
</tr>
<tr class="odd">
<td style="text-align: left;">16</td>
<td style="text-align: left;">0.6875</td>
</tr>
<tr class="even">
<td style="text-align: left;">32</td>
<td style="text-align: left;">0.54375</td>
</tr>
<tr class="odd">
<td style="text-align: left;">64</td>
<td style="text-align: left;">0.471875</td>
</tr>
<tr class="even">
<td style="text-align: left;">128</td>
<td style="text-align: left;">0.4359375</td>
</tr>
</tbody>
</table>
<p>There are two observations from this data immediately. The first is that we get diminishing returns as we add more processors. Going from 1 to 2 processors reduced the runtime dramatically, but going from 64 to 128 reduced the run time only a very small amount. The second is that as we continue to add more processors we are converging on a run time of 0.4 s, which fits our expectations of what would happen with infinite processors. The serial part will take 0.4 s no matter what, and with infinite processors the parallel part would be (effectively) instant. Again, applying the formula, the most we could speed up this code is by a factor of <span class="math inline">\frac{5}{0.4}\approx 12.5</span>. It is not possible to do better than this. In reality we will never be able to equal the limit either, because nobody has infinite processors available, considering that would take an infinite amount of space and an infinite amount of money...</p>
<h5 id="merge-sort-example.">Merge Sort Example.</h5>
<p>Recall from data structures and algorithms the concept of merge sort. This is a divide-and-conquer algorithm like binary search. Split the array of values up into smaller pieces, sort those, and then merge the smaller pieces together to have sorted data. To get this done, we might have many threads sorting and one thread merging the sorted lists together into a larger, sorted list. Visually, this looks like:</p>
<p><img src="images/multithread-sort.png" alt="image" style="width:45.0%" /><br />
Multithreaded sorting <span class="citation" data-cites="osc"></span>.</p>
<h1 id="concurrency-synchronization-and-atomicity" class="unnumbered">13 — Concurrency: Synchronization and Atomicity</h1>
<h2 id="synchronization" class="unnumbered">Synchronization</h2>
<p>If a computer only ever did exactly one thing at a time (one process, one thread) we would have no concurrency and therefore no concurrency (co-ordination) problems. We have seen already, however, that in a system with multiple processes or multiple threads we have concurrency: more than one thread or process is making progress. And if the system is multicore, we can have parallelism: more than one thread or process actually executing on a CPU in a given instant. Either or both of these can lead to various problems.</p>
<p>The author of an application does not decide when a thread runs and when a thread switch will occur; these are things the operating system will decide. And the operating system does not usually give much thought to whether it is a convenient or inconvenient time to run a given thread.</p>
<p>The common English usage of the word “synchronization” refers to making two or more things happen at exactly the same time, but what we mean when we talk about synchronization in the computer sense is more general: it means we want some relationship between events, and the relationship can be before, during, after <span class="citation" data-cites="lbs"></span>. There are two definitions that we need to consider at this point.</p>
<p>The first is <em>serialization</em>: we want there to be some sort of order of events. What we would like is to be certain that Event <span class="math inline">A</span> takes place before Event <span class="math inline">B</span>. We have already examined some examples of this, where we have a thread or process that <code>wait</code>s on another. The merge sort algorithm, if implemented with two threads that sort the sublists and one thread that merges the results, necessarily implies that the merge thread has to wait for the sorting threads to finish. Thus the sorting (event <span class="math inline">A</span>) must take place before the merging (event <span class="math inline">B</span>). Or we could phrase it that <span class="math inline">B</span> must happen after <span class="math inline">A</span>.</p>
<p>The other thing we often want is <em>mutual exclusion</em>: events <span class="math inline">C</span> and <span class="math inline">D</span> must not happen at the same time. This is something we’ve referenced a few times before now, often phrased as the fact that we need some sort of co-ordination. In the discussion of inter-process communication, we said we might have an area of memory that is shared between two processes. If two processes can write to this area, there is some possibility that they both try to access the same place at the same time. If we have mutual exclusion, we are certain that <span class="math inline">P_{1}</span> writing to the shared area (event <span class="math inline">C</span>) does not happen at the same time as <span class="math inline">P_{2}</span> tries to read it (event <span class="math inline">D</span>).</p>
<h3 id="serialization-through-messages" class="unnumbered">Serialization through Messages</h3>
<p>Suppose we have two people, Alice and Bob (these are the standard names in computer examples...) who work at the Springfield Nuclear Power Plant in Sector 7G, though they work in separate offices and cannot easily see one another. Alice works the day shift and Bob works the night shift. Suppose also that due to safety regulations, that Alice cannot go home until Bob has arrived and begun working. This is a situation where we would like serialization: the event of Bob’s arrival must take place before the event of Alice’s departure.</p>
<p>How can we get such behaviour? Well, the simple solution is that Alice stays at her desk and will not leave until she gets a call from Bob. Bob doesn’t call until he’s arrived at the office. This is a very simple scenario, but message passing is a valid solution for a lot of synchronization problems and it’s the sort of thing we do in real life all the time: “Text me when you get here” or “Call me when you’ve finished”.</p>
<p>If we are certain that Bob arrives before Alice departs, we can say that these events are <em>sequential</em>, because we know the order of events. At some point during the workday, Alice ate lunch, and at some point before work, Bob ate lunch. But we have no idea who ate lunch first, so we say they ate lunch <em>concurrently</em>. The formal, strict definition of concurrent is: two events are concurrent if we cannot tell by looking at the program which will happen first <span class="citation" data-cites="lbs"></span>.</p>
<p>In common parlance, when we say something happened concurrently, it means they happened at the same time (Alice and Bob both had lunch at 12:00). In this context, concurrency is not the same as saying that they happened at the exact same time; it’s saying that we do not know (and cannot guarantee) an order of events. It’s possible that Alice had lunch at 12:00 and Bob had lunch at 13:00 or they both ate at 12:00 or Alice had lunch at 13:30 and Bob had lunch at 12:15. We do not know. The order of concurrent events may change on two runs of the program; this is what we call nondeterminism.</p>
<p>In a non-deterministic program, we cannot tell just by looking at the program what the execution order would be. If we have two concurrent events, one in which the program prints “1” to the console and one in which the program prints “2” to the console, these could happen in any order. So we might see the output as “12” or “21”. Which one will happen? Without some form of co-ordination, it could be either. This non-determinism makes it difficult to analyze a program. If “12” is the correct output but “21” occurs only very rarely, finding the cause and fixing it might be very painful <span class="citation" data-cites="lbs"></span>.</p>
<p>This is, incidentally, what is referred to as a “Heisenbug” (a portmanteau of Heisenberg and Bug). This has nothing to do with the “Breaking Bad” TV show, but with Werner Heisenberg (the physicist) and his scientific principle of uncertainty that says: if we precisely know the position of a particle we know nothing about its momentum and vice versa. The Heisenbug is frustrating because the harder we try to track it down, the less likely it is to occur.</p>
<h3 id="shared-data-and-atomic-operations" class="unnumbered">Shared Data and Atomic Operations</h3>
<p>We noted earlier that the need for co-ordination in inter-process communication arises from the fact that some area of memory is shared. We also know that all the threads of a process share the same data: in the merge sort algorithm the sorting and merging routines both operate on the same data array. Let’s examine a simpler example (from <span class="citation" data-cites="lbs"></span>) where a shared variable <code>x</code> is manipulated by two threads <span class="math inline">A</span> and <span class="math inline">B</span>, in pseudocode:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    A1. x = 5
    A2. print x</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    B1. x = 7
    </code></pre>
<p>This is non-deterministic code: there is no co-ordination mechanism here so we cannot say what order these statements will occur. Some possible outcomes are: 5 is printed out and is the final value; 7 is printed out and is the final value, or 5 is printed out and 7 is the final value. Note that there is no way we can print out 7 and get a final value of 5, because we can be certain that statement A1 executes before A2; the problem is we do not know where in relation to the two A-statements that statement B1 will execute.</p>
<p>This example uses more than one thread, but we do not even need multiple threads to have a concurrency problem; just having interrupts in the system is sufficient.</p>
<p>Consider an application that is used to count occurrences of some event (whatever it is). We will store the count in a variable <code>count</code> and we will provide some facility for the user to reset the counter (the reset button). Each time we detect the event, we increment <code>count</code> with statement of <code>count++;</code> which seems like one single statement.</p>
<p>Even a seemingly simple operation like <code>count++;</code> is broken down into a series of smaller operations. You’ve just detected an event. Let’s assume the current value of the variable is 4. Thus we want to increment the variable, which will require three steps.</p>
<ol>
<li><p>Read the current value of <code>count</code> (read 4)</p></li>
<li><p>Add 1 to the value (now it’s 5)</p></li>
<li><p>Write the changed value back to memory (write 5)</p></li>
</ol>
<p>Now imagine an interrupt comes at the worst possible time. The interrupt is generated by the reset button: it’s supposed to set the value of count to zero.</p>
<ol>
<li><p>Read the current value of <code>count</code> (read 4)</p></li>
<li><p>Add 1 to the value (now it’s 5)</p></li>
<li><p>INTERRUPT (control goes to the interrupt handler)</p></li>
<li><p>Write 0 to the variable (write 0)</p></li>
<li><p>END INTERRUPT (control returns to where it was before the interrupt)</p></li>
<li><p>Write the changed value back to memory (write 5)</p></li>
</ol>
<p>At the end of this execution sequence, the variable <code>count</code> shows 5, but it should show 0 (or 1), which is certainly wrong. The user pressed the reset button but the count did not reset! If the reset interrupt had occurred before reading the variable, the count would have been reset, and then an event detected and the count goes up to 1. If the interrupt had occurred after writing the value 5 to the variable we would see the count set to 0 as is expected. If it occurred after the read but before the write, there is an error and the changes the interrupt handler made were lost.</p>
<p>This problem arises because the instruction <code>count++</code> is really three things (read, add, write) and can be interrupted at any time. When we are performing an operation that cannot be interrupted, we say it is <em>atomic</em>: indivisible. Although since about 1945, we have been able to split the atom (proving that atoms themselves are divisible and that humans are very good at finding ways to make things explode) the use of the word atomic in this context is not about nuclear physics but references the other meaning that stems from Greek word <em>atomos</em>, meaning indivisible (or more literally, not-cuttable).</p>
<p>Though there are usually some atomic operations available to us in a given system, we cannot be certain that all operations are indivisible. In fact, the opposite is likely to be true: we can be certain there are some operations that are non-atomic. Therefore we need to make sure at the very least that one operation on the shared variable is finished before the next begins.</p>
<p>A thought: can we do this with serialization? That is, can we make sure that the <code>count++</code> operation completes before the <code>count = 0</code> operation? That would eliminate the problem of the reset being ignored. Unlike the scenario where Alice waits for Bob to get to work before she leaves, in this case there is no obvious order between the events: the user may press the reset button at any time, even if no event has just occurred. Similarly, the event may be detected even if the user is nowhere around and not going to press the reset button. Our concept of serialization requires that there exists a correct order: first this, then that. Here, where both orders are valid, we need the other approach: mutual exclusion (also called <em>mutex</em>).</p>
<p>With mutual exclusion, we do not know or enforce any particular order of events, but what we do care about is that we do not have multiple threads trying to update the variable at the same time. It would mean that the action to reset <code>count</code> to zero would have to wait until the <code>count++</code> operation was completely finished (or vice versa) before it gets to execute.</p>
<h3 id="mutual-exclusion-through-flags" class="unnumbered">Mutual Exclusion through Flags</h3>
<p>So we have identified shared data as a potential source of error. A section of code that should be accessed by a maximum of one thread at a time is referred to as a <em>critical section</em>. The purpose of mutual exclusion is to ensure that at most one thread is in the critical section at a time. If we ever have more than one thread in the critical section at a time, something has gone terribly wrong. But on the other hand, the critical section is supposed to do something useful, so we cannot solve the problem by not allowing any thread to access it ever.</p>
<p>It is the responsibility of the programmer to identify what critical sections, if any, exist in the program, and to protect them with mutexes. Some analysis tools may exist to identify shared data, but ultimately the best analysis tool is taking a careful look. Critical sections should be as short as possible (but enclose all shared data accesses). The critical section is something that cannot be run in parallel, so it increases the magnitude of the <span class="math inline">S</span> term in Amdahl’s Law, limiting the speed increase we can get from multiple threads and cores. Besides, it would be impolite to make other threads and processes wait unnecessarily.</p>
<p>Our first approach then, is to have a variable to indicate if the critical section is currently in use. Suppose we have two threads:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    A1. while ( turn != 0 ) {
    A2.    /* Wait for my turn */
    A3. }
    A4. /* critical section */
    A5. turn = 1;</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    B1. while ( turn != 1 ) {
    B2.   /* Wait for my turn */
    B3. }
    B4. /* critical section */
    B5. turn = 0;</code></pre>
<p>This scheme enforces strict alternation: first it is the turn of thread <span class="math inline">A</span>, then the turn of thread <span class="math inline">B</span>, then back to <span class="math inline">A</span>, and so on. What if thread <span class="math inline">A</span> is to run more often than <span class="math inline">B</span>? If thread <span class="math inline">B</span> terminates then thread <span class="math inline">A</span> will be stuck forever because the variable <code>turn</code> will always be saying that it is thread <span class="math inline">B</span>’s turn. This solution is obviously not satisfactory. Another approach then:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    A1. while ( busy == true ) {
    A2.    /* Wait for my turn */
    A3. }
    A4. busy = true;
    A5. /* critical section */
    A6. busy = false;</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    B1. while ( busy == true ) {
    B2.    /* Wait for my turn */
    B3. }
    B4. busy = true;
    B5. /* critical section */
    B6. busy = false;</code></pre>
<p>The problem with flags is that when we have a statement like <code>while (busy == true)</code> followed by <code>busy = true;</code> these are two distinct steps: read of <code>busy</code> and write of <code>busy</code> and a process switch could occur between the read and the write, which is the worst possible timing (as far as we are concerned). If the switch happens at the bad time then threads <span class="math inline">A</span> and <span class="math inline">B</span> will both be in the critical section at the same time. This solution is also not satisfactory.</p>
<p>What if instead of using one flag variable, we use an array where each thread writes to its own boolean variable?</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    A1. flag[0] = true;
    A2. while ( flag[1] ) {
    A3.    /* Wait for my turn */
    A4. }
    A5. /* critical section */
    A6. flag[0] = false;</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    B1. flag[1] = true;
    B2. while ( flag[0] ) {
    B3.    /* Wait for my turn */
    B4. }
    B5. /* critical section */
    B6. flag[1] = false;</code></pre>
<p>Once again, this strategy is defeated by an untimely process switch: if statement A1 sets <code>flag[0]</code> to true and there is a switch to thread <span class="math inline">B</span>, setting <code>flag[1]</code> to true, now both processes are stuck. Neither can advance, because each is waiting for the other to set its <code>flag</code> variable to false. This is, perhaps, slightly better than two threads in the critical section, but we have two threads that are permanently stuck now. This is also not satisfactory: although we want to forbid two threads from being in the critical section at the same time, keeping all threads out forever is not a good solution either.</p>
<p>The attempts at solution we have attempted so far have all been foiled by an untimely process switch, which will be triggered by an interrupt. This presents a possible solution: disabling interrupts. If interrupts are disabled, then interrupts generated from the user as well as the normal thread switches the scheduler would perform will not occur. Disabling interrupts is a crude solution, however, because during the time in which interrupts are disabled, the system will be unable to respond to user input or other events (e.g., a fire alarm or detection of an incoming missile!). If an error is encountered in the critical section and the program is terminated, the system is effectively stuck because no other program will be able to run.</p>
<p>It gets worse: if we have multiple processors the disabling interrupts will not be sufficient <span class="citation" data-cites="osi"></span>. But maybe we’re on the right track by getting hardware involved: the problem is we would like to read and maybe write a variable in such a way that cannot be interrupted. The hardware designers were aware of the problem and have kindly provided a facility to help us out: the <em>Test-and-Set</em> instruction.</p>
<h3 id="test-and-set" class="unnumbered">Test-and-Set</h3>
<p>The Test-and-Set instruction is a special machine instruction that is performed in a single instruction cycle and is therefore not interruptible. It is therefore an atomic read and write. The idea is that the Test-and-Set instruction returns a boolean value. When run, it will examine the flag variable (in this example, <code>i</code>) and if it is zero, it will set it to 1 and return true. If <code>i</code> is currently set to 1, it will return false. The meaning of the return value is clear: if it is true, it is the current thread’s turn to enter the critical section. The Test-and-Set instruction is not actually implemented like this, but a description of its functionality in C is:</p>
<div class="sourceCode" id="cb97" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb97-1" title="1">boolean test_and_set( <span class="dt">int</span>* i ) {</a>
<a class="sourceLine" id="cb97-2" title="2">  <span class="cf">if</span> ( *i == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb97-3" title="3">    *i = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb97-4" title="4">    <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb97-5" title="5">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb97-6" title="6">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb97-7" title="7">  }</a>
<a class="sourceLine" id="cb97-8" title="8">}</a></code></pre></div>
<p>Now, to make use of the <code>test_and_set</code> routine. Let us assume we have an integer variable called <code>busy</code> that is initialized at program startup to 0. The implementation is the same for both threads so there is no need to show them side by side.</p>
<div class="sourceCode" id="cb98" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb98-1" title="1"><span class="cf">while</span> ( !test_and_set( busy ) ) {</a>
<a class="sourceLine" id="cb98-2" title="2">   <span class="co">/* Wait for my turn */</span></a>
<a class="sourceLine" id="cb98-3" title="3">}</a>
<a class="sourceLine" id="cb98-4" title="4"><span class="co">/* critical section */</span></a>
<a class="sourceLine" id="cb98-5" title="5">busy = <span class="dv">0</span>;</a></code></pre></div>
<p>Finally, we have something that will provide mutual exclusion without the risk that the threads will all get stuck because each thinks another is in the critical section. This is good, but can be improved. The <code>while</code> loop that is constantly checking the value with the Test-and-Set instruction is an example of <em>busy-waiting</em>. A given thread is constantly checking and checking and checking the instruction, and this is a waste of time and effort. Thread <span class="math inline">A</span> will not get into the critical section while thread <span class="math inline">B</span> is in there and asking constantly does not make <span class="math inline">B</span> get the job done any faster, just as a child asking “are we there yet?” does not improve the speed at which he or she gets to his or her destination.</p>
<p>It is less wasteful of resources and effort if the <code>while</code> loop contains some instructions saying it should wait a little while before checking again (a sleep instruction). Serialization was achievable through messages; and they can be used to get mutual exclusion. This is the topic to be examined next.</p>
<h1 id="semaphores" class="unnumbered">14 — Semaphores</h1>
<h2 id="mutual-exclusion-through-messages" class="unnumbered">Mutual Exclusion through Messages</h2>
<p>The earlier definition of mutual exclusion said only that one thread may be in the critical section at a time. This is the minimum, but there are additional desirable properties that will be used to evaluate any solution <span class="citation" data-cites="osi"></span>:</p>
<ol>
<li><p>Mutual exclusion must apply (this criterion eliminated most of the flag examples earlier).</p></li>
<li><p>A thread that halts outside the critical section must not interfere with other threads (the strict alternation routine, even if implemented with Test-and-Set, would fail on this criterion).</p></li>
<li><p>It must not be possible for a thread requiring access to a critical section to be delayed indefinitely (the situation where all threads get stuck, each thinking another is in the critical section, would fail this criterion).</p></li>
<li><p>When no thread is in the critical section, a thread that requests access should be allowed to enter right away (no unnecessary waiting).</p></li>
<li><p>No assumptions are made about what the threads will do or the number of processors in the system (so it should be a general solution, not a special case).</p></li>
<li><p>A thread remains inside the critical section for a finite time only (this is more of an assumption than a criterion, but our solution must provide a way to indicate the thread has left the critical section).</p></li>
</ol>
<p>Recall from earlier the example of the employees Alice and Bob who worked at the Springfield Nuclear Power Plant in Sector 7G. Suppose there is a third employee at the power plant, Charlie, who works on the day shift at the same time as Alice. Safety rules say that at least one of them has to monitor the safety of the reactor at all times and therefore they cannot both take lunch at the same time. If we cannot predict when lunch begins or how long it will last, how can Alice and Charlie co-ordinate to make sure they don’t take lunch at the same time?</p>
<p>A possible solution: before Alice gets up from her desk to go for lunch, she calls Charlie. If he does answer, she may proceed. If Charlie does not answer, Alice will know he is not at his desk and she cannot leave at the moment. She can call again, constantly, until she reaches Charlie (busy-waiting), but this ties up a phone line nonstop and is effort intensive for Alice. If she doesn’t want to do that, at this point she has two options: one is to simply wait some period of time (perhaps 15 minutes) and call again in the hopes that at that time Charlie will be back from lunch. A better approach would be for Alice to leave a message in Charlie’s voice mail box, asking him to call her back when he has finished lunch. Then Alice can go about her work until she gets a call from Charlie and as soon as that happens, she may step out for lunch.</p>
<p>Busy waiting has already been found inadequate as a solution. It wastes CPU time that another process or thread could be putting to productive use. The approach of “wait 15 minutes and try again” might be adequate for Alice as a human, but for the computer it is not ideal. If thread <span class="math inline">B</span> is in the critical section when <span class="math inline">A</span> tries to get in, and <span class="math inline">A</span> then sleeps for 2000 ms before trying again, this at least means <span class="math inline">A</span> is not wasting CPU cycles while it tries futilely to ask “is it my turn now? Now? Now? Now? Now? Now?”, but if <span class="math inline">B</span> is finished after 20 ms, then thread <span class="math inline">A</span> waits unnecessarily for 1980 ms.</p>
<p>What we want is something that resembles the call-when-finished semantics of Alice leaving a message and Charlie calling her back. That solution is called the Semaphore.</p>
<h2 id="semaphore" class="unnumbered">Semaphore</h2>
<p>A semaphore, outside of the context of computing, is a system of signals used for communication. Before ships had radios, when two friendly ships were in visual range, they would communicate with one another through flag semaphores, which is a fancy way of saying each ship had someone holding certain flags in a specific position. Thus the two ships could co-ordinate at a distance, even if the distance was limited to visual range. This worked dramatically better than many alternatives (e.g., shouting).</p>
<p>The computer semaphore was invented in 1965 by Edsger Dijkstra, a brilliant Dutch computer scientist who is sometimes maligned in textbooks as being eccentric or unusual. He described a data structure that can be used to solve synchronization problems via messages in <span class="citation" data-cites="semaphores"></span>. Although the version we use now is not exactly the same as the original description, even 50+ years later, the core idea is unchanged.</p>
<p>We will begin with the <em>binary semaphore</em>: this is a variable that has two values, 0 and 1. It can be initialized to 0 or to 1. The semaphore has two operations: <code>wait</code> and <code>post</code>. In the original paper, <code>wait</code> was called <code>P</code> and <code>signal</code> was called <code>V</code>, but the names in common usage have become a little more descriptive. Mind you, if you can read/write Dutch as I can, the names make some sense: <code>P</code> is short for <em>proberen</em>, “to test”, and <code>V</code> is short for <em>verhogen</em>, “to raise” or “to increment”. But, for historical reasons as much as any other, the traditional lingua franca of computers is English, so the English names have tended to dominate. Furthermore, <code>post</code> is also called <code>signal</code> in many textbooks.</p>
<p>The <code>wait</code> operation on the semaphore is how a program tries to enter the critical section. When <code>wait</code> is called, if the semaphore value is 1, set it to 0 and this thread may enter the critical section and continue. If the semaphore is 0, some other thread is in the critical section and the current thread must <em>wait</em> its turn. The thread that called <code>wait</code> will be blocked by the operating system, just as if it asked for memory or a disk operation. This is sometimes referred to as decrementing the semaphore (because the value changes from 1 to 0).</p>
<p>The <code>post</code> operation is how a program sends the message that it is finished with the critical section. When this is called, if the semaphore is 1, do nothing; if the semaphore is 0 and there is a task blocked awaiting that semaphore, that task may be unblocked; else set the semaphore to 1. This is also sometimes called incrementing the semaphore.</p>
<p>If this is still confusing, consider the following analogy. Suppose you like coffee, and going to a particular coffee shop because there you can get your drink exactly the way you like it: half caf, no whip, extra hot, extra foam, two shot, soy milk latte<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. After this delightful beverage it may be the case that you need to use the washroom. The washroom is locked at such places, so to get in you will need the key, which is available by asking one of the employees. If nobody is currently in the washroom, you will get the key and can proceed. If it is currently occupied, you will have to wait. When the key is returned, if anyone is waiting, the employee will give the key to the first person in line for the washroom; otherwise he or she will put the key away behind the counter.</p>
<p>Observe that the operating system is needed to make this work: if thread <span class="math inline">A</span> attempts to wait on a semaphore that some other thread already has, it will be blocked and the operating system knows not to schedule it to run until it is unblocked. When thread <span class="math inline">B</span> is finished and posts to the semaphore it is holding, that will unblock <span class="math inline">A</span> and allow it to run again.</p>
<p>Note also that the semaphore does not provide any facility to “check” the current value. Thus a thread does not know in advance if it will block when it waits on the semaphore. It can only wait and may be blocked or may proceed directly into the critical section if there is no other thread in there at the moment.</p>
<p>When a thread signals a semaphore, it likewise does not know if any other thread(s) are waiting on that semaphore. There is no facility to check this, either. When thread <span class="math inline">A</span> signals a semaphore, if another thread <span class="math inline">B</span> is waiting, <span class="math inline">B</span> will be unblocked and either thread <span class="math inline">A</span> or thread <span class="math inline">B</span> may continue execution (or both, if it is a SMP system), or another unrelated thread may be the one to continue execution. We have no way of knowing.</p>
<p>On the subject of observation, note that nothing about the semaphore as so defined protects against certain “bad” behaviour. Suppose thread <span class="math inline">C</span> would like to enter the critical section. The programmer of this task is malicious as well as impatient: “my task is FAR too important to wait for those other processes and threads,” he says, as he implements his code such that before he waits on the semaphore, he posts to it. Even though <span class="math inline">A</span> or <span class="math inline">B</span> might be in the critical section, the semaphore gets incremented so he is more or less certain that his program will now get to enter the critical section. It’s not foolproof: if there are other threads waiting, they might get woken up to proceed instead of <span class="math inline">C</span>; much depends on the scheduler. Nevertheless, this is really bad: one process can wreak all kinds of havoc by letting another process into the critical section. Though the example here makes the author of thread <span class="math inline">C</span> a scheming villain (because the example is funnier that way), such a situation may occur without malicious intent if it is simply the result of a programming error.</p>
<p>The problem identified in the previous paragraph is usually solved by supplementing the basic binary semaphore. A data structure called a <em>mutex</em> (from <strong>mut</strong>ual <strong>ex</strong>clusion) is a binary semaphore with an additional rule enforced: only the thread that has called <code>wait</code> may <code>post</code> to that semaphore. This adds a small amount of extra bookkeeping to the semaphore, but this is a reasonable price to pay.</p>
<h3 id="example-linked-list-integrity" class="unnumbered">Example: Linked List Integrity</h3>
<p>We will now examine a situation where a semaphore helps to prevent a synchronization error. This example comes from <span class="citation" data-cites="mte241"></span>. Imagine we have a shared linked list defined as:</p>
<div class="sourceCode" id="cb99" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb99-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> single_node {</a>
<a class="sourceLine" id="cb99-2" title="2">  <span class="dt">void</span> *element;</a>
<a class="sourceLine" id="cb99-3" title="3">  <span class="kw">struct</span> single_node *next;</a>
<a class="sourceLine" id="cb99-4" title="4">} single_node_t;</a>
<a class="sourceLine" id="cb99-5" title="5"></a>
<a class="sourceLine" id="cb99-6" title="6"><span class="kw">typedef</span> <span class="kw">struct</span> single_list {</a>
<a class="sourceLine" id="cb99-7" title="7">  single_node_t *head;</a>
<a class="sourceLine" id="cb99-8" title="8">  single_node_t *tail;</a>
<a class="sourceLine" id="cb99-9" title="9">  <span class="dt">int</span> size;</a>
<a class="sourceLine" id="cb99-10" title="10">} single_list_t;</a>
<a class="sourceLine" id="cb99-11" title="11"></a>
<a class="sourceLine" id="cb99-12" title="12"></a>
<a class="sourceLine" id="cb99-13" title="13"><span class="dt">void</span> single_list_init( single_list_t *list ) {</a>
<a class="sourceLine" id="cb99-14" title="14">  list-&gt;head = NULL;</a>
<a class="sourceLine" id="cb99-15" title="15">  list-&gt;tail = NULL;</a>
<a class="sourceLine" id="cb99-16" title="16">  list-&gt;size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb99-17" title="17">}</a>
<a class="sourceLine" id="cb99-18" title="18"></a>
<a class="sourceLine" id="cb99-19" title="19"><span class="dt">bool</span> push_front( single_list_t *list, <span class="dt">void</span> *obj ) {</a>
<a class="sourceLine" id="cb99-20" title="20">  single_node_t *tmp = malloc( <span class="kw">sizeof</span>( single_node_t ) );</a>
<a class="sourceLine" id="cb99-21" title="21">  </a>
<a class="sourceLine" id="cb99-22" title="22">  <span class="cf">if</span> ( tmp == NULL ) {</a>
<a class="sourceLine" id="cb99-23" title="23">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb99-24" title="24">  }</a>
<a class="sourceLine" id="cb99-25" title="25">  </a>
<a class="sourceLine" id="cb99-26" title="26">  tmp-&gt;element = obj;</a>
<a class="sourceLine" id="cb99-27" title="27">  tmp-&gt;next = list-&gt;head;</a>
<a class="sourceLine" id="cb99-28" title="28">  list-&gt;head = tmp;</a>
<a class="sourceLine" id="cb99-29" title="29"></a>
<a class="sourceLine" id="cb99-30" title="30">  <span class="cf">if</span> ( list-&gt;size == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb99-31" title="31">     list-&gt;tail = tmp;</a>
<a class="sourceLine" id="cb99-32" title="32">  }</a>
<a class="sourceLine" id="cb99-33" title="33">  </a>
<a class="sourceLine" id="cb99-34" title="34">   ++( list-&gt;size );</a>
<a class="sourceLine" id="cb99-35" title="35">   <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb99-36" title="36">}</a></code></pre></div>
<p>If only one thread can access this data structure, we do not have a problem, but it was a shared linked list. Suppose a thread runs and tries to add an element <span class="math inline">A</span> to the list using the <code>push_front</code> function. Right before the increment of the <code>size</code> field takes place there is a process switch. At this point, the new node has been allocated and initialized, the pointers of <code>head</code> and <code>tail</code> have been updated, but <code>size</code> is 0.</p>
<p><img src="images/linkedlist1.png" alt="image" style="width:25.0%" /><br />
The linked list at the time of the thread switch <span class="citation" data-cites="mte241"></span>.</p>
<p>Now, the second thread executes and wants to add <span class="math inline">B</span> to the linked list. In the conditional statement, <code>list-&gt;size == 0</code> evaluates to true. Thus, the <code>tail</code> pointer is updated.</p>
<p><img src="images/linkedlist2.png" alt="image" style="width:35.0%" /><br />
The linked list after the second thread adds <span class="math inline">B</span> <span class="citation" data-cites="mte241"></span>.</p>
<p>When the first thread gets to run again, it will resume where it left off: it increments the <code>size</code> integer, leaving the final state: <code>head</code> and <code>tail</code> both point to element <span class="math inline">B</span>, even though there is element <span class="math inline">A</span> in the list.</p>
<p><img src="images/linkedlist3.png" alt="image" style="width:35.0%" /><br />
The linked list after the first thread resumes <span class="citation" data-cites="mte241"></span>.</p>
<p>This is an <em>inconsistent state</em>: the linked list has two elements in it but the <code>tail</code> pointer is wrong. An attempt to remove an element from the list will reveal the problem, which can manifest in a few ways, depending on how the removal routine is implemented. If we try to remove the front element we might check that <code>head</code> and <code>tail</code> are equal, and that may give the mistaken impression that <span class="math inline">B</span> is the last element in the list, so we “lose” <span class="math inline">A</span> and it becomes a memory leak. Or perhaps the <code>head</code> pointer will be updated but <code>tail</code> will still point to <span class="math inline">B</span> even after it has been freed, which can result in a segmentation fault or invalid access.</p>
<h3 id="semaphore-syntax" class="unnumbered">Semaphore Syntax</h3>
<p>Binary semaphores are useful, and we can generalize this concept to what is known as a <em>counting</em> or <em>general</em> semaphore. Instead of having only the values 0 and 1, the setup routine for the counting semaphore allows the choice of an integer value and this is the maximum value. A thread that waits on that semaphore will decrement the integer by 1; a thread that signals on the semaphore will increment the integer by 1. If a thread attempts to wait on a semaphore and the decrement operation makes the integer value negative, the calling thread is blocked. If, however, the semaphore is, for example, initialized with 5 and the current value is 2, a thread that waits on that general semaphore will not be blocked.</p>
<p>In UNIX, the semaphores are always general. So, the functions are:</p>
<div class="sourceCode" id="cb100" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb100-1" title="1">sem_init( sem_t* semaphore, <span class="dt">int</span> shared, <span class="dt">int</span> initial_value);</a>
<a class="sourceLine" id="cb100-2" title="2">sem_destroy( sem_t* semaphore )</a>
<a class="sourceLine" id="cb100-3" title="3">sem_wait( sem_t* semaphore )</a>
<a class="sourceLine" id="cb100-4" title="4">sem_post( sem_t* semaphore )</a></code></pre></div>
<p>Of these functions, the only one where the parameters are not obvious is the initialization routine. The parameter <code>shared</code> will be set to either 0 or 1: 1 if the semaphore is to be shared between processes (e.g., using shared memory), 0 otherwise. I’ll also take a moment also to point out the importance of getting the initial value correct. If we choose the wrong initial value then our program might get stuck or we might not get the mutual exclusion behaviour we are supposed to have.</p>
<h3 id="applying-the-semaphore-to-the-linked-list" class="unnumbered">Applying the Semaphore to the Linked List</h3>
<p>Now that we have the appropriate syntax we can apply it to the linked list example from this section. We will add to the linked list structure (<code>struct single_list</code>) a semaphore: <code>sem_t sem;</code>. In the initialization routine, we need to call the initialization method: <code>sem_init( &amp;( list-&gt;sem ), 0, 1 );</code></p>
<p>Finally, the <code>semaphore_wait</code> and <code>semaphore_signal</code> operations need to be added to <code>push_front</code> at the start and end of the critical section, respectively. Recall from earlier that we want the critical section to be as small as it can be. Putting it all together:</p>
<div class="sourceCode" id="cb101" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb101-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> single_node {</a>
<a class="sourceLine" id="cb101-2" title="2">  <span class="dt">void</span> *element;</a>
<a class="sourceLine" id="cb101-3" title="3">  <span class="kw">struct</span> single_node *next;</a>
<a class="sourceLine" id="cb101-4" title="4">} single_node_t;</a>
<a class="sourceLine" id="cb101-5" title="5"></a>
<a class="sourceLine" id="cb101-6" title="6"><span class="kw">typedef</span> <span class="kw">struct</span> single_list {</a>
<a class="sourceLine" id="cb101-7" title="7">  single_node_t *head;</a>
<a class="sourceLine" id="cb101-8" title="8">  single_node_t *tail;</a>
<a class="sourceLine" id="cb101-9" title="9">  <span class="dt">int</span> size;</a>
<a class="sourceLine" id="cb101-10" title="10">  sem_t sem;</a>
<a class="sourceLine" id="cb101-11" title="11">} single_list_t;</a>
<a class="sourceLine" id="cb101-12" title="12"></a>
<a class="sourceLine" id="cb101-13" title="13"><span class="dt">void</span> single_list_init( single_list_t *list ) {</a>
<a class="sourceLine" id="cb101-14" title="14">  list-&gt;head = NULL;</a>
<a class="sourceLine" id="cb101-15" title="15">  list-&gt;tail = NULL;</a>
<a class="sourceLine" id="cb101-16" title="16">  list-&gt;size = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb101-17" title="17"></a>
<a class="sourceLine" id="cb101-18" title="18">  sem_init( &amp;( list-&gt;sem ), <span class="dv">0</span>, <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb101-19" title="19">}</a>
<a class="sourceLine" id="cb101-20" title="20"></a>
<a class="sourceLine" id="cb101-21" title="21"><span class="dt">bool</span> push_front( single_list_t *list, <span class="dt">void</span> *obj ) {</a>
<a class="sourceLine" id="cb101-22" title="22">  single_node_t *tmp = malloc( <span class="kw">sizeof</span>( single_node_t ) );</a>
<a class="sourceLine" id="cb101-23" title="23">  </a>
<a class="sourceLine" id="cb101-24" title="24">  <span class="cf">if</span> ( tmp == NULL ) {</a>
<a class="sourceLine" id="cb101-25" title="25">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb101-26" title="26">  }</a>
<a class="sourceLine" id="cb101-27" title="27">  </a>
<a class="sourceLine" id="cb101-28" title="28">  tmp-&gt;element = obj;</a>
<a class="sourceLine" id="cb101-29" title="29">  </a>
<a class="sourceLine" id="cb101-30" title="30">  sem_wait( &amp;( list-&gt;sem ) ); {</a>
<a class="sourceLine" id="cb101-31" title="31">    tmp-&gt;next = list-&gt;head;</a>
<a class="sourceLine" id="cb101-32" title="32">    list-&gt;head = tmp;</a>
<a class="sourceLine" id="cb101-33" title="33"></a>
<a class="sourceLine" id="cb101-34" title="34">    <span class="cf">if</span> ( list-&gt;size == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb101-35" title="35">       list-&gt;tail = tmp;</a>
<a class="sourceLine" id="cb101-36" title="36">    }</a>
<a class="sourceLine" id="cb101-37" title="37">    ++( list-&gt;size );</a>
<a class="sourceLine" id="cb101-38" title="38">  </a>
<a class="sourceLine" id="cb101-39" title="39">  } sem_post( &amp;( list-&gt;sem ) );  </a>
<a class="sourceLine" id="cb101-40" title="40">  </a>
<a class="sourceLine" id="cb101-41" title="41">  <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb101-42" title="42">}</a></code></pre></div>
<p>Strictly speaking, the braces ({ }) to enclose the critical region (between the wait and signal operations) are not necessary. This is just a use of C syntax to make it more obvious what the critical region is and to make it harder to make a mistake.</p>
<p>The critical section here just encloses the modification of the shared linked list. In theory one might put the wait and signal operations at the start and end of the entire function, respectively. This is, however, suboptimal: it forces unnecessary waiting. In this specific example, including the call to <code>malloc</code> is especially bad; the memory allocation itself can block if insufficient memory is available. Thus the process currently in the critical section is blocked and that means no other thread can enter the critical section. This might result in the system getting totally stuck <span class="citation" data-cites="mte241"></span>.</p>
<h1 id="synchronization-patterns" class="unnumbered">15 — Synchronization Patterns</h1>
<h2 id="synchronization-patterns-1" class="unnumbered">Synchronization Patterns</h2>
<p>There are a number of common synchronization patterns that occur frequently and we can use semaphores to solve them. These synchronization patterns are ways of co-ordinating two threads or processes. We have already examined serialization and mutual exclusion, but there are many more. Throughout this section we will use pseudocode and something like “Statement A1” could be any valid statement in the program; what exactly it does is not important as the semaphore is a general solution. The examples in this section come from <span class="citation" data-cites="lbs"></span>.</p>
<h3 id="signalling" class="unnumbered">Signalling</h3>
<p>Recall from earlier the example with Alice and Bob at the power plant. This was signalling: Bob sends a signal to Alice to indicate that he has arrived to work and Alice may go home. Signalling can be used in general as a way of indicating that something has happened. Suppose we have a semaphore named <code>sem</code>, initialized to 0.</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. Statement A1
    2. post( sem )</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. wait( sem )
    2. Statement B2</code></pre>
<p>If <span class="math inline">B</span> gets to the <code>wait</code> statement first, it will be blocked (as the semaphore is 0) and cannot proceed until someone posts on that semaphore. When <span class="math inline">A</span> does call <code>post</code>, then <span class="math inline">B</span> may proceed. If instead <span class="math inline">A</span> gets to the <code>post</code> statement first, it will post and the semaphore value will be 1. Then, when <span class="math inline">B</span> gets to the <code>wait</code> statement, it can proceed without delay. Regardless of the actual order that the threads run, we are certain that statement A1 will execute before statement B2.</p>
<p>Note that this is a situation where it makes sense for a thread to post a semaphore even if it is not the thread that waited on that semaphore. Thus, sometimes, the semaphore is appropriate and the mutex structure is not necessary in every circumstance.</p>
<h3 id="rendezvous" class="unnumbered">Rendezvous</h3>
<p>The rendezvous is an expansion of the post pattern so that it works both ways: two threads should be at the same point before either of them may proceed (they “meet up”). Given the following code:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. Statement A1
    2. Statement A2</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. Statement B1
    2. Statement B2</code></pre>
<p>The desirable property is that A1 should take place before B2 and that B1 should take place before A2. As each thread must wait for the other, two semaphores will be needed: one to indicate that <span class="math inline">A</span> has arrived and one for <span class="math inline">B</span>. We will assign them the names <code>aArrived</code> and <code>bArrived</code> and initialize both to 0. A first attempt at a solution:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. Statement A1
    2. wait( bArrived )
    3. post( aArrived )
    4. Statement A2</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. Statement B1
    2. wait( aArrived )
    3. post( bArrived )
    4. Statement B2</code></pre>
<p>The problem here should be obvious: thread <span class="math inline">A</span> gets to the <code>wait</code> statement and will wait until <span class="math inline">B</span> posts its arrival before it can proceed. Thread <span class="math inline">B</span> gets to its <code>wait</code> statement and will wait until <span class="math inline">A</span> posts its arrival before it will proceed. Unfortunately, each thread is waiting for the other to post and neither of them can get to the actual <code>post</code> statement because they are both blocked.</p>
<p>Neither thread can proceed. The situation can never be resolved, because there is no external force (e.g., a hardware interrupt that means the data has been read from a device) that would cause one or the other to be unblocked. This is a situation called <em>deadlock</em>, and it is a subject that will receive a great deal of examination later on. For now, an informal definition is: all threads are permanently stuck. Obviously, this is undesirable.</p>
<p>What if instead, the threads reverse the order and post first before waiting?</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. Statement A1
    2. post( aArrived )
    3. wait( bArrived )
    4. Statement A2</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. Statement B1
    2. post( bArrived )
    3. wait( aArrived )
    4. Statement B2</code></pre>
<p>This solution works: if <span class="math inline">A</span> gets to the rendezvous point first, it posts its arrival and waits for <span class="math inline">B</span>. If <span class="math inline">B</span> gets there first, it posts its arrival and waits for <span class="math inline">A</span>. Whichever gets there last will post and unblock the other, before it calls <code>wait</code> and will be able to proceed directly because the first thread to arrive already posted.</p>
<p>A variation on this can also work where only one thread posts first and the other thread posts second. This is shown below:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. Statement A1
    2. wait( bArrived )
    3. post( aArrived )
    4. Statement A2</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. Statement B1
    2. post( bArrived )
    3. wait( aArrived )
    4. Statement B2</code></pre>
<p>While this solution will not result in deadlock, it is somewhat less efficient than the previous: it may require an extra switch between processes. If <span class="math inline">A</span> arrives at the <code>wait</code> statement, it waits; then <span class="math inline">B</span> posts and must then wait for <span class="math inline">A</span>’s post (it cannot proceed right away even though it got there second). After <span class="math inline">A</span> gets to run again it may proceed to post and unblock <span class="math inline">B</span>. For the most part, we are usually satisfied as long as we are certain that deadlock will not occur that a given solution is acceptable. Nevertheless, the previous solution is provably better and is what programmers want to implement.</p>
<h3 id="mutual-exclusion" class="unnumbered">Mutual Exclusion</h3>
<p>We saw previously the motivation and concept of mutual exclusion through messages in the linked list example. The general form in pseudocode is of course:</p>
<p><span>2</span>
<strong>Thread A</strong></p>
<pre><code>    1. wait( mutex )
    2. critical section
    3. post( mutex )</code></pre>
<p><strong>Thread B</strong></p>
<pre><code>    1. wait( mutex )
    2. critical section
    3. post( mutex )</code></pre>
<p>The mutex semaphore is originally initialized to 1 (unlike the previous examples where it started at 0), so whichever thread gets to the <code>wait</code> statement first will proceed immediately and not be blocked at all. If the semaphore were initialized to 0 then neither thread could ever get to the <code>post</code> statement or ever get into the critical section (deadlock).</p>
<p>Note that both threads <span class="math inline">A</span> and <span class="math inline">B</span> are identical here, which was not always the case in previous examples. This is a <em>symmetric</em> solution. It is easier to make predictions about the behaviour of the threads when they all do the same thing. If the different threads have different sections of code, they are <em>asymmetric</em>. The symmetric solutions very often scale well: we could have arbitrarily many threads executing in that same pattern, as long as they all wait on the semaphore before entering the critical section, we can be sure mutual exclusion is enforced.</p>
<h3 id="multiplex" class="unnumbered">Multiplex</h3>
<p>In addition to the binary semaphore, we also discussed the general semaphore. If the general semaphore is initialized to <span class="math inline">n</span>, then at most <span class="math inline">n</span> threads can be in the critical section at a time. This pattern is more common than it might appear at first glance. Restaurants have a certain number of tables and seats. If more people wish to dine than there are seats available, those customers must wait until some seats become available (other customers leave). Restaurants generally want to pack in as many seats as possible, but fire safety regulations set a maximum occupancy for a given space.</p>
<p>In a computer related example, suppose that the system has a problem that when too many concurrent database requests are happening. The queries become slow and eventually time out. A potential solution is to protect all database accesses with a binary semaphore, so only one database query can run at any time. Analysis may reveal that this is too restrictive a policy; perhaps we can execute 5 queries concurrently without any slowdown. Then initialize the semaphore with a value of 5, allowing at most 5 threads into the critical section at any time.</p>
<p>Now, to represent this in pseudocode. This is a symmetric solution, so it will work for arbitrarily many threads (and showing <span class="math inline">A</span> and <span class="math inline">B</span> side by side is not necessary).</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>    1. wait( mutex )
    2. critical section
    3. post( mutex )</code></pre>
<p>This looks exactly like the solution for mutual exclusion, as it should. The only difference is how many threads can enter the critical section at a time (1 vs. many).</p>
<h3 id="barrier" class="unnumbered">Barrier</h3>
<p>The barrier pattern is a generalization of the rendezvous pattern; a way of having more than two threads meet up at the same point before any can proceed. Given <span class="math inline">n</span> threads, each of which knows that the total number of threads is <span class="math inline">n</span>, when the first <span class="math inline">n-1</span> threads arrive, they should wait until the <span class="math inline">n</span>th arrives. As a solution we might consider a variable to keep track of the number of threads that have reached the appropriate point. Because this variable is shared data, modification of it should be in a critical section. Thus we will have a semaphore, initialized to 1, called <code>mutex</code> to protect that counter. Then we will have a second semaphore, <code>barrier</code> that will be the place where threads wait until the <span class="math inline">n</span>th thread arrives.</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>    1. wait( mutex )
    2. count++
    3. post( mutex )
    4. if count == n
    5.     post( barrier )
    6. end if
    7. wait( barrier )</code></pre>
<p>When the <span class="math inline">n</span>th thread arrives, it unlocks the barrier (posts it) and then may proceed. Unfortunately, this is not a solution, because it will lead to some threads being permanently stuck. If there is more than one thread waiting at the barrier, the first thread will be unblocked when the <span class="math inline">n</span>th thread posts on it. However, after that, there are no other <code>post</code> statements and therefore the other threads waiting are stuck forever, waiting for a post that will never come.</p>
<p>Perhaps the idea occurred to you that the <span class="math inline">n</span>th thread to arrive should post <span class="math inline">n-1</span> times:</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>    1. wait( mutex )
    2. count++
    3. post( mutex )
    4. if count == n
    5.     for i from 1 to  n
    6.         post( barrier )
    7.     end for
    8. end if
    9. wait( barrier )</code></pre>
<p>This is a solution that allows all of the <span class="math inline">n</span> threads to proceed (none get stuck), but it is less than ideal. The thread that runs last is very likely the lowest priority thread (if it were high priority it would likely have run first) and therefore when it posts on the semaphore, the thread that has just been unblocked will be the next to run. Then the system switches back, at some later time, to the thread currently unblocking all the others. Thus, in the worst case, there are <span class="math inline">2n</span> process switches, when it could be accomplished with just <span class="math inline">n</span> <span class="citation" data-cites="mte241"></span>. Have each thread unblock the next:</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>    1. wait( mutex )
    2. count++
    3. post( mutex )
    4. if count == n
    5.     post( barrier )
    6. end if
    7. wait( barrier )
    8. post( barrier )</code></pre>
<p>This pattern of a wait followed immediately by a post is a common pattern called a <em>turnstile</em>. The analogy should be familiar to anyone who has travelled by subway (e.g., in Toronto or NYC): a turnstile allows one person at a time to go through. A turnstile pattern allows one thread at a time to proceed through, but can be locked to bar all threads from proceeding. Initially the turnstile in the above example is locked, and the <span class="math inline">n</span>th thread unlocks it and permits all <span class="math inline">n</span> threads to go through.</p>
<p>Alert readers may have noticed something that causes some minor distress: on line 4 in this solution (and the previous, suboptimal one), we are reading the value of <code>count</code>, a shared variable, without the protection of a semaphore. Is this dangerous? Yes, but the alternative is, in this specific instance, worse. Consider this instead:</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>    1. wait( mutex )
    2. count++
    3. if count == n
    4.     post( barrier )
    5. end if
    6. wait( barrier )
    7. post( barrier )
    8. post( mutex )</code></pre>
<p>The problem here is deadlock once again. The first thread waits on <code>mutex</code> and then goes to wait on the <code>barrier</code> semaphore. At this point, the first thread is blocked. When a second thread comes along, it will wait on <code>mutex</code> but can get no further because the first thread has not posted on it. The counter will be 1, but cannot get past 1. The condition of <code>count</code> equalling <span class="math inline">n</span> can never be true. Thus, all the threads are stuck. This is a common source of deadlock: blocking on a semaphore while inside a critical region.</p>
<h3 id="the-reusable-barrier" class="unnumbered">The Reusable Barrier</h3>
<p>The barrier solution we have is good (as long as we can live with the read of the <code>count</code> variable outside of a mutual exclusion protection), but the way it is implemented now, <code>count</code> can increase but never decrease. Once the barrier is open, it can never be closed again. Programs very often do the same thing repeatedly, so a one-time use barrier is not ideal; it would be better to have a reusable barrier. One way to deal with this is to decrement <code>count</code> after the rendezvous has taken place. The line labelled “critical point” is the section of code that must wait until all the threads have rendezvoused<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>     1. wait( mutex )
     2. count++
     3. post( mutex )
     4. if count == n
     5.     post( turnstile )
     6. end if
     7. wait( turnstile )
     8. post( turnstile )
     9. [critical point]
    10. wait( mutex )
    11. count--
    12. post( mutex )
    13. if count == 0
    14.     wait( turnstile )
    15. end if</code></pre>
<p>There are two problems with the above implementation. Suppose thread <span class="math inline">n-1</span> is about to execute line 4 (the comparison of <code>count</code>) and then there is a process switch and the <span class="math inline">n</span>th thread comes to this point. Both of them will find that <code>count</code> is equal to <span class="math inline">n</span> and therefore both threads will post the turnstile. The same problem occurs on line 13: more than one thread may wait on the turnstile, resulting in deadlock. Let us fix that:</p>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>     1. wait( mutex )
     2. count++
     3. if count == n
     4.     post( turnstile )
     5. end if
     6. post( mutex )
     7. wait( turnstile )
     8. post( turnstile )
     9. [critical point]
    10. wait( mutex )
    11. count--
    12. if count == 0
    13.     wait( turnstile )
    14. end if
    15. post( mutex )</code></pre>
<p>This solves the problem previously identified by putting the checks of <code>count</code> inside the critical section controlled by <code>mutex</code>. Unfortunately, there is another problem that can occur here: suppose one particular thread gets through the second mutex but is running in a loop and gets back through the first mutex again. This would be like one thread being one “lap” ahead of the others. We can prevent this by having two turnstiles: first all threads wait at the first turnstile until the last gets there and lets them through. Then all threads wait at a second turnstile until the last gets there and lets them all through again. The form of the solution represented visually, is:</p>
<p><img src="images/reusable-barrier.png" alt="image" style="width:75.0%" /><br />
A visual representation of the group rendezvous with two turnstiles <span class="citation" data-cites="mte241"></span>.</p>
<p>From left to right, the seven steps of the diagram are <span class="citation" data-cites="mte241"></span>:</p>
<ol>
<li><p>The threads arrive at the rendezvous.</p></li>
<li><p>The <span class="math inline">n</span>th thread arrives at the rendezvous.</p></li>
<li><p>That last thread unlocks the first turnstile and locks the second turnstile.</p></li>
<li><p>The threads pass through the first turnstile.</p></li>
<li><p>The <span class="math inline">n</span>th thread passes through the first turnstile; it may not have been the last to arrive at the first turnstile.</p></li>
<li><p>The thread that just arrived locks the first turnstile and unlocks the second.</p></li>
<li><p>The threads leave the rendezvous.</p></li>
</ol>
<p><strong>Thread <em>K</em></strong></p>
<pre><code>     1. wait( mutex )
     2. count++
     3. if count == n
     4.     wait( turnstile2 )
     5.     post( turnstile1 )
     6. end if
     7. post( mutex )
     8. wait( turnstile1 )
     9. post( turnstile1 )
    10. [critical point]
    11. wait( mutex )
    12. count--
    13. if count == 0
    14.     wait( turnstile1 )
    15.     post( turnstile2 )
    16. end if
    17. post( mutex )
    18. wait( turnstile2 )
    19. post( turnstile2 )</code></pre>
<p>This solution can also be called a <em>two-phase barrier</em> because all threads have to wait twice: once at each turnstile.</p>
<h1 id="the-producer-consumer-problem" class="unnumbered">16 — The Producer-Consumer Problem</h1>
<h2 id="classical-synchronization-problems-producer-consumer" class="unnumbered">Classical Synchronization Problems: Producer-Consumer</h2>
<p>Various operating systems textbooks provide a few “classical problems”: some scenarios that are phrased in real-world terms but meant to be an analogy for a problem that operating systems will deal with. These standard or classic problems are used to test any newly-proposed synchronization or coordination scheme. The solutions make use of semaphores as the basis for mutual exclusion. We are going to examine three of them in-depth: the producer-consumer problem, the readers-writers problem, and the dining philosophers problem.</p>
<p>The most common synchronization problem is the producer-consumer problem, also sometimes called the bounded-buffer-problem. Two processes share a common buffer that is of fixed size. One process is the producer: it generates data and puts it in the buffer. The other is the consumer: it takes data out of the buffer. This problem can be generalized to have <span class="math inline">p</span> producers and <span class="math inline">c</span> consumers, but for the sake of keeping the explanation simple, for now we will have just one of each <span class="citation" data-cites="mos"></span>.</p>
<p>There are a couple of rules to be aware of. It is not possible to write into a buffer that is already full; if the buffer has capacity <span class="math inline">N</span> and there are currently <span class="math inline">N</span> items in it, the producer cannot write into the buffer and must wait until there is space. It is similarly not possible to read from an empty buffer; if the buffer has zero elements in it, the consumer cannot read from the buffer and must wait until there is something in there.</p>
<p>To keep track of the number of items in the buffer, we will have some variable <code>count</code>. This is a variable shared between more than one thread, and therefore access to this should be controlled with mutual exclusion. Let us assume the maximum number of elements in the buffer is defined as <code>BUFFER_SIZE</code>.</p>
<p>If busy-waiting is permitted, that is, we do not care if we are wasting CPU time, we can get away with one mutex, which we can call <code>mutex</code>. Each of the producer and consumer threads very likely run in an infinite loop on their own, but the code below is the sufficient to explain one iteration.</p>
<p><span>2</span>
<strong>Producer</strong></p>
<pre><code>     1. [produce item]
     2. added = false
     3. while added is false
     4.    wait( mutex )
     5.    if count &lt; BUFFER_SIZE
     6.        [add item to buffer]
     7.        count++
     8.        added = true
     9.    end if
    10.    post( mutex )
    11. end while</code></pre>
<p><strong>Consumer</strong></p>
<pre><code>     1. removed = false
     2. while removed is false
     3.    wait( mutex )
     4.    if count &gt; 0
     5.        [remove item from buffer]
     6.        count--
     7.        removed = true
     8.    end if
     9.    post( mutex )
    10. end while
    11. [consume item]</code></pre>
<p>While this accomplishes what we want, it is inefficient. Let’s add a new rule that says we want to avoid busy-waiting. Thus, when the producer is waiting for space it will be blocked and just as the consumer will be when the consumer is waiting for an element. To accomplish this, we will need two general semaphores, each with maximum value of <code>BUFFER_SIZE</code>. The first is called <code>items</code>: it starts at 0 and represents how many spaces in the buffer are full. The second is the mirror image <code>spaces</code>; it starts at <code>BUFFER_SIZE</code> and represents the number of spaces in the buffer that are currently empty.</p>
<p><span>2</span>
<strong>Producer</strong></p>
<pre><code>     1. [produce item]
     2. wait( spaces )
     3. [add item to buffer]
     4. post( items )</code></pre>
<p><strong>Consumer</strong></p>
<pre><code>     1. wait( items )
     2. [remove item from buffer]
     3. post( spaces )
     4. [consume item]</code></pre>
<p>The producer can continue to produce items until the buffer is full and the consumer can continue to consume items until the buffer is empty. This solution works okay, given two assumptions: (1) that the actions of adding an item to the buffer and removing an item from the buffer add to and remove from the “next” space; and (2) that there is exactly one producer and one consumer in the system. If we have two producers, for example, they might be trying to write into the same space at the same time, and this would be a problem.</p>
<p>To generalize this solution to allow multiple producers and multiple consumers, what we need to do is add another binary semaphore, <code>mutex</code> (initialized to 1), effectively combining the previous solution with the one before it:</p>
<p><span>2</span>
<strong>Producer</strong></p>
<pre><code>     1. [produce item]
     2. wait( spaces )
     3. wait( mutex )
     4. [add item to buffer]
     5. post( mutex )
     6. post( items )</code></pre>
<p><strong>Consumer</strong></p>
<pre><code>     1. wait( items )
     2. wait( mutex )
     3. [remove item from buffer]
     4. post( mutex )
     5. post( spaces )
     6. [consume item]</code></pre>
<p>This situation should be setting off some alarm bells in your mind. In the synchronization patterns examined earlier, we mentioned the possibility of deadlock: all threads getting stuck. The hint that we might have a problem is one <code>wait</code> statement inside another. Unfortunately, seeing this pattern is not necessarily a guarantee that deadlock is going to happen (that would be too easy). This is, however, a sign that we need to analyze the code to determine if there is a problem.</p>
<p>Reading through the psuedocode above, you should be able to reason that this solution will not get stuck. You may choose a strategy along the lines of “proof by contradiction” and try to come up with a scenario that leads to deadlock. If you are unable to find one, then you may have a suitable solution (though it might be best to have someone else check to be sure). This is not a substitute for a formal mathematical proof, but the logic in your analysis should be convincing. Consider an alternate solution:</p>
<p><span>2</span>
<strong>Producer</strong></p>
<pre><code>     1. [produce item]
     2. wait( mutex )
     3. wait( spaces )
     4. [add item to buffer]
     5. post( items )
     6. post( mutex )</code></pre>
<p><strong>Consumer</strong></p>
<pre><code>     1. wait( mutex )
     2. wait( items )
     3. [remove item from buffer]
     4. post( spaces )
     5. post( mutex )
     6. [consume item]</code></pre>
<p>This solution is very much like the one we are certain works, except we have swapped the order of the <code>wait</code> statements. As before, we need to analyze this code to determine if there is a problem. This solution does have the deadlock problem. Imagine at the start of execution, when the buffer is empty, the consumer thread runs first. It will wait on <code>mutex</code>, be allowed to proceed, and then will be blocked on <code>items</code> because the buffer is initially empty. The thread is blocked. When the producer thread runs, it waits on <code>mutex</code> and cannot proceed because the consumer thread is in the critical section there. So the producer is blocked and can never produce any items. Thus, we have deadlock. This situation could occur any time the buffer is empty.</p>
<p>If the above pseudocode were implemented it is not a certainty that there will be a deadlock every time. In fact, the code will probably work fine most of the time. Once, however, we have found one scenario that can lead to deadlock, there is no need to look for other failure cases; we can write off this solution and replace it with a better one.</p>
<p>But let’s get to doing an actual example! We will take some time to analyze this solution and understand how we got from the psuedocode above to the actual code below.</p>
<h3 id="producer-consumer-example" class="unnumbered">Producer-Consumer Example</h3>
<div class="sourceCode" id="cb130" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb130-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb130-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb130-3" title="3"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb130-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb130-5" title="5"><span class="pp">#include </span><span class="im">&lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb130-6" title="6"></a>
<a class="sourceLine" id="cb130-7" title="7"><span class="pp">#define BUFFER_SIZE 20</span></a>
<a class="sourceLine" id="cb130-8" title="8">sem_t spaces;</a>
<a class="sourceLine" id="cb130-9" title="9">sem_t items;</a>
<a class="sourceLine" id="cb130-10" title="10"><span class="dt">int</span> counter = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb130-11" title="11"><span class="dt">int</span>* buffer;</a>
<a class="sourceLine" id="cb130-12" title="12"></a>
<a class="sourceLine" id="cb130-13" title="13"><span class="dt">int</span> produce() {</a>
<a class="sourceLine" id="cb130-14" title="14">  ++counter;</a>
<a class="sourceLine" id="cb130-15" title="15">  <span class="cf">return</span> counter;</a>
<a class="sourceLine" id="cb130-16" title="16">} </a>
<a class="sourceLine" id="cb130-17" title="17"></a>
<a class="sourceLine" id="cb130-18" title="18"><span class="dt">void</span> consume( <span class="dt">int</span> value ) {</a>
<a class="sourceLine" id="cb130-19" title="19">  printf(<span class="st">&quot;Consumed %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, value);</a>
<a class="sourceLine" id="cb130-20" title="20">}</a>
<a class="sourceLine" id="cb130-21" title="21"></a>
<a class="sourceLine" id="cb130-22" title="22"><span class="dt">void</span>* producer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb130-23" title="23">  <span class="dt">int</span> pindex = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb130-24" title="24">  <span class="cf">while</span>( counter &lt; <span class="dv">10000</span> ) {</a>
<a class="sourceLine" id="cb130-25" title="25">    <span class="dt">int</span> v = produce();</a>
<a class="sourceLine" id="cb130-26" title="26">    sem_wait( &amp;spaces );</a>
<a class="sourceLine" id="cb130-27" title="27">    buffer[pindex] = v;</a>
<a class="sourceLine" id="cb130-28" title="28">    pindex = (pindex + <span class="dv">1</span>) % BUFFER_SIZE;</a>
<a class="sourceLine" id="cb130-29" title="29">    sem_post( &amp;items );</a>
<a class="sourceLine" id="cb130-30" title="30">  }</a>
<a class="sourceLine" id="cb130-31" title="31">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb130-32" title="32">}</a>
<a class="sourceLine" id="cb130-33" title="33"></a>
<a class="sourceLine" id="cb130-34" title="34"><span class="dt">void</span>* consumer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb130-35" title="35">  <span class="dt">int</span> cindex = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb130-36" title="36">  <span class="dt">int</span> ctotal = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb130-37" title="37">  <span class="cf">while</span>( ctotal &lt; <span class="dv">10000</span> ) {</a>
<a class="sourceLine" id="cb130-38" title="38">    sem_wait( &amp;items );</a>
<a class="sourceLine" id="cb130-39" title="39">    <span class="dt">int</span> temp = buffer[cindex];</a>
<a class="sourceLine" id="cb130-40" title="40">    buffer[cindex] = -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb130-41" title="41">    cindex = (cindex + <span class="dv">1</span>) % BUFFER_SIZE;</a>
<a class="sourceLine" id="cb130-42" title="42">    sem_post( &amp;spaces );</a>
<a class="sourceLine" id="cb130-43" title="43">    consume( temp );</a>
<a class="sourceLine" id="cb130-44" title="44">    ++ctotal;</a>
<a class="sourceLine" id="cb130-45" title="45">  }</a>
<a class="sourceLine" id="cb130-46" title="46">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb130-47" title="47">}</a>
<a class="sourceLine" id="cb130-48" title="48"></a>
<a class="sourceLine" id="cb130-49" title="49"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb130-50" title="50">  buffer = malloc( BUFFER_SIZE * <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb130-51" title="51">  <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; BUFFER_SIZE; i++ ) {</a>
<a class="sourceLine" id="cb130-52" title="52">    buffer[i] = -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb130-53" title="53">  }  </a>
<a class="sourceLine" id="cb130-54" title="54">  sem_init( &amp;spaces, <span class="dv">0</span>, BUFFER_SIZE );</a>
<a class="sourceLine" id="cb130-55" title="55">  sem_init( &amp;items, <span class="dv">0</span>, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb130-56" title="56"></a>
<a class="sourceLine" id="cb130-57" title="57">  pthread_t prod;</a>
<a class="sourceLine" id="cb130-58" title="58">  pthread_t con;</a>
<a class="sourceLine" id="cb130-59" title="59"></a>
<a class="sourceLine" id="cb130-60" title="60">  pthread_create( &amp;prod, NULL, producer, NULL );</a>
<a class="sourceLine" id="cb130-61" title="61">  pthread_create( &amp;con, NULL, consumer, NULL );</a>
<a class="sourceLine" id="cb130-62" title="62">  pthread_join( prod, NULL );</a>
<a class="sourceLine" id="cb130-63" title="63">  pthread_join( con, NULL );</a>
<a class="sourceLine" id="cb130-64" title="64"></a>
<a class="sourceLine" id="cb130-65" title="65">  free( buffer );</a>
<a class="sourceLine" id="cb130-66" title="66">  sem_destroy( &amp;spaces );</a>
<a class="sourceLine" id="cb130-67" title="67">  sem_destroy( &amp;items );</a>
<a class="sourceLine" id="cb130-68" title="68">  pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb130-69" title="69">}</a></code></pre></div>
<h3 id="mutex-syntax" class="unnumbered">Mutex Syntax</h3>
<p>Before we go on to the the next code example, we should take a moment to learn about the syntax of the pthread mutex. While it is possible, of course, to use a semaphore as a mutex, frequently we will use the more specialized tool for this task.</p>
<p>The structure representing the mutex is of type <code>pthread_mutex_t</code>. We don’t care about the internals or what the struct is made of; it is either locked or unlocked and that’s all that matters to us.</p>
<div class="sourceCode" id="cb131" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb131-1" title="1">pthread_mutex_init( pthread_mutex_t *mutex, pthread_mutexattr_t *attributes )</a>
<a class="sourceLine" id="cb131-2" title="2">pthread_mutex_lock( pthread_mutex_t *mutex )</a>
<a class="sourceLine" id="cb131-3" title="3">pthread_mutex_trylock( pthread_mutex_t *mutex ) <span class="co">/* Returns 0 on success */</span></a>
<a class="sourceLine" id="cb131-4" title="4">pthread_mutex_unlock( pthread_mutex_t *mutex )</a>
<a class="sourceLine" id="cb131-5" title="5">pthread_mutex_destroy( pthread_mutex_t *mutex )</a></code></pre></div>
<p>The first function of note is <code>pthread_mutex_init</code> which is used to create a new mutex variable and returns it, with type <code>pthread_mutex_t</code>. It takes an optional parameter, the attributes (the details of which are not important at the moment, but relate mostly to priorities). We can initialize it using <code>NULL</code> and that is sufficient. There is also a syntactic shortcut to do static initialization if you do not want to set attributes <span class="citation" data-cites="pthreads"></span>:</p>
<div class="sourceCode" id="cb132" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb132-1" title="1">pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;</a></code></pre></div>
<p>When created, by default, the mutex is unlocked. There are three methods related to using the mutex; two to lock it and one to unlock it, all of which take as a parameter the mutex to (un)lock. The unlock method, <code>pthread_mutex_unlock</code> is self-explanatory. As expected, attempting to unlock a mutex that is not currently locked is an error, but it is also an error if one thread attempts to unlock a mutex owned by another thread <span class="citation" data-cites="pthreads"></span>.</p>
<p>The two kinds of lock are <code>pthread_mutex_lock</code>, which is blocking, and <code>pthread_mutex_trylock</code>, which is nonblocking. The lock function works as you would expect: if the mutex is currently locked, the calling function is blocked until its turn to enter the critical section; if the mutex is unlocked then it changes to being locked and the current thread enters the critical section. Trylock is more complicated and not necessary for understanding the producer-consumer example, but will come up again soon when we look at another classical synchronization problem.</p>
<p>To destroy a mutex, there is a method <code>pthread_mutex_destroy</code>. As expected, it cleans up a mutex and should be used when finished with it. If attributes were created with <code>pthread_mutexattr_init</code> they should be destroyed with <code>pthread_mutexattr_destroy</code>.</p>
<p>An attempt to destroy the mutex may fail if the mutex is currently locked. The specification says that destroying an unlocked mutex is okay, but attempting to destroy a locked one results in undefined behaviour. Undefined behaviour is, in the words of the internet, the worst thing ever: it means code might work some of the time or on some systems, but not others, or could work fine for a while and then break suddenly later when something else is changed<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<h3 id="parallelizing-the-producer-consumer-solution" class="unnumbered">Parallelizing the Producer-Consumer Solution</h3>
<p>Now suppose that we wanted to have ten producers and ten consumers. How do we get there from here?</p>
<div class="sourceCode" id="cb133" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb133-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb133-2" title="2"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb133-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb133-4" title="4"><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></a>
<a class="sourceLine" id="cb133-5" title="5"><span class="pp">#include </span><span class="im">&lt;semaphore.h&gt;</span></a>
<a class="sourceLine" id="cb133-6" title="6"></a>
<a class="sourceLine" id="cb133-7" title="7"><span class="pp">#define BUFFER_SIZE 100</span></a>
<a class="sourceLine" id="cb133-8" title="8"><span class="dt">int</span> buffer[BUFFER_SIZE];</a>
<a class="sourceLine" id="cb133-9" title="9"><span class="dt">int</span> pindex = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb133-10" title="10"><span class="dt">int</span> cindex = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb133-11" title="11">sem_t spaces;</a>
<a class="sourceLine" id="cb133-12" title="12">sem_t items;</a>
<a class="sourceLine" id="cb133-13" title="13">pthread_mutex_t mutex;</a>
<a class="sourceLine" id="cb133-14" title="14"></a>
<a class="sourceLine" id="cb133-15" title="15"><span class="dt">int</span> produce( <span class="dt">int</span> id ) {</a>
<a class="sourceLine" id="cb133-16" title="16">  <span class="dt">int</span> r = rand();</a>
<a class="sourceLine" id="cb133-17" title="17">  printf(<span class="st">&quot;Producer %d produced %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, id, r);</a>
<a class="sourceLine" id="cb133-18" title="18">  <span class="cf">return</span> r;</a>
<a class="sourceLine" id="cb133-19" title="19">}</a>
<a class="sourceLine" id="cb133-20" title="20"></a>
<a class="sourceLine" id="cb133-21" title="21"><span class="dt">void</span> consume( <span class="dt">int</span> id, <span class="dt">int</span> number ) {</a>
<a class="sourceLine" id="cb133-22" title="22">  printf(<span class="st">&quot;Consumer %d consumed %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, id, number);</a>
<a class="sourceLine" id="cb133-23" title="23">}</a>
<a class="sourceLine" id="cb133-24" title="24"></a>
<a class="sourceLine" id="cb133-25" title="25"><span class="dt">void</span>* producer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb133-26" title="26">  <span class="dt">int</span>* id = (<span class="dt">int</span>*) arg;</a>
<a class="sourceLine" id="cb133-27" title="27">  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10000</span>; ++i) {</a>
<a class="sourceLine" id="cb133-28" title="28">    <span class="dt">int</span> num = produce(*id); </a>
<a class="sourceLine" id="cb133-29" title="29">    sem_wait( &amp;spaces );</a>
<a class="sourceLine" id="cb133-30" title="30">    pthread_mutex_lock( &amp;mutex );</a>
<a class="sourceLine" id="cb133-31" title="31">    buffer[pindex] = num;</a>
<a class="sourceLine" id="cb133-32" title="32">    pindex = (pindex + <span class="dv">1</span>) % BUFFER_SIZE;</a>
<a class="sourceLine" id="cb133-33" title="33">    pthread_mutex_unlock( &amp;mutex );</a>
<a class="sourceLine" id="cb133-34" title="34">    sem_post( &amp;items );</a>
<a class="sourceLine" id="cb133-35" title="35">  }</a>
<a class="sourceLine" id="cb133-36" title="36">  free( arg );</a>
<a class="sourceLine" id="cb133-37" title="37">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb133-38" title="38">}</a>
<a class="sourceLine" id="cb133-39" title="39"></a>
<a class="sourceLine" id="cb133-40" title="40"><span class="dt">void</span>* consumer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb133-41" title="41">  <span class="dt">int</span>* id = (<span class="dt">int</span>*) arg;</a>
<a class="sourceLine" id="cb133-42" title="42">  <span class="cf">for</span>(<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10000</span>; ++i) {</a>
<a class="sourceLine" id="cb133-43" title="43">    sem_wait( &amp;items );</a>
<a class="sourceLine" id="cb133-44" title="44">    pthread_mutex_lock( &amp;mutex );</a>
<a class="sourceLine" id="cb133-45" title="45">    <span class="dt">int</span> num = buffer[cindex];</a>
<a class="sourceLine" id="cb133-46" title="46">    buffer[cindex] = -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb133-47" title="47">    cindex = (cindex + <span class="dv">1</span>) % BUFFER_SIZE;</a>
<a class="sourceLine" id="cb133-48" title="48">    pthread_mutex_unlock( &amp;mutex );</a>
<a class="sourceLine" id="cb133-49" title="49">    sem_post( &amp;spaces );</a>
<a class="sourceLine" id="cb133-50" title="50">    consume( *id, num );</a>
<a class="sourceLine" id="cb133-51" title="51">  }</a>
<a class="sourceLine" id="cb133-52" title="52">  free( id );</a>
<a class="sourceLine" id="cb133-53" title="53">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb133-54" title="54">}</a>
<a class="sourceLine" id="cb133-55" title="55"></a>
<a class="sourceLine" id="cb133-56" title="56"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb133-57" title="57">  sem_init( &amp;spaces, <span class="dv">0</span>, BUFFER_SIZE );</a>
<a class="sourceLine" id="cb133-58" title="58">  sem_init( &amp;items, <span class="dv">0</span>, <span class="dv">0</span> );  </a>
<a class="sourceLine" id="cb133-59" title="59">  pthread_mutex_init( &amp;mutex, NULL );</a>
<a class="sourceLine" id="cb133-60" title="60"></a>
<a class="sourceLine" id="cb133-61" title="61">  pthread_t threads[<span class="dv">20</span>];</a>
<a class="sourceLine" id="cb133-62" title="62"></a>
<a class="sourceLine" id="cb133-63" title="63">  <span class="cf">for</span>( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) {</a>
<a class="sourceLine" id="cb133-64" title="64">    <span class="dt">int</span>* id = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb133-65" title="65">    *id = i;</a>
<a class="sourceLine" id="cb133-66" title="66">    pthread_create(&amp;threads[i], NULL, producer, id);</a>
<a class="sourceLine" id="cb133-67" title="67">  }</a>
<a class="sourceLine" id="cb133-68" title="68">  <span class="cf">for</span>( <span class="dt">int</span> j = <span class="dv">10</span>; j &lt; <span class="dv">20</span>; j++ ) {</a>
<a class="sourceLine" id="cb133-69" title="69">    <span class="dt">int</span>* jd = malloc(<span class="kw">sizeof</span>(<span class="dt">int</span>));</a>
<a class="sourceLine" id="cb133-70" title="70">    *jd = j-<span class="dv">10</span>;</a>
<a class="sourceLine" id="cb133-71" title="71">    pthread_create(&amp;threads[j], NULL, consumer, jd);</a>
<a class="sourceLine" id="cb133-72" title="72">  }</a>
<a class="sourceLine" id="cb133-73" title="73">  <span class="cf">for</span>( <span class="dt">int</span> k = <span class="dv">0</span>; k &lt; <span class="dv">20</span>; k++ ){  </a>
<a class="sourceLine" id="cb133-74" title="74">    pthread_join(threads[k], NULL);</a>
<a class="sourceLine" id="cb133-75" title="75">  }</a>
<a class="sourceLine" id="cb133-76" title="76">  sem_destroy( &amp;spaces );</a>
<a class="sourceLine" id="cb133-77" title="77">  sem_destroy( &amp;items );</a>
<a class="sourceLine" id="cb133-78" title="78">  pthread_mutex_destroy( &amp;mutex );</a>
<a class="sourceLine" id="cb133-79" title="79">  pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb133-80" title="80">}</a></code></pre></div>
<h1 id="hogwarts-school-of-witchcraft-and-wizardry" class="unnumbered">17 — Hogwarts School of Witchcraft and Wizardry</h1>
<h2 id="in-class-exercise-harry-potter-and-the-pthread-house-elves" class="unnumbered">In Class Exercise: Harry Potter and the pthread House Elves</h2>
<h5 id="background.-1">Background.</h5>
<p>At Hogwarts School of Witchcraft and Wizardry, undesirable tasks are done by House
Elves, magical creatures who apparently are not covered under any sort of employment
standards or workers rights legislation. They work as a team under the direction of
Dobby, who is a free elf. At the beginning of the day, the headmaster, Dumbledore, tells Dobby how many tasks there are to do today. Dobby will communicate with Dumbledore about what the specific tasks to do are, and posts a partial list of items for the other elves to do. The elves take tasks from the list and do them. When the list is empty, Dobby asks for more directions and posts more tasks. This continues until the house elves have finished all the tasks for the day.</p>
<h5 id="primary-objective.-1">Primary Objective.</h5>
<p>The primary objective of this exercise is to practice using synchronization constructs such as semaphores and mutexes in a simple C program.</p>
<h5 id="secondary-objectives.-1">Secondary Objective(s).</h5>
<p>You will gain some experience in designing and debugging a multithreaded program. You may also improve your ability to work with version control (git) and gitlab.</p>
<h5 id="starter-code.-1">Starter Code.</h5>
<p>The starter code can be found at <a href="https://git.uwaterloo.ca/ece252-1195/ece252-e2">https://git.uwaterloo.ca/ece252-1195/ece252-e2</a> – fork this repository to your own space. Set permissions for this repository to be private, but add the group for the course staff with read access so your code can be evaluated.</p>
<h5 id="submitting-your-code.-1">Submitting Your Code.</h5>
<p>When you’re done, use the command <code>git commit -a</code> to add all files to your commit and enter a commit message. Then <code>git push</code> to upload your changes to your repository. You can commit and push as many times as you like; we’ll look at whatever was last pushed. And check that you gave the course staff permissions!</p>
<h5 id="grading.-1">Grading.</h5>
<p>Binary grading: 1 if you have made a meaningful attempt at implementing the code; 0 otherwise.</p>
<h5 id="description-of-behaviour.-1">Description of Behaviour.</h5>
<p>The goal is to implement the program so that the following behaviour occurs:</p>
<ul>
<li><p>At program start, the first argument provided to the program represents the total number of tasks to do today. So if, for example, the program is invoked with <code>./hogwarts 100</code>, there are 100 tasks to be done today (total tasks).</p></li>
<li><p>The <code>main</code> function should initialize and clean up, respectively, any global variables.</p></li>
<li><p>Your program should create five (5) house elves (<code>house_elf()</code>) and one (1) Dobby thread (<code>dobby()</code>).</p></li>
<li><p>Worker elves take tasks using the function
<code>take_task()</code> (which cannot be safely run in parallel) and then do the work by
calling <code>do_work()</code> (which can be done in parallel). If the list of tasks is
empty, an elf cannot call <code>take_task()</code> and must instead wake up Dobby, who will then post the next 10 tasks before going to sleep again; meanwhile the elf is blocked until the next group of tasks is ready.</p></li>
<li><p>When woken up, Dobby posts (up to) 10 tasks to do by calling <code>post_tasks()</code> and updates the number of available tasks (active tasks). After that, Dobby sleeps (is blocked). If there are fewer than 10 tasks remaining for the day then Dobby cannot post 10, but instead posts however many remain.</p></li>
<li><p>Note that Dobby and the elves are responsible for managing the number of active tasks.</p></li>
<li><p>House elves don’t know that their day is over until they are told so using <code>pthread_cancel</code>. Dobby must dismiss the other elves using this function, if Dobby gets woken up and the remaining tasks for the day is zero. After cancelling the other threads, Dobby should use <code>pthread_join</code> to wait for each of them to finish before he can go home for the day (exit).</p></li>
<li><p>Your program should not leak memory; be sure to destroy/deallocate anything initialized/allocated.</p></li>
<li><p>There should not be any race conditions in your program either.</p></li>
</ul>
<h5 id="sample-output.">Sample Output.</h5>
<p>Below is some sample output. The actual order of task completion will vary.</p>
<pre><code>jzarnett@ecetesla0:~/ece252$ ./hogwarts 5
There are 5 tasks to do today.
Adding 5 tasks to the list of active tasks.
Task 5 was completed!
Task 3 was completed!
Task 4 was completed!
Task 2 was completed!
Task 1 was completed!
jzarnett@ecetesla0:~/ece252$ ./hogwarts 0
There are 0 tasks to do today.
jzarnett@ecetesla0:~/ece252$ ./hogwarts 20
There are 20 tasks to do today.
Adding 10 tasks to the list of active tasks.
Task 10 was completed!
Task 9 was completed!
Task 8 was completed!
Task 7 was completed!
Task 6 was completed!
Task 4 was completed!
Task 5 was completed!
Task 1 was completed!
Task 3 was completed!
Adding 10 tasks to the list of active tasks.
Task 2 was completed!
Task 20 was completed!
Task 19 was completed!
Task 17 was completed!
Task 15 was completed!
Task 13 was completed!
Task 11 was completed!
Task 16 was completed!
Task 12 was completed!
Task 18 was completed!
Task 14 was completed!
jzarnett@ecetesla0:~/ece252$ ./hogwarts 12
There are 12 tasks to do today.
Adding 10 tasks to the list of active tasks.
Task 10 was completed!
Task 9 was completed!
Task 8 was completed!
Task 7 was completed!
Task 6 was completed!
Task 2 was completed!
Task 1 was completed!
Task 4 was completed!
Adding 2 tasks to the list of active tasks.
Task 5 was completed!
Task 3 was completed!
Task 11 was completed!
Task 12 was completed!</code></pre>
<h5 id="hints-debugging-guidance.-1">Hints &amp; Debugging Guidance.</h5>
<p>This problem is very similar to what is called the “Dining Savages Problem” <span class="citation" data-cites="lbs"></span>, but is probably less offensive. Because who does not like Harry Potter themed material? Also, I really hope J. K. Rowling does not sue me. I don’t have time for that...</p>
<p>Some general guidance is below. If you’re having trouble, try running through these steps and it may resolve your problem. If you’re still stuck you can ask a neighbour or the course staff.</p>
<ul>
<li><p>Check the documentation for how functions work if you are unfamiliar with them (google is your friend!)</p></li>
<li><p>Have you initialized all variables? It is easy to forget; <code>malloc</code> does not initialize the value...</p></li>
<li><p>If a variable is going to be used in more than one function, make sure it is allocated on the heap (ie with <code>malloc</code>) and not on the stack.</p></li>
<li><p>Is there a missing or extra <code>*</code> (dereference) on a pointer somewhere?</p></li>
<li><p>Check carefully what values semaphores are initialized to.</p></li>
<li><p>Is the number of <code>wait</code> and <code>post</code> statements on a given semaphore balanced?</p></li>
<li><p>Does every memory allocation have a matching deallocation?</p></li>
<li><p>Does every code path in a critical section protected by a mutex lead to an unlock statement?</p></li>
<li><p>Are accesses to shared variables protected by a mutex or semaphore appropriately?</p></li>
<li><p>Remember that both reads and writes of shared variables need to be inside critical sections.</p></li>
<li><p>It may be helpful to put <code>printf()</code> statements to follow along what the program is doing and it may help you narrow down where the issue is.</p></li>
<li><p>Don’t be shy about asking for help; the TAs and instructor are here to help you get it done and will help you as much as is reasonable.</p></li>
</ul>
<h1 id="the-readers-writers-problem" class="unnumbered">18 — The Readers-Writers Problem</h1>
<h2 id="the-readers-writers-problem-1" class="unnumbered">The Readers-Writers Problem</h2>
<p>This problem is about concurrent reading and modification of a data structure or record by more than one thread. A writer will modify the data; a reader will read it only without modification. Unlike the producer-consumer problem, some concurrency is allowed:</p>
<ol>
<li><p>Any number of readers may be in the critical section simultaneously.</p></li>
<li><p>Only one writer may be in the critical section (and when it is, no readers are allowed).</p></li>
</ol>
<p>Or, to sum that up, a writer cannot enter the critical section while any other thread (whether reader or writer) is there. While a writer is in the critical section, neither readers nor writers may enter the critical section <span class="citation" data-cites="lbs"></span>. This is very often how file systems work: a file may be read concurrently by any number of threads, but only one thread may write to it at a time (and to prevent reading of inconsistent data, no thread may read during the write).</p>
<p>This is similar to, but distinct from, the general mutual exclusion problem and the producer-consumer problem. In the readers-writers problem, readers do not modify the data (consumers do take things out of the buffer, modifying it). If any thread could read or write the shared data structure, we would have to use the general mutual exclusion solution. Although the general mutual exclusion routine would work in that it would prevent errors, it is a serious performance reduction versus allowing multiple readers concurrently <span class="citation" data-cites="osi"></span>. Thus, this situation is worth examining in its own right.</p>
<p>Let us keep track of the number of readers at any given time with a variable <code>readers</code>. We will need a way of protecting this variable from concurrent modifications, so there will have to be a binary semaphore <code>mutex</code>. We will also need one further semaphore, <code>roomEmpty</code>, as a way of indicating that the room is empty. A writer has to wait for the room to be empty (i.e., <code>wait</code> on the <code>roomEmpty</code> semaphore) before it can enter. The solution comes from <span class="citation" data-cites="lbs"></span>:</p>
<p><span>2</span>
<strong>Writer</strong></p>
<pre><code>     1. wait( roomEmpty )
     2. [write data]
     3. post( roomEmpty )
     
     
     
     
     
     
     
     
     
     </code></pre>
<p><strong>Reader</strong></p>
<pre><code>     1. wait( mutex )
     2. readers++
     3. if readers == 1
     4.     wait( roomEmpty )
     5. end if
     6. post( mutex )
     7. [read data]
     8. wait( mutex )
     9. readers--
    10. if readers == 0
    11.     post( roomEmpty )
    12. end if
    13. post( mutex )</code></pre>
<p>The code for the writer is much simpler than that of the readers. The writer may only enter into the critical section if the room is empty. When it has finished, it signals that the room is empty. The writer can be certain that when it exits the critical section that there are no other threads in the room, because no thread may enter the room while the writer was there.</p>
<p>The reader code is somewhat more complicated. The first reader that arrives encounters the situation that the room is empty, so it “locks” the room (waiting on the <code>roomEmpty</code> semaphore), and that will prevent writers from entering the room. Additional readers do not check if the room is empty; they just proceed to enter. When the last reader leaves the room, it signals that the room is empty (“unlocking it” to allow a writer in). This pattern is sometimes called the <em>light switch</em>, as in <span class="citation" data-cites="mte241"></span>: the first one into the room turns on the lights and the last one out turns them off again.</p>
<p>The reader code has that situation that makes us concerned about the possibility of deadlock: a wait on <code>roomEmpty</code> inside a critical section controlled by <code>mutex</code>. With a bit of reasoning, we can convince ourselves that there is no risk: the only situation in which a thread waits on <code>roomEmpty</code> is that a writer is currently in its critical section. No other reader thread can get the <code>mutex</code> lock. As long as the write operation takes finite time, eventually the writer will post the <code>roomEmpty</code> semaphore and the threads can continue. Deadlock is not a problem.</p>
<p>There is, however, a second problem that we need to be concerned about. Suppose some readers are in the room, and a writer arrives. The writer must wait until all the readers have left the room. When each of the readers is finished, it exits the room. In the meantime, more readers arrive and enter the room. So even though each reader is in the room for only a finite amount of time, there is never a moment when the room has no readers in it. This undesirable situation is not deadlock, because the reader threads are not stuck, but the writer (and any subsequent writers) is (are) going to wait forever. This is a situation called <em>starvation</em>: a thread never gets a chance to run.</p>
<p>Recall criterion 3 of the list of properties we want in any mutual exclusion solution: it must not be possible for a thread requiring access to the critical section to be delayed indefinitely. This problem is just as bad as deadlock in that if it is discovered, it eliminates a proposed solution as an acceptable option, even though starvation might only be an unlikely event. We must therefore improve on this solution such that there is no longer the possibility that a writer starves.</p>
<p>Conceptually, the solution that accomplishes the goal looks something like this: when a writer arrives, any readers currently reading should be permitted to finish their read, but no new readers should be allowed to start reading. Thus, eventually, all the readers currently in the critical section will finish, the writer will get a turn, because the room is empty, and when the writer is done, all the readers that arrived after the writer will be able to enter.</p>
<p>A new binary semaphore is needed here, called <code>turnstile</code>.</p>
<p><span>2</span>
<strong>Writer</strong></p>
<pre><code>     1. wait( turnstile )
     2. wait( roomEmpty )
     3. [write data]
     4. post( turnstile )
     5. post( roomEmpty )
     
     
     
     
     
     
     
     
     
     </code></pre>
<p><strong>Reader</strong></p>
<pre><code>     1. wait( turnstile )
     2. post( turnstile )
     3. wait( mutex )
     4. readers++
     5. if readers == 1
     6.     wait( roomEmpty )
     7. end if
     8. post( mutex )
     9. [read data]
    10. wait( mutex )
    11. readers--
    12. if readers == 0
    13.     post( roomEmpty )
    14. end if
    15. post( mutex )</code></pre>
<p>As before, the writer code is simpler, so we will examine it first. When the writer arrives, it will wait on the turnstile. If it is not the first writer, subsequent writers will queue up there, but if proceeds then it will wait for the room to be empty. Because the writer has locked the turnstile, no new readers can enter. There may be an arbitrary number of readers currently in the room, but each is there for only a finite amount of time. These existing-readers will be allowed to finish and leave the room. Then the writer gets a turn. When the writer is done, it posts the turnstile, which might unblock a reader or another writer.</p>
<p>Readers first get to the turnstile, and if they find it is locked, a writer is in its critical section. Thus, readers will queue at the turnstile if necessary, otherwise proceed. After that, the code is the same as we saw before: keep track of the number of readers and post if the room is empty or not empty.</p>
<p>Does this solution satisfy our goals of avoidance of deadlock and starvation? Starvation is fairly easy to assess: the first attempt at the solution had one scenario leading to starvation and this solution addresses it. Problem solved. You should be able to convince yourself that the solution as described cannot starve the writers or readers.</p>
<p>On to deadlock: the reader code is minimally changed from before; we have identified the turnstile code as not being a problem on its own (though its interactions with other threads need to be examined). The more dangerous block of code is on the side of the writer, because it has that pattern: two waits. If the writer is blocked on the <code>roomEmpty</code> semaphore, no readers or writers could advance past the turnstile and no writers. If the writer is blocked on that semaphore, it means there are readers in the room, and the readers will individually finish and leave (their progress is not impeded). Given that, the room will eventually become empty and the writer will be unblocked.</p>
<p>Note that this solution does not give writers any particular priority: when a writer exits it posts <code>turnstile</code> and that may unblock a reader or a writer. If it unblocks a reader, a whole bunch of readers may enter before the next writer is unblocked and locks the turnstile again. That may or may not be desirable, depending on the application. In any event, it does mean it is possible for readers to proceed even if a writer is queued. If there is a need to give writers priority, there are several techniques for doing so <span class="citation" data-cites="lbs"></span>.</p>
<p>Let’s modify the solution so that writers have priority over readers. Giving writers priority may potentially cause readers to starve, but you may ignore this. We will probably want to break up the <code>roomEmpty</code> semaphore into <code>noReaders</code> and <code>noWriters</code>. A reader in the critical section should hold the <code>noReaders</code> semaphore and a writer should hold <code>noWriters</code> and <code>noReaders</code>.</p>
<p><span>2</span>
<strong>Writer</strong></p>
<pre><code>     1. wait( writeMutex )
     2. writers++
     3. if writers == 1
     4.     wait( noReaders )
     5. end if
     6. post( writeMutex )
     7. wait ( noWriters )
     8. [write data]
     9. post( noWriters ) 
    10. wait( writeMutex )
    11. writers--
    12. if writers == 0
    13.    post( noReaders )
    14. end if
    15. post( writeMutex )     </code></pre>
<p><strong>Reader</strong></p>
<pre><code>     1. wait( noReaders )
     2. wait( readMutex )
     3. readers++
     4. if readers == 1
     5.    wait( noWriters )
     6. end if
     7. post( readMutex )
     8. post( noReaders )
     9. [read data]
    10. wait( readMutex )
    11. readers--
    12. if readers == 0
    13.     post( noWriters )
    14. end if
    15. post( readMutex )</code></pre>
<p>Yikes! The complexity for the writer increased dramatically. The reader is not all that different than it was before, however, and the writer now is to some extent the mirror image of the reader.</p>
<h3 id="readers-writers-example" class="unnumbered">Readers Writers Example</h3>
<p>Using the pseudocode as above, we can implement the readers-writers behaviour in a given program using only semaphores (optionally using a mutex to replace a semaphore). But in the pthread library there is support for readers-writers lock types, meaning we don’t have to reinvent the wheel. We can probably well imagine the actual complexity of the previous solution, so it’s our hope that the readers-writers lock would make our code simpler to read and harder to make mistakes.</p>
<p>The type for the lock is <code>pthread_rwlock_t</code>. It is analogous, obviously, to the mutex type <code>pthread_mutex_t</code>. Let’s consider the functions that we have:</p>
<div class="sourceCode" id="cb141" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb141-1" title="1">pthread_rwlock_init( pthread_rwlock_t * rwlock, pthread_rwlockattr_t * attr )</a>
<a class="sourceLine" id="cb141-2" title="2">pthread_rwlock_rdlock( pthread_rwlock_t * rwlock )</a>
<a class="sourceLine" id="cb141-3" title="3">pthread_rwlock_tryrdlock( pthread_rwlock_t * rwlock )</a>
<a class="sourceLine" id="cb141-4" title="4">pthread_rwlock_wrlock( pthread_rwlock_t * rwlock )</a>
<a class="sourceLine" id="cb141-5" title="5">pthread_rwlock_trywrlock( pthread_rwlock_t  *  rwlock )</a>
<a class="sourceLine" id="cb141-6" title="6">pthread_rwlock_unlock( pthread_rwlock_t * rwlock )</a>
<a class="sourceLine" id="cb141-7" title="7">pthread_rwlock_destroy( pthread_rwlock_t * rwlock )</a></code></pre></div>
<p>In general our syntax very much resembles that of the mutex (attribute initialization and destruction not shown but they do exist). There are some small noteworthy differences, other than obviously the different type of the structure passed. Whereas before we had functions for lock and trylock, we now have those split into readlock and writelock (each of which has its own trylock function). As before, we will return to the subject of how trylock works soon.</p>
<p>In theory, the same thread may lock the same rwlock <span class="math inline">n</span> times; just remember to unlock it <span class="math inline">n</span> times as well.</p>
<p>And speaking of unlock, there’s no specifying whether you are releasing a read or write lock. This is because it is unnecessary; the implementation unlocks whatever type the calling thread was holding. Much like <code>close()</code>, if we can figure out what we’re closing we don’t need the caller of the function to specify what to do.</p>
<p>As for whether readers or writers get priority, the specification says this is implementation defined. If possible, for threads of equal priority, a writer takes precedence over a reader. But your system may vary.</p>
<p>Consider the following example of the simple readers-writers (without writer priority and with risk of starvation) using the “old” way:</p>
<p><span>2</span></p>
<div class="sourceCode" id="cb142" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb142-1" title="1"><span class="dt">int</span> readers;</a>
<a class="sourceLine" id="cb142-2" title="2">pthread_mutex_t mutex;</a>
<a class="sourceLine" id="cb142-3" title="3">sem_t roomEmpty;</a>
<a class="sourceLine" id="cb142-4" title="4"></a>
<a class="sourceLine" id="cb142-5" title="5"><span class="dt">void</span> init( ) {</a>
<a class="sourceLine" id="cb142-6" title="6">  readers = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb142-7" title="7">  pthread_mutex_init( &amp;mutex, NULL );</a>
<a class="sourceLine" id="cb142-8" title="8">  sem_init( &amp;roomEmpty, <span class="dv">0</span>, <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb142-9" title="9">}</a>
<a class="sourceLine" id="cb142-10" title="10"></a>
<a class="sourceLine" id="cb142-11" title="11"><span class="dt">void</span> cleanup( ) {</a>
<a class="sourceLine" id="cb142-12" title="12">  pthread_mutex_destroy( &amp;mutex );</a>
<a class="sourceLine" id="cb142-13" title="13">  sem_destroy( &amp;roomEmpty );</a>
<a class="sourceLine" id="cb142-14" title="14">}</a></code></pre></div>
<div class="sourceCode" id="cb143" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb143-1" title="1"><span class="dt">void</span>* writer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb143-2" title="2">  sem_wait( &amp;roomEmpty );</a>
<a class="sourceLine" id="cb143-3" title="3">  write_data( arg );</a>
<a class="sourceLine" id="cb143-4" title="4">  sem_post( &amp;roomEmpty );</a>
<a class="sourceLine" id="cb143-5" title="5">}</a>
<a class="sourceLine" id="cb143-6" title="6"></a>
<a class="sourceLine" id="cb143-7" title="7"><span class="dt">void</span>* reader( <span class="dt">void</span>* read ) {</a>
<a class="sourceLine" id="cb143-8" title="8">  pthread_mutex_lock( &amp;mutex );</a>
<a class="sourceLine" id="cb143-9" title="9">  readers++;</a>
<a class="sourceLine" id="cb143-10" title="10">  <span class="cf">if</span> ( readers == <span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb143-11" title="11">    sem_wait( &amp;roomEmpty );</a>
<a class="sourceLine" id="cb143-12" title="12">  }</a>
<a class="sourceLine" id="cb143-13" title="13">  pthread_mutex_unlock( &amp;mutex );</a>
<a class="sourceLine" id="cb143-14" title="14">  read_data( arg );</a>
<a class="sourceLine" id="cb143-15" title="15">  pthread_mutex_lock( &amp;mutex );</a>
<a class="sourceLine" id="cb143-16" title="16">  readers--;</a>
<a class="sourceLine" id="cb143-17" title="17">  <span class="cf">if</span> ( readers == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb143-18" title="18">    sem_post( &amp;roomEmpty );</a>
<a class="sourceLine" id="cb143-19" title="19">  }</a>
<a class="sourceLine" id="cb143-20" title="20">  pthread_mutex_unlock( &amp;mutex );</a>
<a class="sourceLine" id="cb143-21" title="21">}</a></code></pre></div>
<p>Now see it as it would be with the use of a rwlock!</p>
<p><span>2</span></p>
<div class="sourceCode" id="cb144" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb144-1" title="1">pthread_rwlock_t rwlock;</a>
<a class="sourceLine" id="cb144-2" title="2"></a>
<a class="sourceLine" id="cb144-3" title="3"><span class="dt">void</span> init( ) {</a>
<a class="sourceLine" id="cb144-4" title="4">  pthread_rwlock_init( &amp;rwlock, NULL );</a>
<a class="sourceLine" id="cb144-5" title="5">}</a>
<a class="sourceLine" id="cb144-6" title="6"></a>
<a class="sourceLine" id="cb144-7" title="7"><span class="dt">void</span> cleanup( ) {</a>
<a class="sourceLine" id="cb144-8" title="8">  pthread_rwlock_destroy( &amp;rwlock );</a>
<a class="sourceLine" id="cb144-9" title="9">}</a></code></pre></div>
<div class="sourceCode" id="cb145" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb145-1" title="1"><span class="dt">void</span>* writer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb145-2" title="2">  pthread_rwlock_wrlock( &amp;rwlock );</a>
<a class="sourceLine" id="cb145-3" title="3">  write_data( arg );</a>
<a class="sourceLine" id="cb145-4" title="4">  pthread_rwlock_unlock( &amp;rwlock );</a>
<a class="sourceLine" id="cb145-5" title="5">}</a>
<a class="sourceLine" id="cb145-6" title="6"></a>
<a class="sourceLine" id="cb145-7" title="7"><span class="dt">void</span>* reader( <span class="dt">void</span>* read ) {</a>
<a class="sourceLine" id="cb145-8" title="8">  pthread_rwlock_rdlock( &amp;rwlock );</a>
<a class="sourceLine" id="cb145-9" title="9">  read_data( arg );</a>
<a class="sourceLine" id="cb145-10" title="10">  pthread_rwlock_unlock( &amp;rwlock );</a>
<a class="sourceLine" id="cb145-11" title="11">}</a></code></pre></div>
<h3 id="seek-and-destroy-the-search-insert-delete-problem" class="unnumbered">Seek and Destroy: the Search-Insert-Delete Problem</h3>
<p>This is an extension of the readers-writers problem called the search-insert-delete problem. Instead of two types of thread, reader and writer, there are three types of thread: searchers, inserters, deleters. They operate on a shared linked list of data.</p>
<p><em>Searchers</em> merely examine the list; hence they can execute concurrently with each other. Searcher threads must call <code>void search( void* target )</code> where the argument to the searcher thread is the element to be found. These most closely resemble readers in the readers-writers problem.</p>
<p><em>Inserters</em> add new items to the end of the list; only one insertion may take place at a time. However, one insert can proceed in parallel with any number of searches. Inserter threads call <code>node* find_insert_loc()</code> to find where to do the insertion; then <code>void insert( void* to_insert, node* after )</code> where the arguments are the location and the element to be inserted. Assume <code>insert</code> is written so the insertion can be done in parallel with the searches. Inserters resemble readers with an additional rule that only one of them can manipulate the list at a time.</p>
<p><em>Deleters</em> remove items from anywhere in the list. At most one deleter process can access the list at a time, and when the deleter is accessing the list, no inserters and no searchers may be accessing the list. Deleter threads call <code>void delete( void* to_delete )</code> where the argument to the deleter thread is the element to be deleted. These most closely resemble writers in the readers-writers problem.</p>
<p>It turns out we don’t need to modify things too much to allow for this third kind of thread. We need to keep track of when there are “no inserters” and “no searchers” (some hints for our semaphores) and another mutex to go around the actual insertion... See the code implementation below.</p>
<p><span>2</span></p>
<div class="sourceCode" id="cb146" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb146-1" title="1">pthread_mutex_t searcher_mutex;</a>
<a class="sourceLine" id="cb146-2" title="2">pthread_mutex_t inserter_mutex;</a>
<a class="sourceLine" id="cb146-3" title="3">pthread_mutex_t perform_insert;</a>
<a class="sourceLine" id="cb146-4" title="4">sem_t no_searchers;</a>
<a class="sourceLine" id="cb146-5" title="5">sem_t no_inserters;</a>
<a class="sourceLine" id="cb146-6" title="6"><span class="dt">int</span> searchers;</a>
<a class="sourceLine" id="cb146-7" title="7"><span class="dt">int</span> inserters;</a>
<a class="sourceLine" id="cb146-8" title="8"></a>
<a class="sourceLine" id="cb146-9" title="9"></a>
<a class="sourceLine" id="cb146-10" title="10"><span class="dt">void</span> init( ) {</a>
<a class="sourceLine" id="cb146-11" title="11">  pthread_mutex_init( &amp;searcher_mutex, NULL );</a>
<a class="sourceLine" id="cb146-12" title="12">  pthread_mutex_init( &amp;inserter_mutex, NULL );</a>
<a class="sourceLine" id="cb146-13" title="13">  pthread_mutex_init( &amp;perform_insert, NULL );</a>
<a class="sourceLine" id="cb146-14" title="14">  sem_init( &amp;no_inserters, <span class="dv">0</span>, <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb146-15" title="15">  sem_init( &amp;no_searchers, <span class="dv">0</span>, <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb146-16" title="16">  searchers = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb146-17" title="17">  inserters = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb146-18" title="18">}</a>
<a class="sourceLine" id="cb146-19" title="19"></a>
<a class="sourceLine" id="cb146-20" title="20"><span class="dt">void</span>* searcher_thread( <span class="dt">void</span> *target ) {</a>
<a class="sourceLine" id="cb146-21" title="21">  pthread_mutex_lock( &amp;searcher_mutex );</a>
<a class="sourceLine" id="cb146-22" title="22">  searchers++;</a>
<a class="sourceLine" id="cb146-23" title="23">  <span class="cf">if</span> ( searchers == <span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb146-24" title="24">    sem_wait( &amp;no_searchers );</a>
<a class="sourceLine" id="cb146-25" title="25">  }</a>
<a class="sourceLine" id="cb146-26" title="26">  pthread_mutex_unlock( &amp;searcher_mutex );</a>
<a class="sourceLine" id="cb146-27" title="27">  </a>
<a class="sourceLine" id="cb146-28" title="28">  search( target );</a>
<a class="sourceLine" id="cb146-29" title="29">  </a>
<a class="sourceLine" id="cb146-30" title="30">  pthread_mutex_lock( &amp;searcher_mutex );</a>
<a class="sourceLine" id="cb146-31" title="31">  searchers--;</a>
<a class="sourceLine" id="cb146-32" title="32">  <span class="cf">if</span> ( searchers == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb146-33" title="33">    sem_post( &amp;no_searchers );</a>
<a class="sourceLine" id="cb146-34" title="34">  }</a>
<a class="sourceLine" id="cb146-35" title="35">  pthread_mutex_unlock( &amp;searcher_mutex );</a>
<a class="sourceLine" id="cb146-36" title="36">}</a></code></pre></div>
<div class="sourceCode" id="cb147" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb147-1" title="1"><span class="dt">void</span>* deleter_thread( <span class="dt">void</span>* to_delete ) {</a>
<a class="sourceLine" id="cb147-2" title="2">  sem_wait( &amp;no_searchers );</a>
<a class="sourceLine" id="cb147-3" title="3">  sem_wait( &amp;no_inserters );</a>
<a class="sourceLine" id="cb147-4" title="4">  </a>
<a class="sourceLine" id="cb147-5" title="5">  delete( to_delete );</a>
<a class="sourceLine" id="cb147-6" title="6">  </a>
<a class="sourceLine" id="cb147-7" title="7">  sem_post( &amp;no_inserters );</a>
<a class="sourceLine" id="cb147-8" title="8">  sem_post( &amp;no_searchers );</a>
<a class="sourceLine" id="cb147-9" title="9">}</a>
<a class="sourceLine" id="cb147-10" title="10"></a>
<a class="sourceLine" id="cb147-11" title="11"></a>
<a class="sourceLine" id="cb147-12" title="12"><span class="dt">void</span>* inserter_thread( <span class="dt">void</span> *to_insert ) {</a>
<a class="sourceLine" id="cb147-13" title="13">  pthread_mutex_lock( &amp;inserter_mutex );</a>
<a class="sourceLine" id="cb147-14" title="14">  inserters++;</a>
<a class="sourceLine" id="cb147-15" title="15">  <span class="cf">if</span> ( inserters == <span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb147-16" title="16">    sem_wait( &amp;no_inserters );</a>
<a class="sourceLine" id="cb147-17" title="17">  }</a>
<a class="sourceLine" id="cb147-18" title="18">  pthread_mutex_unlock( &amp;inserter_mutex );</a>
<a class="sourceLine" id="cb147-19" title="19">  </a>
<a class="sourceLine" id="cb147-20" title="20">  pthread_mutex_lock( &amp;perform_insert );</a>
<a class="sourceLine" id="cb147-21" title="21">  node * insert_after = find_insert_location( );</a>
<a class="sourceLine" id="cb147-22" title="22">  insert( to_insert, insert_after );</a>
<a class="sourceLine" id="cb147-23" title="23">  pthread_mutex_unlock( &amp;perform_insert );</a>
<a class="sourceLine" id="cb147-24" title="24">  </a>
<a class="sourceLine" id="cb147-25" title="25">  pthread_mutex_lock( &amp;inserter_mutex );</a>
<a class="sourceLine" id="cb147-26" title="26">  inserters--;</a>
<a class="sourceLine" id="cb147-27" title="27">  <span class="cf">if</span> ( inserters == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb147-28" title="28">    sem_post( &amp;no_inserters );</a>
<a class="sourceLine" id="cb147-29" title="29">  }</a>
<a class="sourceLine" id="cb147-30" title="30">  pthread_mutex_unlock( &amp;inserter_mutex );</a>
<a class="sourceLine" id="cb147-31" title="31">}</a></code></pre></div>
<h1 id="deadlock" class="unnumbered">19 — Deadlock</h1>
<h2 id="the-dining-philosophers-problem" class="unnumbered">The Dining Philosophers Problem</h2>
<p>The dining philosophers problem was also proposed by Dijkstra in 1965. The problem can be formulated with <span class="math inline">n</span> philosophers, but problem is typically described as involving five philosophers. The description that follows is from <span class="citation" data-cites="osc"></span>. These five smart individuals spend their lives thinking, but every so often, they need to eat. They share a table, each having his or her own chair. In the centre of the table is a bowl of rice, and the table is laid with five single chopsticks. See the diagram below.</p>
<p><img src="images/philosopher-table.png" alt="image" style="width:40.0%" /><br />
The situation of the dining philosophers <span class="citation" data-cites="osc"></span>.</p>
<p>When a philosopher wishes to eat, she sits down at her designated chair, and attempts to pick up the two chopsticks that are nearest (one on the left, and one on the right). Philosophers are polite and therefore do not grab a chopstick out of the hands of a colleague. When a philosopher has both chopsticks, she may eat rice, and when she is finished, she puts down the chopsticks and goes back to thinking.</p>
<p>Some textbooks formulate this problem as philosophers needing two forks to eat rather than chopsticks. It is, of course, much easier to imagine having difficulty eating with only one chopstick than having difficulty with only one fork. Of course, the scenario is a little bit silly; we don’t study it because it is supposed to be a true to life model of how real philosophers behave. The scenario is just a convenient and memorable example of a whole class of problems.</p>
<p>Suppose then that semaphores are the method for managing things. Because only one person can be in possession of a chopstick at a time, each chopstick may be represented by a binary semaphore. As a philosopher needs the chopstick to his left and right to eat, when the philosopher sits down he attempts to acquire the left chopstick, then the right, eats, and puts the chopsticks down. This works fine, until all philosophers sit down at the same time. Each grabs the chopstick to his or her left. None of them are able to acquire the chopstick to his or her right (because someone has already picked it up). None of the philosophers can eat; they are all stuck. This is deadlock.</p>
<p>This example makes it more clear why we call a situation where a thread never gets to run “starvation”. If a philosopher is never able to get both chopsticks, that philosopher will never be able to eat, and though I am not an expert on biology, I have it on good authority that people who do not eat anything end up eventually starving to death. Even philosophers.</p>
<p>One thing that would guarantee that this problem does not occur is to protect the table with a binary semaphore. This would allow exactly one philosopher at a time to eat, but at the very least, deadlock and starvation would be avoided. Although this works, it is a suboptimal solution. There are five seats and five chopsticks and yet only one person is eating at a time. We can get better concurrency and use of the resources.</p>
<p>Next idea: what if we limit the number of philosophers at the table concurrently to four? The pigeonhole principle applies here: if there are <span class="math inline">k</span> pigeonholes and more than <span class="math inline">k</span> pigeons, at least one pigeonhole must have at least two pigeons. Thus, at least one of the four philosophers can get two chopsticks <span class="citation" data-cites="mte241"></span>. Implementing the solution is easy; we have a general semaphore with a maximum and initial value of 4.</p>
<p>Another idea: the problem above occurs because every philosopher tries to pick up the left chopstick first. If some of them try to pick up the left and some pick up the right first, then deadlock will not happen, either <span class="citation" data-cites="osc"></span>.</p>
<p>The dining philosophers problem is a good springboard from which to launch into a much deeper discussion of deadlock, and starvation.</p>
<h2 id="deadlock-1" class="unnumbered">Deadlock</h2>
<p>We have already introduced the subject of deadlock and gave an informal definition as all processes being “stuck” (unable to proceed). A more formal definition is given in <span class="citation" data-cites="osi"></span>: “the <em>permanent</em> blocking of a set of processes that either compete for system resources or communicate with each other”. There is emphasis on permanent. It may be possible for all processes to be stuck temporarily, because one is waiting for some event (e.g., a read from disk), but this situation will resolve itself and is not deadlock. A set of processes is truly deadlocked when each process in the set is blocked on some event that can only be triggered by another blocked process in the set. In this case it is permanent, because none of the events can take place.</p>
<p>A deadlock involves some conflicting needs for resources by two or more processes. Consider a traffic deadlock. Suppose four cars arrive at a four-way stop intersection at the same time. We can divide the intersection into four quadrants, labelled, a, b, c, and d. To drive straight through the intersection, any one vehicle will need at least two of the quadrants (the two directly in front of it).</p>
<p><img src="images/car-deadlock.png" alt="image" style="width:75.0%" /><br />
An illustration of deadlock involving cars <span class="citation" data-cites="osi"></span>.</p>
<p>According to the Highway Traffic Act, whichever vehicle arrives at the stop sign first has the right of way. In the event that two vehicles arrive at the same time, a vehicle yields the right of way to the vehicle on its right. As long as three or fewer vehicles come to the stop sign at the same time, this works. If all four vehicles arrive at the same time, we have the potential for a problem. It is not a deadlock yet, because none of the processes are stuck yet, but it could happen. If all the drivers believe they should go first, we get the situation on the right, and we actually do have deadlock. This is very much like the dining philosophers problem; deadlock occurs if everyone tries to do the same thing at the same time.</p>
<p>Of course, for deadlock to occur, we do not have to have symmetric processes trying to do the same thing at the same time. Given two semaphores, <code>a</code> and <code>b</code>, and two processes, we can have the following code that will sometimes, but not always lead to deadlock. If thread <span class="math inline">P</span> locks <code>a</code> and then there is a process switch, and <code>b</code> is locked by <span class="math inline">Q</span>, both threads will be stuck. Each has one resource the other needs, but they are both blocked and waiting for the other. It is obvious when we compare threads <span class="math inline">P</span> and <span class="math inline">Q</span> like this side-by-side, but in reality the problem is not usually that easy to see.</p>
<p><span>2</span>
<strong>Thread P</strong></p>
<pre><code>     1. wait( a ) 
     2. wait( b )
     3. [critical section]
     4. post( a )
     5. post( b )</code></pre>
<p><strong>Thread Q</strong></p>
<pre><code>     1. wait( b ) 
     2. wait( a )
     3. [critical section]
     4. post( b )
     5. post( a )</code></pre>
<h3 id="reusable-and-consumable-resources" class="unnumbered">Reusable and Consumable Resources</h3>
<p>So, deadlock takes place when two processes or threads are competing for resources. We can generally classify a resource as either <em>reusable</em> or <em>consumable</em>. A reusable resource can be used by one process at a time, and is not depleted by that use. A process may lock the resource, make use of it, then release it such that other processes may acquire it. Processors, memory, files, and semaphores are all examples of reusable resources. If process <span class="math inline">P</span> gets resource A and then releases it, process <span class="math inline">Q</span> can acquire it. Thus, the example above involving <span class="math inline">P</span> and <span class="math inline">Q</span> is a deadlock involving reusable resources.</p>
<p>A consumable resource is one that is created and destroyed upon consumption. If the user presses the “Z” key on the keyboard, this generates an interrupt and produces the “Z” character in a buffer. A process that takes input will then consume that character (e.g., it goes into the <code>vi</code> editor window) and it is unavailable to other processes. Other things that are consumable resources: interrupts, posts, and messages. Deadlock is somewhat less likely when dealing with consumable resources, but in theory, all processes could be waiting to receive a message, if it is a blocking receive, and no process can send a message (because they are all waiting for some other process to send first).</p>
<h3 id="conditions-for-deadlock" class="unnumbered">Conditions for Deadlock</h3>
<p>When a disaster happens, it is typically a result of a chain of things going wrong. If any one of those things did not happen, the disaster would be averted. This is referred to as “breaking the chain”. There are four conditions for deadlock:</p>
<ol>
<li><p><strong>Mutual Exclusion</strong>: A resource belongs to, at most, one process at a time.</p></li>
<li><p><strong>Hold-and-Wait</strong>: A process that is currently holding some resources may request additional resources and may be forced to wait for them.</p></li>
<li><p><strong>No Preemption</strong>: A resource cannot be “taken” from the process that holds it; only the process currently holding that resource may release it.</p></li>
<li><p><strong>Circular-Wait</strong>: A cycle in the resource allocation graph.</p></li>
</ol>
<p>If the first three conditions are true, deadlock is possible, but deadlock will only happen if the fourth condition is fulfilled. But what is a resource allocation graph? It is a directed graph that tells us the state of the system by representing the processes, the resources, and which resources are held by which processes. Consider the example below:</p>
<p><img src="images/rag1.png" alt="image" style="width:20.0%" /><br />
A sample resource allocation graph <span class="citation" data-cites="osc"></span>.</p>
<p>A process is represented by a circle labelled <span class="math inline">P_{n}</span>. A resource is a box labelled <span class="math inline">R_{n}</span> and contains one or more black circles, representing how many of that resource are available. A binary semaphore would therefore have one black circle; a general semaphore will have 1 or more. A directed edge from <span class="math inline">P_{i}</span> to <span class="math inline">R_{j}</span> is a request: a process requests that resource. A directed edge from <span class="math inline">R_{j}</span> to <span class="math inline">P_{i}</span> represents assignment - the process holds that resource. When a request is made, a request edge is inserted into the graph; if the request is fulfilled it is instantly turned into an assignment edge. When a resource is released, the assignment edge is deleted <span class="citation" data-cites="osc"></span>.</p>
<p>If there are no cycles in the graph, then we can be certain that no process in the system is deadlocked. If a cycle exists, then some process may be deadlocked:</p>
<p><img src="images/rag2.png" alt="image" style="width:20.0%" /><br />
A sample resource allocation graph with a deadlock <span class="citation" data-cites="osc"></span>.</p>
<p>But the presence of a cycle, on its own, is not necessarily certain that there is a deadlock:</p>
<p><img src="images/rag3.png" alt="image" style="width:20.0%" /><br />
A sample resource allocation graph with a cycle, but no deadlock <span class="citation" data-cites="osc"></span>.</p>
<p>In this case, <span class="math inline">P_{4}</span> and <span class="math inline">P_{2}</span> are not part of the cycle and when they release their held resources, the other two processes will be able to proceed.</p>
<h2 id="dealing-with-deadlock" class="unnumbered">Dealing with Deadlock</h2>
<p>There are four basic approaches to dealing with deadlock, each of which we will examine in turn.</p>
<ol>
<li><p>Ignore it.</p></li>
<li><p>Deadlock prevention.</p></li>
<li><p>Deadlock avoidance.</p></li>
<li><p>Deadlock detection.</p></li>
</ol>
<h3 id="deadlock-option-1-ignore-it" class="unnumbered">Deadlock Option 1: Ignore it</h3>
<p>This option is certainly convenient: we simply pretend that deadlock can never happen, or if it does happen, it is someone else’s fault. That said, this is the approach taken in Microsoft Windows, so it is a valid option. If two processes get deadlocked, the user may simply see no progress (or the “not responding” dialog) and have to open task manager and start killing processes. But the operating system designers can plausibly blame the problem on the program authors. Since we are the program authors we can’t really pass the buck here. You can try to blame the users, but they’ll tell you that your system shouldn’t allow them to make mistakes in the first place. Well then.</p>
<p>Setting aside the “do-nothing” option, let us move on to some approaches that actually deal with the problem.</p>
<h3 id="deadlock-option-2-deadlock-prevention" class="unnumbered">Deadlock Option 2: Deadlock Prevention</h3>
<p>This approach is a way of preventing a deadlock from being possible. The first three conditions for deadlock (mutual exclusion, hold and wait, and no preemption) are all necessary for deadlock to be possible. If we eliminate one of these three pillars, deadlock is not possible and it is prevented from happening.</p>
<h5 id="mutual-exclusion.">Mutual Exclusion.</h5>
<p>This pillar cannot, generally speaking, be disallowed. The purpose of mutual exclusion is to prevent errors like inconsistent state or crashes. Getting rid of mutual exclusion to rule out the possibility of deadlock is a cure that is worse than the disease. It is therefore not acceptable as a solution.</p>
<p>When it comes to your specific program, though, you might be able to make it so that mutual exclusion is not necessary. If you can give each thread, for example, its own copy of the data, or you can find an algorithm that no longer requires locking a given resource, then by all means, use it! Locking and other mutual exclusion constructs are things we use because we must, not because we like to.</p>
<h5 id="hold-and-wait.">Hold and Wait.</h5>
<p>To prevent the hold-and-wait condition, we must guarantee that when a process requests a resource, it does not have any other resource. In a practical sense this does not mean that things can be requested only one at a time; that would be like telling the philosophers that when they have one chopstick already, they cannot request another.</p>
<p>The operating system could operate under these rules, but we know that our usual commercial operating systems don’t do this. We could imagine a world where things are different, but that’s not very helpful when it comes to implementing the program we’re trying to write. Even so, the idea of requesting everything up front is obviously not possible (at the time of opening a document you are not asked if you are going to use the printer sometime later, just in case), nor is giving up all resources before asking for more possible. A resource that cannot be easily released is memory, as released memory may be collected and reassigned by the operating system. Therefore we cannot release all resources, and releasing only some of the resources means that we cannot categorically rule out deadlock; we can only make it less likely to occur <span class="citation" data-cites="mte241"></span>.</p>
<p>Another idea that might work is <em>two-phase locking</em>. A process attempts to lock a group of resources at once, and if it does not get everything it needs, it releases the locks it received and tries again. Thus a process does not wait while holding resources. If a philosopher picks up a chopstick but is unable to acquire a second, she puts down the chopstick she has picked up and tries again. Although she may not be the one to eat next, at least not all philosophers are stuck holding one chopstick.</p>
<p>Two phase locking is not applicable to our current model for semaphores, where there is no way to know the value of the semaphore and the operating system will block a process on a <code>wait</code> if some other thread is in the critical region. After the process is blocked on the semaphore, a second process will run, and the first process does not get the opportunity to release the resources it holds. If there exist requests for resources and mutual exclusion areas that return, perhaps, <code>true</code> if the resource is acquired and <code>false</code> if it is unavailable, this can work. Then the program is responsible for checking if any of the requests returned <code>false</code> and releasing any resources where the request returned <code>true</code>.</p>
<p>Fortunately, we know of some routines that do just this: the <code>trylock</code> functions that were mentioned earlier but not expanded upon:</p>
<div class="sourceCode" id="cb150" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb150-1" title="1"><span class="dt">int</span> pthread_mutex_trylock( pthread_mutex_t * mutex )</a>
<a class="sourceLine" id="cb150-2" title="2"><span class="dt">int</span> pthread_rwlock_tryrdlock( pthread_rwlock_t * rwlock )</a>
<a class="sourceLine" id="cb150-3" title="3"><span class="dt">int</span> pthread_rwlock_trywrlock( pthread_rwlock_t  * rwlock )</a></code></pre></div>
<p>These functions return an integer and it’s extremely important to check and see if the return code is 0, because that is the only way to know if the lock was acquired. The call is non-blocking so the code will carry on regardless. Consider below a code description of the dining philosophers if they used two-phase locking via the trylock routines. Assume that the mutex variables have been initialized appropriately. It should be possible to reason about this solution and demonstrate that (1) a philosopher can only eat if they have both chopsticks, and (2) deadlock does not occur.</p>
<div class="sourceCode" id="cb151" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb151-1" title="1"><span class="dt">int</span> locked_both = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb151-2" title="2"><span class="cf">while</span>( locked_both == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb151-3" title="3">  <span class="dt">int</span> locked1 = pthread_mutex_trylock( chopstick1 );</a>
<a class="sourceLine" id="cb151-4" title="4">  <span class="dt">int</span> locked2 = pthread_mutex_trylock( chopstick2 );</a>
<a class="sourceLine" id="cb151-5" title="5">  <span class="cf">if</span> (locked1 != <span class="dv">0</span> &amp;&amp; locked2 == <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb151-6" title="6">    pthread_mutex_unlock( chopstick2 );</a>
<a class="sourceLine" id="cb151-7" title="7">  } <span class="cf">else</span> <span class="cf">if</span> (locked1 == <span class="dv">0</span> &amp;&amp; locked2 != <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb151-8" title="8">    pthread_mutex_unlock( chopstick1 );</a>
<a class="sourceLine" id="cb151-9" title="9">  } <span class="cf">else</span> <span class="cf">if</span> (locked1 != <span class="dv">0</span> &amp;&amp; locked2 != <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb151-10" title="10">    <span class="co">/* Do nothing */</span></a>
<a class="sourceLine" id="cb151-11" title="11">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb151-12" title="12">    locked_both = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb151-13" title="13">  }</a>
<a class="sourceLine" id="cb151-14" title="14">}</a>
<a class="sourceLine" id="cb151-15" title="15">eat( );</a>
<a class="sourceLine" id="cb151-16" title="16"></a>
<a class="sourceLine" id="cb151-17" title="17">pthread_mutex_unlock( chopstick1 );</a>
<a class="sourceLine" id="cb151-18" title="18">pthread_mutex_unlock( chopstick2 );</a></code></pre></div>
<p>The idea of a process releasing resources that it is holding is the basis for the next solution: knocking down the “no preemption” pillar.</p>
<h5 id="no-preemption.">No Preemption.</h5>
<p>If we violate this condition, it means that we do have preemption: forcible removal of resources from a process, by the operating system. Suppose a process <span class="math inline">P_{1}</span> holds <span class="math inline">R_{1}</span> and <span class="math inline">R_{2}</span> and wants to get <span class="math inline">R_{3}</span>, but <span class="math inline">R_{3}</span> is unavailable. <span class="math inline">P_{1}</span> will be blocked by the operating system. If another process <span class="math inline">P_{2}</span> comes by and requests <span class="math inline">R_{1}</span> and <span class="math inline">R_{2}</span>, the resources <span class="math inline">R_{1}</span> and <span class="math inline">R_{2}</span> are taken away from <span class="math inline">P_{1}</span>. The resources are added to the list of things that <span class="math inline">P_{1}</span> is waiting for (so it is waiting for all three now). In the meantime, <span class="math inline">P_{2}</span> can use them and continue. <span class="math inline">P_{1}</span> will be unblocked when all three resources are once again available for it to acquire <span class="citation" data-cites="osc"></span>.</p>
<p>This isn’t really something we can do as program designers, because only the operating system really has the power to carry out. It’s included for completeness, but is not anything we can actually implement ourselves.</p>
<p>For preemption to work, however, the resource must be a resource of a type where the state can be saved and restored (e.g., the CPU with its registers). This is not applicable to all resources; if a printer is in use by <span class="math inline">P_{1}</span> it cannot be preempted and given to <span class="math inline">P_{2}</span>, otherwise the printout will be a jumble. Thus, preemption is also not sufficient to prevent deadlock from ever transpiring, it once again only makes it less likely.</p>
<h1 id="deadlock-avoidance" class="unnumbered">20 — Deadlock Avoidance</h1>
<h2 id="dealing-with-deadlock-1" class="unnumbered">Dealing with Deadlock</h2>
<h3 id="deadlock-option-3-deadlock-avoidance" class="unnumbered">Deadlock Option 3: Deadlock Avoidance</h3>
<p>In examining deadlock prevention, we were attempting to rule deadlock out categorically by eliminating one of the three preconditions for deadlock to be possible. If successful, then we can be sure that deadlock does not occur. Unfortunately, eliminating the pillars came with some conditions and the best we could accomplish was merely making deadlock less likely and not resolving the problem in its entirety. Thus, we are forced to live with a system where a deadlock is possible. However, deadlock being possible is not the same thing as deadlock being inevitable; we can take steps to avoid it if there is a danger of it actually happening. The basic strategy is: do not allow a cycle in the resource allocation graph.</p>
<p>In the dining philosophers problem, one strategy to prevent the deadlock was limiting the number of concurrently-eating philosophers to four, even though the table has five seats. This was a way of preventing a cycle in the resource allocation graph: with only four philosophers and five chopsticks, there were insufficient requests to complete a cycle. This solution is suitable, but not necessarily generalizable to all deadlock situations.</p>
<h4 id="ordering-of-resources" class="unnumbered">Ordering of Resources</h4>
<p>A general strategy to prevent a cycle from forming is to impose ordering on resource requests. Resources are given some order and requests must follow that order. This idea may have occurred seemed obvious from this example:</p>
<p><span>2</span>
<strong>Thread P</strong></p>
<pre><code>     1. wait( a ) 
     2. wait( b )
     3. [critical section]
     4. post( a )
     5. post( b )</code></pre>
<p><strong>Thread Q</strong></p>
<pre><code>     1. wait( b ) 
     2. wait( a )
     3. [critical section]
     4. post( b )
     5. post( a )</code></pre>
<p>Thread <span class="math inline">Q</span> requests <code>b</code> first and then <code>a</code>, while <span class="math inline">P</span> does the reverse. The deadlock would not take place if both threads requested these two resources in the same order, whether <code>a</code> then <code>b</code> or <code>b</code> then <code>a</code>. Of course, when they have names like this, a natural ordering (alphabetical, or perhaps reverse alphabetical) is obvious.</p>
<p>To generalize and formalize this principle, if the set of all resources in the system is <span class="math inline">R = \{R_{0}, R_{1}, R_{2}, ... R_{m}\}</span>, we assign to each resource <span class="math inline">R_{k}</span> a unique integer value. Let us define this function as <span class="math inline">f(R_{i})</span>, that maps a resource to an integer value. This integer value is used to compare two resources: if a process has been assigned resource <span class="math inline">R_{i}</span>, that process may request <span class="math inline">R_{j}</span> only if <span class="math inline">f(R_{j}) &gt; f(R_{i})</span>. Note that this is a strictly greater-than relationship; if the process needs more than one of <span class="math inline">R_{i}</span> then the request for all of these must be made at once (in a single request). To get <span class="math inline">R_{i}</span> when already in possession of a resource <span class="math inline">R_{j}</span> where <span class="math inline">f(R_{j}) &gt; f(R_{i})</span>, the process must release any resources <span class="math inline">R_{k}</span> where <span class="math inline">f(R_{k}) \geq f(R_{i})</span>. If these two protocols are followed, then a circular-wait condition cannot hold <span class="citation" data-cites="osc"></span>.</p>
<p>In the dining philosophers problem, we assign each of the five chopsticks a number from 0 to 4. Each philosopher must then request them in ascending order. The first philosopher requests chopstick 0, on her left, and then chopstick 1, on her right. The second requests chopstick 1 and then chopstick 2. This continues until the last philosopher who would previously have requested chopstick 4 and then 0, but under the new rules, this is forbidden. This philosopher must instead request 0 on his right, and then 4, on his left. This last philosopher will be blocked when trying to acquire chopstick 0 and it means chopstick 4 will be available for the second-to-last philosopher. Thus, deadlock is avoided.</p>
<p>In <span class="citation" data-cites="osc"></span> is a proof that ordering the resources prevents deadlock. The approach is proof by contradiction: assume a circular wait is present. Let the set of processes in the circular wait be <span class="math inline">\{P_{0}, P_{1}, ... P_{n}\}</span> and the set of resources be <span class="math inline">\{R_{0}, R_{1}, ... R_{n}\}</span>. The cycle is formed as: <span class="math inline">P_{i}</span> is waiting for resource <span class="math inline">R_{i}</span> and that resource is held by <span class="math inline">P_{i+1}</span>. The exception is the case of <span class="math inline">P_{n}</span>, which is waiting for resource <span class="math inline">R_{n}</span> that is held by <span class="math inline">P_{0}</span> (completing the cycle by wrapping around). Since Process <span class="math inline">P_{i+1}</span> holds resource <span class="math inline">R_{i}</span> while requesting <span class="math inline">R_{i+1}</span>, this means <span class="math inline">f(R_{i}) &lt; f(R_{i+1})</span> for all <span class="math inline">i</span>. But this means that <span class="math inline">f(R_{0}) &lt; f(R_{1}) &lt; ... &lt; f(R_{n}) &lt; f(R_{0})</span>. It cannot be the case that <span class="math inline">f(R_{0}) &lt; f(R_{0})</span>: a contradiction, meaning a circular wait cannot occur.</p>
<p>In development this is usually enforced just by coding convention and code review. If you say that mutexes must always be acquired in alphabetical order (or their order in some file), if everyone sticks to that there will be no issue. Sometimes it’s not that simple, though, because one mutex can be pointed to by two pointers... which name is the correct one?</p>
<h4 id="stay-alert-stay-safe" class="unnumbered">Stay Alert, Stay Safe<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></h4>
<p>Suppose that instead of ordering the resources, each process will need to give the operating system some additional information about what resources might be requested. Processes need to say in advance of execution what is the maximum number of resources of each type they might conceivably need. In a system with a tape drive and printer, perhaps process <span class="math inline">A</span> needs the tape drive first, then the printer, and process <span class="math inline">B</span> needs the printer and then the tape drive. With this knowledge, the system can make more intelligent decisions about when to run a process or make it wait, to avoid getting into a deadlock <span class="citation" data-cites="osc"></span>.</p>
<p>We say a state is <em>safe</em> if there is some scheduling order in which every process can run to completion even if all of them suddenly request their maximum resources immediately <span class="citation" data-cites="mos"></span>. Hence why we needed to know in advance the maximum resources that could be required by the process.</p>
<p>More formally, there must exist a <em>safe sequence</em>: a sequence of processes <span class="math inline">&lt;P_{1}, P_{2}, ... P_{n}</span> is a safe sequence in the current allocation state if, for each <span class="math inline">P_{i}</span> the resource requests that <span class="math inline">P_{i}</span> can still make can be satisfied by the currently available resources plus resources held by <span class="math inline">P_{j}</span> where <span class="math inline">j &lt; i</span>. If a resource <span class="math inline">P_{i}</span> needs is not currently available, <span class="math inline">P_{i}</span> can wait until all <span class="math inline">P_{j}</span> have finished and releases its resources. When <span class="math inline">P_{i}</span> terminates, <span class="math inline">P_{i+1}</span> can obtain its needed resources and continue <span class="citation" data-cites="osc"></span>.</p>
<p>Any state that is not safe is considered <em>unsafe</em>. If the system is in a safe state, then there is no deadlock. Being in an unsafe state does not mean that there is a deadlock, but it means a deadlock is possible. The analysis we do is the worst case scenario: every process immediately requests the maximum resources it could ever use. Perhaps the processes do not make those requests in reality.</p>
<p>Consider an example from <span class="citation" data-cites="mos"></span> in which there are three processes, <span class="math inline">A</span>, <span class="math inline">B</span>, and <span class="math inline">C</span>. Assume there is only one resource, and a maximum of 10 instances exist. Suppose <span class="math inline">A</span> has 3 resources but may request up to 9, <span class="math inline">B</span> has 2 and may request up to 4, <span class="math inline">C</span> has 2 and may request up to 7. There are 3 resources currently free. How do we determine that the state described below is safe?</p>
<p><img src="images/safe-state-initial.png" alt="image" style="width:15.0%" /><br />
A diagram representing the resource allocation state of the system <span class="citation" data-cites="mos"></span>.</p>
<p>Recall that for a state to be safe we need only one path that allows all processes to complete. Multiple solutions may exist, and there may be paths that lead to deadlock. But we need only one solution, such as:</p>
<p><img src="images/safe-state.png" alt="image" style="width:75.0%" /><br />
A diagram demonstrating the state in (a) is safe <span class="citation" data-cites="mos"></span>.</p>
<p>The part of the diagram labelled (a) is the initial state of the system. Imagine that process <span class="math inline">B</span> is allowed to run exclusively, until it gets two more resources, so it now has 4 resources and there is one free, as diagram (b) depicts. <span class="math inline">B</span> is allowed to run to completion, and it therefore finishes and releases its resources to the free pool, shown in (c). Then process <span class="math inline">C</span> is scheduled and gets its full complement of resources, consuming all the elements in the free pool, as in (d). <span class="math inline">C</span> runs exclusively until completion and it releases its resources, shown in (e). Finally, <span class="math inline">A</span> is able to get all the resources and run to completion, too. Thus, we proved that the state is safe: there is a way the system can avoid a deadlock, and run all processes to completion.</p>
<p>Suppose, however, <span class="math inline">A</span> requests and gets another resource. In that case, the initial condition has changed so that <span class="math inline">A</span> has 4 resources and there are 2 free resources. Or, in the diagram below, the state changes from (a) to (b).</p>
<p><img src="images/unsafe-state-initial.png" alt="image" style="width:35.0%" /><br />
A diagram representing the updated resource allocation state of the system <span class="citation" data-cites="mos"></span>.</p>
<p>Given this new initial state (b), we need to evaluate if it is safe.</p>
<p><img src="images/unsafe-state.png" alt="image" style="width:70.0%" /><br />
A diagram demonstrating the state of <span class="citation" data-cites="mos"></span>.</p>
<p>Let us start by attempting to run <span class="math inline">A</span> - there are 3 free resources and <span class="math inline">A</span> would need 6 to continue (because a process immediately takes its full resources when it runs), so it cannot run to completion. The same is true for <span class="math inline">C</span> - it needs 5 additional resources when 3 are available. <span class="math inline">B</span>, however, can continue: it needs 2 resources when 3 are available. If we attempt to run <span class="math inline">B</span> exclusively, it gets its full resources, shown in part (c), and then will terminate and release its resources, as in (d). At this point, however, there is no way to continue; neither <span class="math inline">A</span> nor <span class="math inline">C</span> can get the full complement of resources it might need because there are only 4 free resources. We are out of options; there is no path that guarantees all processes run to completion. Thus, the state is unsafe.</p>
<p>Remember that just because the state is unsafe, does not mean that deadlock is present or certain. The analysis is worst-case: <span class="math inline">C</span> may never need all 7 of the resource and may run to completion with its current 2. However, in an unsafe state, we cannot be certain that deadlock will not occur.</p>
<h5 id="resource-allocation-graph-algorithm.">Resource-Allocation-Graph Algorithm.</h5>
<p>The fourth condition for deadlock is modelled, typically as being a resource allocation graph with a cycle in it. Idea: let us use that idea to avoid deadlock by having the operating system maintain a resource allocation graph. This is applicable if there is only one instance of each resource and still requires that all the resources that a process will require must be declared in advance. However, this condition does not have to be strictly adhered to, if the system allows additional requests only when none of the process’s requests have yet been made.</p>
<p>The model for resource allocation graphs earlier had two kinds of edges: one representing requests (a process requests a resource) and one representing allocation (a resource currently belongs to a process). We will require a new type of edge in the graph: a <em>claim</em> edge, as a way of indicating a process may request a resource at some time in the future, and it is drawn with a dashed line. When the process actually makes the request for the resource, a claim edge is converted to a request edge, and upon release the assignment edge reverts to a claim edge <span class="citation" data-cites="osc"></span>.</p>
<p><img src="images/resource-allocation-graph-claim.png" alt="image" style="width:25.0%" /><br />
A resource allocation graph showing claim edges <span class="citation" data-cites="osc"></span>.</p>
<p>A resource request will only be granted if converting the request edge to an assignment edge will not result in a cycle in the graph. There are graph algorithms in code that can be used to detect a cycle (and you may have studied them in a data structures and algorithms class). If no cycle is found, then allocation of the resource will not move the system into an unsafe state. If a cycle is found, the request should not be granted, as it risks a deadlock.</p>
<p>As mentioned, this is applicable only if all resource requests are known in advance and there is only one instance of each resource.</p>
<h5 id="the-bankers-algorithm.">The Banker’s Algorithm.</h5>
<p>The banker’s algorithm is more general: it allows for resources with multiple instances. It received this name because it is hypothetically an algorithm that a small town banker might follow if he or she were trying to prevent allocating the cash on hand in such away that he or she could no longer satisfy customers<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>. Banks typically lend out more money than they have on hand on the (usually-correct) theory that not everyone will come asking for all their deposits all at once<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<p>In fact, the analysis we did earlier to determine if a state is safe or unsafe, is the foundation of the banker’s algorithm. Recall this diagram from earlier:</p>
<p><img src="images/unsafe-state-initial.png" alt="image" style="width:35.0%" /><br />
A diagram representing the updated resource allocation state of the system <span class="citation" data-cites="mos"></span>.</p>
<p>Granting the request from process <span class="math inline">A</span>, the transition from (a) to (b), moved the system from a safe state to an unsafe state. The operating system, when it receives a resource request, will evaluate the new state to see if it would transition the system to an unsafe state. If it would result in that transition, the request will be denied or <span class="math inline">A</span> will be blocked until the request can be fulfilled without putting the system in an unsafe state. Holding to this condition means deadlock will be avoided.</p>
<p>The banker’s algorithm can accommodate multiple resources, as shown in the diagram below.</p>
<p><img src="images/bankers-multiple.png" alt="image" style="width:60.0%" /><br />
The banker’s algorithm with multiple resources <span class="citation" data-cites="mos"></span>.</p>
<p>The left matrix shows the current state of assigned resources and the matrix on the right shows the maximum number of resources that a process might need to complete execution. At the far right of the diagram is a series of vectors: <span class="math inline">E</span> for the existing resources, <span class="math inline">P</span> for the resources some process currently possesses, and <span class="math inline">A</span> for the available instances of that resource.</p>
<p>The informal approach for checking if a state is safe is described by <span class="citation" data-cites="mos"></span>:</p>
<ol>
<li><p>Look for a row in the matrix, <span class="math inline">r</span>, where the unmet resource needs are less than or equal to the available resources in <span class="math inline">A</span>. If no such row exists, the system state is unsafe.</p></li>
<li><p>Assume the process from <span class="math inline">r</span> gets all the resources it needs. Mark that process as terminated and put all its resources into <span class="math inline">A</span>, the available pool.</p></li>
<li><p>Repeat steps 1 and 2 until either: (i) all processes are marked terminated and the initial state was safe; or (ii) no process remains whose needs can be met and the initial state is unsafe.</p></li>
</ol>
<p>If more than one process may be chosen in step 1, it does not matter which we choose: the pool of available resources will either stay the same or get larger; it cannot shrink.</p>
<p>To determine if granting a resource will make the system unsafe, the operating system should simply perform a what-if calculation. Assume the resource is granted and do the safe state calculation given that new state. If the result is that the state is unsafe, the request should be deferred or denied.</p>
<p>A formal, mathematical description of the banker’s algorithm is defined in <span class="citation" data-cites="osc"></span>.</p>
<p>As great as the banker’s algorithm is in theory, in practice it is utterly useless, as highlighted by <span class="citation" data-cites="mos"></span>. Processes rarely know in advance what their maximum resource needs will be. Also, the number of processes is not fixed, but varies as users log in and launch and close programs and log out. Finally, a resource that was thought to be available can suddenly vanish (a peripheral device is disconnected, the network goes down, a printer breaks...). Thus in practice, the banker’s algorithm can almost never be used.</p>
<h1 id="deadlock-detection-recovery" class="unnumbered">21 — Deadlock Detection &amp; Recovery</h1>
<h2 id="deadlock-detection" class="unnumbered">Deadlock Detection</h2>
<p>Thus far we have examined several ways to prevent or avoid deadlock, but all of those solutions have come with significant drawbacks or limitations. Avoidance analyses are also conservative; they will prevent a request from taking place if there is even a small chance it could lead to a deadlock. If we cannot stop deadlock from happening or cannot live with the performance reduction that avoidance mandates, then perhaps the next best thing is to let all resource requests proceed and then determine later if a deadlock exists, and if so, do something about it.</p>
<p>The truth is that the operating system is in the best position to detect if there is a deadlock, but commercial operating systems don’t do that. We can do it ourselves in our program using some of the following techniques but we almost certainly won’t have the full picture. This is because we cannot see what’s going on inside other processes or inside the kernel. But we will do our best under the circumstances, if we need to.</p>
<p>The basic strategy for deadlock detection is like the deadlock avoidance strategy in that it relies on a model of the resource allocation and requests. If resources have only a single instance, we may reduce the graph to a simplified version called the <em>wait-for</em> graph. This removes the resource boxes from the diagram and indicates that a process <span class="math inline">P_{i}</span> is waiting for process <span class="math inline">P_{j}</span> rather than for a resource <span class="math inline">R_{k}</span> that happens to be held by <span class="math inline">P_{j}</span>. An edge <span class="math inline">P_{i} \rightarrow P_{j}</span> exists in the wait-for graph if and only if the resource allocation graph has a request <span class="math inline">P_{i} \rightarrow R_{k}</span> and an assignment edge <span class="math inline">R_{k} \rightarrow P_{j}</span> <span class="citation" data-cites="osc"></span>. Consider the example below:</p>
<p><img src="images/rag-waitfor.png" alt="image" style="width:50.0%" /><br />
(a) A resource allocation graph and (b) its corresponding wait-for graph <span class="citation" data-cites="osc"></span>.</p>
<p>Given the wait-for graph, it is trivial for humans to look at this and determine if there is a cycle, but for the computer it takes slightly more work. We must execute an algorithm to determine if there is a cycle. A cycle exists in the wait for graph if and only if a deadlock exists in the system. Such cycle detection algorithms tend to have runtime characteristics of <span class="math inline">\Theta(n^{2})</span> where <span class="math inline">n</span> is the number of nodes in the graph. Though not a formal proof and probably not acceptable to write on a data structures and algorithms examination, the premise of the algorithm is: for each node <span class="math inline">n</span> in the graph, examine each possible path from that node. If a node is reached from which no further path is available, examine the next path. If node <span class="math inline">n</span> is reached on the current path, a cycle is detected and the algorithm terminates.</p>
<h3 id="general-deadlock-detection-algorithm" class="unnumbered">General Deadlock Detection Algorithm</h3>
<p>We will use the general deadlock detection algorithm from <span class="citation" data-cites="mos"></span> that allows for multiple resources of each type. In this algorithm, there are <span class="math inline">n</span> processes numbered <span class="math inline">P_{1}</span> through <span class="math inline">P_{n}</span> and <span class="math inline">m</span> resources. Resources are represented by two vectors: <span class="math inline">E</span>, the existing resource vector – the total number of instances of each resource; and <span class="math inline">A</span>, the available resource vector – how many instances of each resource are currently available (not assigned to a process). If resource <span class="math inline">i</span> has two instances total and one is currently assigned to a process, <span class="math inline">E_{i}</span> is 2 and <span class="math inline">A_{i}</span> is 1.</p>
<p>We need two matrices to represent the current situation of the system. The first is <span class="math inline">C</span>, the current allocation; it contains data about what resources are currently assigned to each process. Thus, row <span class="math inline">i</span> of <span class="math inline">C</span> shows how many of each resource <span class="math inline">P_{i}</span> has. The second matrix is <span class="math inline">R</span>, the request matrix. Row <span class="math inline">i</span> of this matrix shows how many of each resource <span class="math inline">P_{i}</span> wants. Thus, <span class="math inline">C_{ij}</span> shows the number of instances of resource <span class="math inline">j</span> that <span class="math inline">P_{i}</span> has and <span class="math inline">R_{ij}</span> shows the number of instances of resource <span class="math inline">j</span> that <span class="math inline">P_{i}</span> wants. Or, to show what those look like:</p>
<p><span>2</span></p>
<p><span class="sans-serif">Resources in Existence</span><br />
<span class="math inline">[E_{1}, E_{2}, ..., E_{m}]</span></p>
<p><span class="sans-serif">Current Allocations</span>
<span class="math display">\left[ {\begin{array}{cccc}
                            C_{11} &amp; C_{12} &amp; ... &amp; C_{1m} \\
                            C_{21} &amp; C_{22} &amp; ... &amp; C_{2m} \\
                            \vdots &amp; \vdots &amp;     &amp; \vdots \\
                            C_{n1} &amp; C_{n2} &amp; ... &amp; C_{nm}
                        \end{array} } \right]</span></p>
<p><span class="sans-serif">Resources Available</span><br />
<span class="math inline">[A_{1}, A_{2}, ..., A_{m}]</span></p>
<p><span class="sans-serif">Requests</span>
<span class="math display">\left[ {\begin{array}{cccc}
                            R_{11} &amp; R_{12} &amp; ... &amp; R_{1m} \\
                            R_{21} &amp; R_{22} &amp; ... &amp; R_{2m} \\
                            \vdots &amp; \vdots &amp;     &amp; \vdots \\
                            R_{n1} &amp; R_{n2} &amp; ... &amp; R_{nm}
                        \end{array} } \right]</span></p>
<p>Note that at all times a resource is considered either allocated or available. This means this mathematical relationship always holds:</p>
<p><span class="math inline">\sum\limits_{i=1}^n C_{ij} + A_{j} = E_{j}</span>.</p>
<p>There is one more bit of setup before we are ready to run the algorithm. The key idea is comparison of vectors, so let us define for notational convenience, the idea of “less than” for two vectors. We will say that for two vectors <span class="math inline">A</span> and <span class="math inline">B</span> of length <span class="math inline">m</span>, <span class="math inline">A \leq B</span> means that <span class="math inline">A_{i} \leq B_{i}</span> for all <span class="math inline">i</span> from 1 to <span class="math inline">m</span>.</p>
<p>At last, the algorithm. The starting condition is that all processes are unmarked and the vectors and matrices described above are populated. The algorithm will go through all processes and determine if they can complete, under worst-case conditions (keeping all resources until termination), and if they can, marks them. At the end, any processes that are not marked are deadlocked.</p>
<ol>
<li><p>Search for an unmarked process whose requests can all be satisfied with the available resources in <span class="math inline">A</span>. Mathematically: find a process <span class="math inline">P_{i}</span> such that row <span class="math inline">R_{i} \leq A</span>.</p></li>
<li><p>If a process is found, add the allocated resources of that process to the available vector and mark the process. Mathematically: <span class="math inline">A = A + C_{i}</span>. Go back to step 1.</p></li>
<li><p>If no process was found in the search of step 1, the algorithm terminates.</p></li>
</ol>
<p>This approach is similar to the banker’s algorithm. Step one looks for a process that can run to completion, and we are certain it will be able to do so because the currently available resources equal or exceed its needs. That process can finish, and when it does so, its currently-held resources are released and available for another process to acquire. Step two reflects this by adding the resources it holds to the available set. Then another process is selected. At the end, either all processes can finish and there is no deadlock, or there is a set of processes (at least two) that are deadlocked.</p>
<p>This algorithm has a runtime performance characteristic of <span class="math inline">\Theta(m \times n^{2})</span>.</p>
<h5 id="deadlock-detection-algorithm-example.">Deadlock Detection Algorithm Example.</h5>
<p>Let’s now use this algorithm on an example also from <span class="citation" data-cites="mos"></span>. Let us assume we have 4 types of resources and 3 processes. The names and types of the resources do not matter - they can be anything - all that matters are the numbers. Each process has some resources currently allocated to it, and each process has some requests outstanding. Thus, the initial state of the system is:</p>
<p><span>2</span></p>
<p><span class="math inline">E = [4, 2, 3, 1]</span>
<span class="math display">C =
            \left[ {\begin{array}{cccc}
                            0 &amp; 0 &amp; 1 &amp; 0 \\
                            2 &amp; 0 &amp; 0 &amp; 1 \\
                            0 &amp; 1 &amp; 2 &amp; 0 \\
                        \end{array} } \right]</span></p>
<p><span class="math inline">A = [2, 1, 0, 0]</span>
<span class="math display">R =
            \left[ {\begin{array}{cccc}
                            2 &amp; 0 &amp; 0 &amp; 1 \\
                            1 &amp; 0 &amp; 1 &amp; 0 \\
                            2 &amp; 1 &amp; 0 &amp; 0
                        \end{array} } \right]</span></p>
<p>Now, carry out the algorithm. The first process cannot proceed because its request <span class="math inline">R_{14}</span> cannot be met; there are no instances of resource 4 available. Process 2 cannot proceed either, because it needs resource 3 and there are none of those available either. Process 3 can run and will eventually return its resources, changing the available vector to <span class="math inline">A = [2, 2, 2, 0]</span>. Mark process 3.</p>
<p>Process 1 still cannot run because its need for resource 4 still cannot be met. Process 2, however, can, and it will do so, returning all its resources. The available vector is changed to <span class="math inline">A = [4, 2, 2, 1]</span>. Mark process 2.</p>
<p>Process 1 can now run. Return its resources: <span class="math inline">A = [4, 2, 3, 1]</span>. Mark process 1.</p>
<p>There are no remaining unmarked processes in the system, and therefore no deadlock. As a sanity check, compare vector <span class="math inline">E</span> and the final values for <span class="math inline">A</span> – they should be the same if there is no deadlock.</p>
<h3 id="when-to-detect-deadlock" class="unnumbered">When to Detect Deadlock</h3>
<p>The runtime characteristic of the simple deadlock detection algorithm was identified as <span class="math inline">\Theta(n^{2})</span>, and the runtime characteristic of the general algorithm was shown as <span class="math inline">\Theta(m \times n^{2})</span> where <span class="math inline">n</span> is the number of processes and <span class="math inline">m</span> is the number of resources in the system. This means that the deadlock detection routine is expensive to execute.</p>
<p>This prompts a question: how often should the deadlock detection algorithm be run? One strategy is to run it every time a resource is requested. Running the algorithm might be rather expensive, so perhaps this is too often. An obvious optimization: it should only run every time a resource request cannot be granted (that is, a process gets blocked). Another idea: run it periodically instead.</p>
<p>When to run the deadlock detection algorithm depends on how often we expect deadlock to occur, and how severe a problem it is when deadlock occurs. If deadlock happens a lot, checking for deadlock often will make sense. If the consequences of a deadlock are severe, it makes sense to check frequently to identify the problem as soon as possible.</p>
<p>Several sources including <span class="citation" data-cites="mos"></span> suggest running the deadlock detection algorithm when CPU utilization is low. This is not only because it would be a bad idea to run an algorithm that is time consuming and computationally expensive while the system is busy. When a deadlock is present in the system, many processes are stuck and cannot proceed, so a drop in CPU usage may be an indication that many processes are deadlocked.</p>
<h2 id="deadlock-recovery" class="unnumbered">Deadlock Recovery</h2>
<p>Once a deadlock has been detected, a system can recover from that deadlock by “breaking” the deadlock. These are called recovery strategies and they are ways the system may automatically deal with the problem. It is possible to have a manual form of deadlock recovery, where an operator is notified and that person is responsible for sorting out the problem, but the manual method needs no further discussion.</p>
<h3 id="recovery-strategies" class="unnumbered">Recovery Strategies</h3>
<p>There are several strategies that we could apply, which we will refer to in humorous terms. All are valid solutions of various complexity. Unfortunately, none of the solutions are particularly pleasant. They can result in data loss, delays in completion of programs, or some other problems. Ideally we would like to break the deadlock with as little disruption as possible, so the strategies that rely on selection of one or more victims should choose carefully. These strategies are not mutually exclusive; an operating system may implement some or all of them.</p>
<h4 id="robbery" class="unnumbered">Robbery</h4>
<p>The strategy of “robbery” is just a humorous way of saying preemption. This is virtually identical to the discussion of knocking down the pillar of deadlock for deadlock prevention; the only difference is that recovery is run only when deadlock is detected. Suppose a process <span class="math inline">P_{1}</span> has a resource <span class="math inline">R_{1}</span> and needs <span class="math inline">R_{2}</span>, while a process <span class="math inline">P_{2}</span> has <span class="math inline">R_{2}</span> and needs <span class="math inline">R_{1}</span>. The operating system may block process <span class="math inline">P_{2}</span> and take away <span class="math inline">R_{2}</span> from <span class="math inline">P_{2}</span> and allow <span class="math inline">P_{1}</span> to have it. After that resource becomes available again, it is returned to <span class="math inline">P_{2}</span>. In the general case, the operating system will take resources from (“rob”) some process(es) and give those resources to other processes until the deadlock cycle is broken. To do so, the operating system needs to choose a victim to rob; a subject we will examine shortly.</p>
<p>The resource should be an appropriate type to be preempted: it must be possible to save and restore the state. Preemption of a printer is not realistic, nor is memory. However, other resources, like a processor or access to the network, may be. If the state of the resource cannot be saved and restored, then preemption is not a good strategy.</p>
<h4 id="mass-murder" class="unnumbered">Mass Murder</h4>
<p>If the operating system detects a deadlock, it may choose to terminate (kill) all the processes involved in the deadlock. This solution is surprisingly common. It is one way to be certain that the deadlock cycle is broken. The resources that these processes were holding will become available. There is no need to determine a victim: kill ’em all and let root sort them out.</p>
<p>This solution, while easy to implement, may not solve the problem, however, as the circumstances that caused the deadlock may occur again if all the processes are restarted. If the deadlock were an unlikely situation caused by “unlucky” timing then it will probably not recur, or at least, will not recur for some time.</p>
<p>If processes <span class="math inline">P_{1}</span> and <span class="math inline">P_{2}</span> are deadlocked, however, is it really necessary to kill both of them? If we killed only one, the other could proceed...</p>
<h4 id="murder" class="unnumbered">Murder</h4>
<p>Perhaps instead of killing all processes involved in a deadlock, the operating system chooses to kill processes selectively. Like preemption, selecting which process is the victim is important. When the victim is killed, its resources are added to the available set and this will hopefully allow other processes to proceed. At this point, the deadlock detection algorithm must run again to determine if a deadlock still exists; if not the problem is dealt with, but if so, this strategy needs to be repeated (select a new victim, kill it, free up its resources, and determine if deadlock is still present) again and again until the logjam is broken.</p>
<h4 id="time-travel" class="unnumbered">Time Travel</h4>
<p>Time travel is just a clever way of saying <em>rollback</em>: returning the state of a process to a saved state from an earlier time. To do so, of course, there must be a saved state that was created in advance of a problem (otherwise there is no state to roll back to...). The saved state is called a <em>checkpoint</em> and the act of creating and saving a checkpoint is called <em>checkpointing</em><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>. Checkpoints may be created periodically or before beginning a particular operation that requires a lot of resources.</p>
<p>A checkpoint contains the memory image, including the call stack, and resource state of a process. It is written to disk and will usually persist as long as the process continues to execute.</p>
<p>You might already be somewhat familiar with the concept of rollbacks if you have used version control software like Subversion (<code>svn</code>) or Git (<code>git</code>). A previous state of the source code is saved and if a developer commits a change that is detrimental to the software, that change can easily be undone by reverting the state of the source files to an earlier version. Rollbacks are also common in databases; if an attempted modification of a database record fails for some reason, such as data being too long for a field, then the state of the database is restored to what it was before the attempted change.</p>
<p>Unfortunately, rollback does not always succeed. Sometimes moving the process back to an earlier state just moves it a few steps back on the same road that leads to the deadlock. Or a different ordering of events and resource requests may avoid the deadlock entirely. Rollback may be attempted a few times before giving up and trying another strategy.</p>
<h4 id="armageddon" class="unnumbered">Armageddon</h4>
<p>Armageddon - the end of the world. If a deadlock has occurred, sometimes the best thing to do is reboot the system. This has a side effect of killing all processes, whether they are stuck or not, but is sometimes the best way to make sure that the system is in a valid state. NASA’s Spirit rover, one of the missions to explore the red planet, relies on this strategy if it detects a deadlock. Like killing all affected processes, it is easy to implement, but is most disruptive.</p>
<h3 id="victim-selection" class="unnumbered">Victim Selection</h3>
<p>If we have to choose a victim process for one of the strategies, e.g., termination, then we need a strategy for which process to choose. We could choose randomly: kill a process and hope that that was enough. Sometimes this will work, because it breaks the deadlock and the other processes can all proceed. In general, however, making an informed decision is better.</p>
<p>Note that it is, strictly speaking, not necessary to choose one of the processes involved in the deadlock. For example, if <span class="math inline">P_{1}</span> and <span class="math inline">P_{2}</span> are deadlocked, a process <span class="math inline">P_{3}</span> may have an instance of a resource that <span class="math inline">P_{1}</span> needs, and killing <span class="math inline">P_{3}</span> will allow both <span class="math inline">P_{1}</span> and <span class="math inline">P_{2}</span> to proceed.</p>
<p>We can think of this as kind of an optimization problem. Define a cost function for choosing each process, evaluate the cost function, and then choose the lowest cost. Some factors to consider in selection of processes <span class="citation" data-cites="osc"></span>:</p>
<ol>
<li><p>The priority of the process.</p></li>
<li><p>How long the process has been executing.</p></li>
<li><p>How long is remaining in execution, if known.</p></li>
<li><p>What resources the process has (number and type).</p></li>
<li><p>Future resource requests, if known.</p></li>
<li><p>Whether the process is user-interactive or in the background.</p></li>
<li><p>How many times, if any, the process has been selected as a victim.</p></li>
</ol>
<p>These sorts of selection routines tend to favour older processes rather than younger ones. This is not because older processes vote in higher numbers, but because it tends to be more expensive to restart an older process. A process that has been running for a long time, if it is restarted, has to do a lot more work to get to the point where it was terminated than a younger process. Another reason: if the oldest process were constantly the one selected, that process itself might never get to run to completion (starvation) because it is constantly killed before it finishes. A third reason is somewhat more subtle: if the killing process is very aggressive then perhaps no tasks run to completion because each process, shortly after becoming the oldest, is claimed by the deadlock recovery process. Therefore, young processes tend to be the ones selected.</p>
<p>The final element in the list, keeping track of how many times a process has been victimized, is also there to prevent starvation. The selection process very likely produces the same or similar results each time it is run, so it may happen that the same process is selected over and over again. It may be advisable to take the number of rollbacks or terminations into account so that no process in particular is starved.</p>
<h3 id="miscarriages-of-justice" class="unnumbered">Miscarriages of Justice</h3>
<p>The deadlock detection algorithm we have chosen tends to be conservative in that it will err on the side of saying that there is a deadlock. This is because the worst case is assumed: that processes take resources and keep them until the end of their execution. In practice, however, processes will release resources (or at least they should!) so we might detect a deadlock when there is none. We may also, then, kill an innocent process in a system that is not actually deadlocked. Oops!</p>
<p>It turns out that our deadlock detection algorithms do not have to be perfect if we have chosen an appropriate recovery strategy. If killing the process and restarting it does not have unexpected side effects (like asking the user the same question a second time), then being selected does not have an impact on the correctness of the program; just on how long it takes to execute. Suppose the process is a compiler. It reads the source files, processes that input, and produces the binary output file. If partway through, this task is terminated and has to start again, it takes slightly longer for the compile to finish, but there is no impact on the correctness of the binary.</p>
<h1 id="advanced-concurrency-problems" class="unnumbered">22 — Advanced Concurrency Problems</h1>
<h2 id="get-a-pizza-this" class="unnumbered">Get a Pizza This!</h2>
<p>Let’s consider a more advanced concurrency problem. In <span class="citation" data-cites="lbs"></span> it’s called the “Cigarette Smokers Problem”, but smoking is bad for you so it’s going to be the “Pizza Makers Problem”. Pizza, while not exactly health food, is amazing. Delicious, delicious pizza.</p>
<p>A new show to be hosted by some famous TV chef personality is being pitched, and you’re going to write a simulation of it. The show is about making pizza. A pizza requires three ingredients: dough, sauce, and cheese. All three ingredients are necessary to make a pizza (otherwise it does not meet the definition of a pizza).</p>
<p>Each contestant has an unlimited supply of one ingredient. Contestant A has an unlimited supply of dough, Contestant B has an unlimited supply of sauce, and Contestant C has an unlimited supply of cheese. Each contestant needs to get the two ingredients they do not have and then can make a pizza. They will continue to (try to) make pizza in a loop until time is up. At the beginning of the episode, the host places two different random ingredients out. Contestants can signal the host to ask for more ingredients, but they should not do so unless they actually need some. Each time the host is woken up (signalled), he again places two different random ingredients out. When an ingredient is placed on the table, the host posts on the associated semaphore. For example, if the host puts out cheese and sauce, then the host posts on both <code>cheese</code> and <code>sauce</code>.</p>
<p>In this scenario, there are resources provided by some external system and the contestants are processes that want resources. But we shouldn’t be wasteful: resources should only be requested when they are needed and processes should take only what they need. Applications should only wake up if they can do something useful.</p>
<p>There are some restrictions, though, and they could make the problem either impossible or trivial. In the impossible version, you can’t modify what the host does (which is sensible, because you don’t control the other system) but you also cannot use conditional (if) statements, which is pretty ridiculous. In the trivial version, the host tells which contestants whose turn it is, which is boring but also unrealistic, because again it requires the host system to know too much about the contestants. The interesting version has just the restriction that we can’t control the host behaviour <span class="citation" data-cites="lbs"></span>. And he is a TV chef personality, after all, they do wacky things.</p>
<p>Consider the following solution. All semaphores start at 0, except for <code>host</code> which starts as 1 (so the host will run the first time). Does this work?</p>
<p><span>3</span>
<strong>Contestant A</strong></p>
<pre><code>wait( sauce )
get_sauce()
wait( cheese )
get_cheese()
make_pizza( )
post( host )</code></pre>
<p><strong>Contestant B</strong></p>
<pre><code>wait( dough )
get_dough()
wait( cheese )
get_cheese()
make_pizza( )
post( host )</code></pre>
<p><strong>Contestant C</strong></p>
<pre><code>wait( sauce )
get_sauce()
wait( dough )
get_dough()
make_pizza( )
post( host )</code></pre>
<p>No. Deadlock can easily occur. Suppose the host puts out sauce and dough. If contestant B takes the dough and contestant A takes the sauce, then both of them are blocked and nobody can proceed and nobody gets pizza.</p>
<p>Part of the problem here is that a contestant doesn’t have a good way to assess what the ingredients are before going up there. And once there, if it finds that the ingredients match someone else’s needs, we don’t call that contestant over. That would be clever, but to make this work we would need a way to “check” what ingredients are there and semaphores don’t let us do that. If we want to do that, we’d have to break the rule about not modifying the host’s behaviour. Can we work with what we have?</p>
<p>Imagine now that each contestant gets a helper. The job of the helper is to, well, help their contestant to make pizza by figuring out whose turn it is. For this there are boolean variables <code>dough_present</code>, <code>sauce_present</code>, and <code>cheese_present</code> that are all initialized to <code>false</code>. They are protected by a semaphore (called <code>mutex</code>). The helpers update that variable, and based on the information available, signal which contestant should come up to the table and take ingredients. Each contestant now has a semaphore (such as <code>contestantA</code> for contestant A) which the helpers will post on. Contestants are still responsible for telling the host to put out more ingredients.</p>
<p><span>3</span>
<strong>Helper 1</strong></p>
<pre><code>wait( sauce )
wait( mutex )
if dough_present  
  dough_present = false;
  post( contestantC )
else if cheese_present
  cheese_present = false;
  post( contestantA )
else
  sauce_present = true;
end if  
post( mutex )</code></pre>
<p><strong>Helper 2</strong></p>
<pre><code>wait( dough )
wait( mutex )
if sauce_present  
  sauce_present = false;
  post( contestantC )
else if cheese_present
  cheese_present = false;
  post( contestantB )
else
  dough_present = true;
end if  
post( mutex )</code></pre>
<p><strong>Helper 3</strong></p>
<pre><code>wait( cheese )
wait( mutex )
if dough_present  
  dough_present = false;
  post( contestantB )
else if sauce_present
  sauce_present = false;
  post( contestantA )
else
  cheese_present = true;
end if  
post( mutex )</code></pre>
<p>So let’s analyze Helper 1. Each of the other helpers does the same thing but for a different ingredient. In this case, the helper is woken up when sauce is placed on the table. It then locks the mutex so that it can manipulate the shared variables of what ingredients are present. Now we decide what to do here. If the current helper is the first one to run, then all the variables will be false, so we’ll end up at the else block and just set <code>sauce_present</code> to true and then let the next helper run. If <code>dough_present</code> is true, then Helper 2 has already run and we know that dough is present on the table. With both sauce and dough present, we know that the ingredients present match the needs of Contestant C. If <code>cheese_present</code> is true then Helper 3 has already run and the ingredients present match the needs of Contestant A.</p>
<p>Obviously, each of the other helpers will signal the appropriate contestant based on its assessment of the state of the ingredients.</p>
<p><span>3</span>
<strong>Contestant A</strong></p>
<pre><code>wait( contestantA )
get_sauce()
get_cheese()
make_pizza( )
post( host )</code></pre>
<p><strong>Contestant B</strong></p>
<pre><code>wait( contestantB )
get_dough()
get_cheese()
make_pizza( )
post( host )</code></pre>
<p><strong>Contestant C</strong></p>
<pre><code>wait( contestantC )
get_sauce()
get_dough()
make_pizza( )
post( host )</code></pre>
<p>The contestant code is pretty much trivial now: wait until a helper signals, then go take your ingredients and make a pizza. Once the pizza is in the oven, indicate that you are ready for more ingredients.</p>
<p>The generalized version of the problem is what happens when the host puts out ingredients periodically, without a need to be signalled to ask for more. How do we modify the solution to deal with that?</p>
<p>Obviously if there is no longer a need for the contestants to signal that they want more resources then the <code>post( host )</code> statements in the contestant code has to be removed. But what about the helpers?</p>
<p>Instead of boolean variables to indicate the presence or absence of an ingredient what we need instead is an integer counter to know how many there are. So let’s call them <code>num_dough</code>, <code>num_sauce</code>, and <code>num_cheese</code>, and they all start as zero.</p>
<p><span>3</span>
<strong>Helper 1</strong></p>
<pre><code>wait( sauce )
wait( mutex )
if num_dough &gt; 0  
  num_dough--
  post( contestantC )
else if num_cheese &gt; 0
  num_cheese--
  post( contestantA )
else
  num_sauce++
end if  
post( mutex )</code></pre>
<p><strong>Helper 2</strong></p>
<pre><code>wait( dough )
wait( mutex )
if num_sauce &gt; 0  
  num_sauce--
  post( contestantC )
else if num_cheese &gt; 0
  num_cheese--
  post( contestantB )
else
  num_dough++
end if  
post( mutex )</code></pre>
<p><strong>Helper 3</strong></p>
<pre><code>wait( cheese )
wait( mutex )
if num_dough &gt; 0 
  num_dough--
  post( contestantB )
else if num_sauce &gt; 0
  num_sauce--
  post( contestantA )
else
  num_cheese++
end if  
post( mutex )</code></pre>
<p>Now instead of setting the variables to true and false, the variables tracking the ingredients are incremented and decremented. Otherwise not much has changed. This pattern is referred to as the “scoreboard” <span class="citation" data-cites="lbs"></span> – there are variables keeping track of the state of the system which are viewable from all threads. As threads go about their actions, they take a look at the current state (the scoreboard) and decide how to act based on that.</p>
<h2 id="the-barbershop-problem" class="unnumbered">The Barbershop Problem</h2>
<p>Consider the “Barbershop Problem”, originally proposed by Dijkstra. A variant of this appears in <span class="citation" data-cites="osc"></span>. A barbershop is a place where customers get their hair cut. A barbershop consists of a waiting area with <span class="math inline">n</span> chairs, and a barber chair.</p>
<p>If there are no customers to be served, the barber goes to sleep. If a customer enters the barbershop and all chairs are occupied, then the customer leaves the shop. If the barber is busy, but chairs are available, then the customer sits in one of the free chairs. If the barber is asleep, the customer wakes up the barber.</p>
<p>Customer threads should call <code>get_hair_cut()</code> when it is their turn. If the shop is full, the customer should <code>return</code> (exit/leave). The barber thread will call <code>cut_hair</code>. The barber can cut only one person’s hair at a time, so there should be exactly one thread calling <code>get_hair_cut()</code> concurrently. You can assume that external forces cause customers to appear and the barber to keep working (so you do not need to write any loops). Assume <code>n</code> is initialized to an appropriate value.</p>
<p>We need an integer counter for customers waiting called <code>customers</code> that starts at 0. We will also have a mutex for controlling access to <code>customers</code> called <code>mutex</code> (it obviously starts at 1). Finally, two semaphores, <code>customer</code> and <code>barber</code> that both start at 0.</p>
<p>As for the solution:</p>
<p><span>2</span>
<strong>Customer</strong></p>
<pre><code>wait( mutex )
if customers == n
    signal( mutex )
    return
end if
customers++
signal( mutex )

signal( customer )
wait( barber )
get_hair_cut()

wait( mutex )
customers--
signal( mutex )</code></pre>
<p><strong>Barber</strong></p>
<pre><code>wait( customer )
signal( barber )
cut_hair()</code></pre>
<p>The barber code is much simpler, so let’s start there. The barber waits for there to be a customer. When there is one, the barber calls the customer forward by signalling on <code>barber</code>, and then cuts hair. Simple enough.</p>
<p>As for the customer, <code>customers</code> is shared data, so its access should be protected by <code>mutex</code>. If we find that the number of customers is already <span class="math inline">n</span> – that is, the waiting area is full, the customer should leave. But not without unlocking <code>mutex</code>! If the customer forgot to do that then no more customers could enter. That’s a problem. Otherwise the count of customers is increased and the customer signals the semaphore <code>customer</code>. This will wake up the barber, if the barber is sleeping, but also indicates the number of customers waiting. Then the customer must wait for the barber. When the customer gets called forward by the barber, the customer can get their hair cut. Finally, when leaving, the customer decrements the number of customers counter.</p>
<p>Let’s look over this for a risk of deadlock. We don’t see anywhere, really, the nested-waits pattern that usually indicates trouble. There isn’t really any scenario where a customer can get blocked waiting for another customer or the barber, and the barber code is very simple.</p>
<p>As for starvation, it also won’t happen. Assuming there are actually customers, the barber will have work to do. And the customers will wait for a finite period before they get their hair cut. The size of the waiting area is limited so we expect that a customer doesn’t get delayed indefinitely. It is possible for them to wait quite a while, though, but they will eventually get a turn.</p>
<p>We can maybe say that customers who give up in frustration are disappointed but that’s better than making them wait forever. If they are told they won’t get service today, they can go to a different barbershop or come again some other time. That’s why there’s the limit on the waiting area at all. In the scenario, the barber is only human and can only cut so many people’s hair in a day. The exact number will vary based on how long each hair cut takes, which depends on the person whose hair is being cut. But there is a limit of some sort: at some point the barber will go home. And only so many people can fit into the waiting room anyway: if there are too many, then nobody can move around (and this violates fire code!).</p>
<p>This is actually a good lesson for services in general. They have a certain capacity, and when things are overloaded it’s helpful to tell clients that they are unable to take any more requests right now. Clients can then choose what to do (and it’s usually either “wait a while and try again” or “go to a different service”). And you can! If the game that you want to play requires a server and all servers are busy, you can play a different game (or go outside, or who knows what!).</p>
<h3 id="chemistry-building-h_2o" class="unnumbered">Chemistry: Building H<span class="math inline">_{2}</span>O</h3>
<p>There are two kinds of thread, <code>oxygen()</code> and <code>hydrogen()</code>. As you will recall from basic chemistry, water, H<span class="math inline">_{2}</span>O, requires two hydrogen modules and one oxygen module. To assemble the desired molecule (water) a group rendezvous pattern is needed to make each thread wait until all ingredients are present in the correct amounts. As each thread passes the barrier, it should call the function <code>bond()</code> which makes the water. Our solution must function so that all threads for one molecule invoke <code>bond()</code> before any of the threads from the next molecule do.</p>
<p>To clarify, if an oxygen thread arrives at the barrier when no hydrogen threads are present, it has to wait for two hydrogen threads to arrive. If a hydrogen thread arrives a the barrier when no other threads are waiting, it has to wait for an oxygen thread and another hydrogen thread. It is not necessary for the threads to know what other threads they are matched with, as long as the correct elements are present in the correct proportions.</p>
<p>In the example, we’ll assume the <code>oxygen</code> and <code>hydrogen</code> threads are created and started correctly and in the correct proportions. The code for the creation of those two types of threads is not shown for space reasons. The reusable two-phase barrier from earlier has also been converted into C code.</p>
<p>The oxygen queue and hydrogen queue start as “locked” so we’ll only signal the threads when they are going to proceed. Before that we have a scoreboard pattern, where threads take a look at the state of the system and decide what to do.</p>
<p><span>2</span></p>
<div class="sourceCode" id="cb168" data-firstline="0" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb168-1" title="1"><span class="dt">int</span> oxygen;</a>
<a class="sourceLine" id="cb168-2" title="2"><span class="dt">int</span> hydrogen;</a>
<a class="sourceLine" id="cb168-3" title="3">pthread_mutex_t barrier_mutex;</a>
<a class="sourceLine" id="cb168-4" title="4">sem_t turnstile;</a>
<a class="sourceLine" id="cb168-5" title="5"><span class="dt">int</span> barrier_count;</a>
<a class="sourceLine" id="cb168-6" title="6"><span class="dt">int</span> barrier_N;</a>
<a class="sourceLine" id="cb168-7" title="7">sem_t bond;</a>
<a class="sourceLine" id="cb168-8" title="8">sem_t oxygen_queue;</a>
<a class="sourceLine" id="cb168-9" title="9">sem_t hydrogen_queue;</a>
<a class="sourceLine" id="cb168-10" title="10"></a>
<a class="sourceLine" id="cb168-11" title="11"><span class="dt">void</span> barrier_enter( ) {</a>
<a class="sourceLine" id="cb168-12" title="12">  pthread_mutex_lock( &amp;barrier_mutex );</a>
<a class="sourceLine" id="cb168-13" title="13">  barrier_count++;</a>
<a class="sourceLine" id="cb168-14" title="14">  <span class="cf">if</span> ( barrier_count == barrier_N ) {</a>
<a class="sourceLine" id="cb168-15" title="15">    sem_post( &amp;turnstile );</a>
<a class="sourceLine" id="cb168-16" title="16">  }</a>
<a class="sourceLine" id="cb168-17" title="17">  pthread_mutex_unlock( &amp;barrier_mutex );</a>
<a class="sourceLine" id="cb168-18" title="18">  sem_wait( &amp;turnstile );</a>
<a class="sourceLine" id="cb168-19" title="19">  sem_post( &amp;turnstile );            </a>
<a class="sourceLine" id="cb168-20" title="20">}</a>
<a class="sourceLine" id="cb168-21" title="21"></a>
<a class="sourceLine" id="cb168-22" title="22"><span class="dt">void</span> barrier_exit( ) {</a>
<a class="sourceLine" id="cb168-23" title="23">  pthread_mutex_lock( &amp;barrier_mutex );</a>
<a class="sourceLine" id="cb168-24" title="24">  barrier_count--;</a>
<a class="sourceLine" id="cb168-25" title="25">  <span class="cf">if</span> ( barrier_count == <span class="dv">0</span> ) {</a>
<a class="sourceLine" id="cb168-26" title="26">    sem_wait( &amp;turnstile );</a>
<a class="sourceLine" id="cb168-27" title="27">  }</a>
<a class="sourceLine" id="cb168-28" title="28">  pthread_mutex_unlock( &amp;barrier_mutex );</a>
<a class="sourceLine" id="cb168-29" title="29">}</a>
<a class="sourceLine" id="cb168-30" title="30"></a></code></pre></div>
<div class="sourceCode" id="cb169" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb169-1" title="1"><span class="dt">int</span> main( <span class="dt">void</span> ) {</a>
<a class="sourceLine" id="cb169-2" title="2">  oxygen = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb169-3" title="3">  hydrogen = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb169-4" title="4">  barrier_count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb169-5" title="5">  barrier_N = <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb169-6" title="6"></a>
<a class="sourceLine" id="cb169-7" title="7">  pthread_mutex_init( &amp;barrier_mutex, NULL );</a>
<a class="sourceLine" id="cb169-8" title="8">  sem_init( &amp;barrier_turnstile, <span class="dv">0</span>, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb169-9" title="9">  </a>
<a class="sourceLine" id="cb169-10" title="10">  sem_init( &amp;bond, <span class="dv">0</span>, <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb169-11" title="11">  sem_init( &amp;oxygen_queue, <span class="dv">0</span>, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb169-12" title="12">  sem_init( &amp;hydrogen_queue, <span class="dv">0</span>, <span class="dv">0</span> ); </a>
<a class="sourceLine" id="cb169-13" title="13"></a>
<a class="sourceLine" id="cb169-14" title="14">  <span class="co">/* Creation of oxygen and hydrogen threads</span></a>
<a class="sourceLine" id="cb169-15" title="15"><span class="co">   not shown for space reasons */</span></a>
<a class="sourceLine" id="cb169-16" title="16"></a>
<a class="sourceLine" id="cb169-17" title="17">  pthread_mutex_destroy( &amp;barrier_mutex );</a>
<a class="sourceLine" id="cb169-18" title="18">  sem_destroy( &amp;barrier_turnstile );</a>
<a class="sourceLine" id="cb169-19" title="19">  sem_destroy( &amp;bond );</a>
<a class="sourceLine" id="cb169-20" title="20">  sem_destroy( &amp;oxygen_queue );</a>
<a class="sourceLine" id="cb169-21" title="21">  sem_destroy( &amp;hydrogen_queue );   </a>
<a class="sourceLine" id="cb169-22" title="22"></a>
<a class="sourceLine" id="cb169-23" title="23">  pthread_exit( <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb169-24" title="24">}</a></code></pre></div>
<p><span>2</span></p>
<div class="sourceCode" id="cb170" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb170-1" title="1"><span class="dt">void</span>* oxygen( <span class="dt">void</span>* ignore ) {</a>
<a class="sourceLine" id="cb170-2" title="2">  sem_wait( &amp;bond );</a>
<a class="sourceLine" id="cb170-3" title="3">  oxygen++;</a>
<a class="sourceLine" id="cb170-4" title="4">  </a>
<a class="sourceLine" id="cb170-5" title="5">  <span class="cf">if</span>( hydrogen &gt;= <span class="dv">2</span> ){</a>
<a class="sourceLine" id="cb170-6" title="6">    sem_post( &amp;hydrogen_queue );</a>
<a class="sourceLine" id="cb170-7" title="7">    sem_post( &amp;hydrogen_queue );</a>
<a class="sourceLine" id="cb170-8" title="8">    hydrogen -= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb170-9" title="9">    sem_post( &amp;oxygen_queue );</a>
<a class="sourceLine" id="cb170-10" title="10">    oxygen--;</a>
<a class="sourceLine" id="cb170-11" title="11">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb170-12" title="12">    sem_post( &amp;bond );</a>
<a class="sourceLine" id="cb170-13" title="13">  }</a>
<a class="sourceLine" id="cb170-14" title="14">  </a>
<a class="sourceLine" id="cb170-15" title="15">  sem_wait( &amp;oxygen_queue );</a>
<a class="sourceLine" id="cb170-16" title="16">  bond();</a>
<a class="sourceLine" id="cb170-17" title="17"></a>
<a class="sourceLine" id="cb170-18" title="18">  barrier_enter();</a>
<a class="sourceLine" id="cb170-19" title="19">  barrier_exit();</a>
<a class="sourceLine" id="cb170-20" title="20"></a>
<a class="sourceLine" id="cb170-21" title="21">  sem_post( &amp;bond );</a>
<a class="sourceLine" id="cb170-22" title="22">  </a>
<a class="sourceLine" id="cb170-23" title="23">  pthread_exit( NULL )</a>
<a class="sourceLine" id="cb170-24" title="24">}</a></code></pre></div>
<div class="sourceCode" id="cb171" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb171-1" title="1"><span class="dt">void</span>* hydrogen( <span class="dt">void</span>* ignore ) {</a>
<a class="sourceLine" id="cb171-2" title="2">  sem_wait( &amp;bond );</a>
<a class="sourceLine" id="cb171-3" title="3">  hydrogen++;</a>
<a class="sourceLine" id="cb171-4" title="4">  </a>
<a class="sourceLine" id="cb171-5" title="5">  <span class="cf">if</span>( hydrogen &gt;= <span class="dv">2</span> &amp;&amp; oxygen &gt;= <span class="dv">1</span> )</a>
<a class="sourceLine" id="cb171-6" title="6">    sem_post( &amp;hydrogen_queue );</a>
<a class="sourceLine" id="cb171-7" title="7">    sem_post( &amp;hydrogen_queue );</a>
<a class="sourceLine" id="cb171-8" title="8">    hydrogen -= <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb171-9" title="9">    sem_post( &amp;oxygen_queue );</a>
<a class="sourceLine" id="cb171-10" title="10">    oxygen--;</a>
<a class="sourceLine" id="cb171-11" title="11">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb171-12" title="12">    sem_post( &amp;bond );</a>
<a class="sourceLine" id="cb171-13" title="13">  }</a>
<a class="sourceLine" id="cb171-14" title="14">  </a>
<a class="sourceLine" id="cb171-15" title="15">  sem_wait( &amp;hydrogen_queue );</a>
<a class="sourceLine" id="cb171-16" title="16">  bond();</a>
<a class="sourceLine" id="cb171-17" title="17">  </a>
<a class="sourceLine" id="cb171-18" title="18">  barrier_enter();</a>
<a class="sourceLine" id="cb171-19" title="19">  barrier_exit();</a>
<a class="sourceLine" id="cb171-20" title="20">  </a>
<a class="sourceLine" id="cb171-21" title="21">  pthread_exit( NULL )</a>
<a class="sourceLine" id="cb171-22" title="22">}</a></code></pre></div>
<p>Let’s analyze the solution then, starting with oxygen threads. When it enters, it waits on the <code>bond</code> semaphore, which in this case is used somewhat like a mutex. If there are at least two hydrogen threads waiting, then, we can unblock two of them, signal the oxygen queue, and update the counters. If there are not two hydrogens waiting, then we just signal <code>bond</code> so that the next thread will arrive. Then the thread can get in line at the oxygen queue.</p>
<p>The hydrogen code is more or less the same, but the if-condition is different since it’s not enough for 1 hydrogen to be present (we need at least two). If we have what we need, signal the queues to release the needed molecules, and we are ready to go. If not, get in line.</p>
<p>When threads are released from the oxygen queue and hydrogen queue respectively, they proceed forward to the <code>bond()</code> step, and afterwards there is a barrier enter followed by exit to wait for all of them to be finished. All we really need is for all three threads to be done with <code>bond()</code> before they can exit so the barrier enter and exit happen one after the other.</p>
<p>Now it may be that when a thread arrives it unblocks some thread ahead of it in line. So if the oxygen that arrives is the 2nd oxygen and there is already one waiting ahead of it, that first one proceeds. That’s okay – one molecule of water is as good as any other so we don’t really care which oxygen ends up in its composition.</p>
<p>It is a little strange that the hydrogen threads don’t post on <code>bond</code>. Isn’t this a problem? It turns out no, because the oxygen threads post on it unconditionally. The reasoning on this is not too complicated. When a thread arrives but the water molecule cannot be formed, whether it is oxygen or hydrogen, a post on <code>bond</code> takes place. If, however, the thread arriving is the last one necessary for bonding to take place, then one oxygen and two hydrogen proceed. Whoever waited on <code>bond</code> does not matter, as long as one of the threads that went into the water molecule posts on it before leaving. As the chemical composition of water has one oxygen, the job is assigned to this molecule. If we put it in hydrogen we might post on it twice.</p>
<p>These are by no means all the concurrency problems in the world. There are many more in <span class="citation" data-cites="lbs"></span> that could be considered. But for now we will leave it here, before we get into really obscure problems...</p>
<h1 id="condition-variables-monitors-atomic-types" class="unnumbered">23 — Condition Variables, Monitors, Atomic Types</h1>
<h3 id="condition-variables" class="unnumbered">Condition Variables</h3>
<p>Condition variables are another way to achieve synchronization. Rather than designating critical areas and enforcing rules about how many threads may be in the critical area, a condition variable allows synchronization based on the value of the data. Instead of locking a mutex, checking a variable, and then unlocking the mutex, we could achieve the same goal without constantly polling. We can think of condition variables as “events” that occur (like interrupts from hardware when there is new data to read rather than polling to check periodically or constantly).</p>
<p>An event is similar to, but slightly different from, a counting semaphore. We have the option, when an event occurs, to signal either one thread waiting for that event to occur, or to broadcast (signal) to all threads waiting for the event <span class="citation" data-cites="mte241"></span>.</p>
<p>Consider the condition variable functions:</p>
<div class="sourceCode" id="cb172" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb172-1" title="1">pthread_cond_init( pthread_cond_t *cv, pthread_condattr_t *attributes );</a>
<a class="sourceLine" id="cb172-2" title="2">pthread_cond_wait( pthread_cond_t *cv, pthread_mutex_t *mutex );</a>
<a class="sourceLine" id="cb172-3" title="3">pthread_cond_signal( pthread_cond_t *cv );</a>
<a class="sourceLine" id="cb172-4" title="4">pthread_cond_broadcast( pthread_cond_t *cv );</a>
<a class="sourceLine" id="cb172-5" title="5">pthread_cond_destroy( pthread_cond_t *cv );</a></code></pre></div>
<p>To initialize a <code>pthread_cond_t</code> (condition variable type), the function is <code>pthread_cond_init</code> and to destroy them, <code>pthread_cond_destroy</code>. As with threads and a mutex, we can initialize them with attributes, and there are functions to create and destroy the attribute structures, too. But the default attributes will be fine, at least in this course.</p>
<p>Condition variables are always used in conjunction with a mutex. To wait on a condition variable, the function <code>pthread_cond_wait</code> takes two parameters: the condition variable and the mutex. This routine should be called only while the mutex is locked. It will automatically release the mutex while it waits for the condition; when the condition is true then the mutex will be automatically locked again so the thread may proceed. The programmer then unlocks the mutex when the thread is finished with it <span class="citation" data-cites="pthreads"></span>. Obviously, failing to lock and unlock the mutex before and after using the condition variable, respectively, can result in problems.</p>
<p>In addition to the expected <code>pthread_cond_signal</code> function that signals a provided condition variable, there is also <code>pthread_cond_broadcast</code> that signals all threads waiting on that condition variable. It’s this “broadcast” idea that makes the condition variable more interesting than the simple “signalling” pattern we covered much earlier on.</p>
<p>Let us now examine a code example from <span class="citation" data-cites="pthreads"></span> which has been cut down a bit to make it more readable:</p>
<div class="sourceCode" id="cb173" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb173-1" title="1"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb173-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb173-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb173-4" title="4"></a>
<a class="sourceLine" id="cb173-5" title="5"><span class="pp">#define NUM_THREADS  3</span></a>
<a class="sourceLine" id="cb173-6" title="6"><span class="pp">#define COUNT_LIMIT 12</span></a>
<a class="sourceLine" id="cb173-7" title="7"></a>
<a class="sourceLine" id="cb173-8" title="8"><span class="dt">int</span> count = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb173-9" title="9">pthread_mutex_t count_mutex;</a>
<a class="sourceLine" id="cb173-10" title="10">pthread_cond_t count_threshold_cv;</a>
<a class="sourceLine" id="cb173-11" title="11"></a>
<a class="sourceLine" id="cb173-12" title="12"><span class="dt">void</span>* inc_count( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb173-13" title="13">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; <span class="dv">10</span>; i++ ) {</a>
<a class="sourceLine" id="cb173-14" title="14">    pthread_mutex_lock( &amp;count_mutex );</a>
<a class="sourceLine" id="cb173-15" title="15">    count++;</a>
<a class="sourceLine" id="cb173-16" title="16">    <span class="cf">if</span> ( count == COUNT_LIMIT ) {</a>
<a class="sourceLine" id="cb173-17" title="17">      printf( <span class="st">&quot;Condition Fulfilled!</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb173-18" title="18">      pthread_cond_signal( &amp;count_threshold_cv );</a>
<a class="sourceLine" id="cb173-19" title="19">      printf( <span class="st">&quot;Sent signal.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb173-20" title="20">    }</a>
<a class="sourceLine" id="cb173-21" title="21">    pthread_mutex_unlock( &amp;count_mutex );</a>
<a class="sourceLine" id="cb173-22" title="22">  }</a>
<a class="sourceLine" id="cb173-23" title="23">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb173-24" title="24">}</a>
<a class="sourceLine" id="cb173-25" title="25"></a>
<a class="sourceLine" id="cb173-26" title="26"><span class="dt">void</span>* watch_count( <span class="dt">void</span> *arg ) {</a>
<a class="sourceLine" id="cb173-27" title="27">  pthread_mutex_lock( &amp;count_mutex );  </a>
<a class="sourceLine" id="cb173-28" title="28">  <span class="cf">if</span> ( count &lt; COUNT_LIMIT ) {</a>
<a class="sourceLine" id="cb173-29" title="29">    pthread_cond_wait( &amp;count_threshold_cv, &amp;count_mutex );</a>
<a class="sourceLine" id="cb173-30" title="30">    printf( <span class="st">&quot;Watcher has woken up.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb173-31" title="31">    <span class="co">/* Do something useful here now that condition is fulfilled. */</span></a>
<a class="sourceLine" id="cb173-32" title="32">  }</a>
<a class="sourceLine" id="cb173-33" title="33">  pthread_mutex_unlock( &amp;count_mutex );</a>
<a class="sourceLine" id="cb173-34" title="34">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb173-35" title="35">}</a>
<a class="sourceLine" id="cb173-36" title="36"></a>
<a class="sourceLine" id="cb173-37" title="37"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span> **argv ) {</a>
<a class="sourceLine" id="cb173-38" title="38">  pthread_t threads[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb173-39" title="39"></a>
<a class="sourceLine" id="cb173-40" title="40">  pthread_mutex_init( &amp;count_mutex, NULL );</a>
<a class="sourceLine" id="cb173-41" title="41">  pthread_cond_init ( &amp;count_threshold_cv, NULL );</a>
<a class="sourceLine" id="cb173-42" title="42"></a>
<a class="sourceLine" id="cb173-43" title="43">  pthread_create( &amp;threads[<span class="dv">0</span>], NULL, watch_count, NULL );</a>
<a class="sourceLine" id="cb173-44" title="44">  pthread_create( &amp;threads[<span class="dv">1</span>], NULL, inc_count, NULL );</a>
<a class="sourceLine" id="cb173-45" title="45">  pthread_create( &amp;threads[<span class="dv">2</span>], NULL, inc_count, NULL );</a>
<a class="sourceLine" id="cb173-46" title="46"></a>
<a class="sourceLine" id="cb173-47" title="47">  <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NUM_THREADS; i++ ) {</a>
<a class="sourceLine" id="cb173-48" title="48">    pthread_join(threads[i], NULL);</a>
<a class="sourceLine" id="cb173-49" title="49">  }</a>
<a class="sourceLine" id="cb173-50" title="50">  </a>
<a class="sourceLine" id="cb173-51" title="51">  pthread_mutex_destroy( &amp;count_mutex );</a>
<a class="sourceLine" id="cb173-52" title="52">  pthread_cond_destroy( &amp;count_threshold_cv );</a>
<a class="sourceLine" id="cb173-53" title="53">  pthread_exit( NULL );</a>
<a class="sourceLine" id="cb173-54" title="54">}</a></code></pre></div>
<p>It should be noted that if a thread signals a condition variable that an event has occurred, but no thread is waiting for that event, the event is “lost”. Because an event that takes place when no thread is listening is simply lost, it is (almost always) a logical error to signal or broadcast on a condition variable before some thread is waiting on it. This is sometimes called the “lost wakeup problem”, because threads don’t get woken up if they weren’t waiting for this. Maybe it’s not as dire as that, however, because sometimes an event is broadcast but nobody is interested and that’s fine.</p>
<p>The condition variable with broadcast can be used to replace some of the synchronization constructs we’ve seen already. Consider the barrier pattern from earlier. There are <span class="math inline">n</span> threads and we wait for the last one to arrive. Then the last thread signals to unlock the barrier and then each thread calls post to unblock the next thread until all of them are through. This is a lot of calls and maybe it would be better to make it a broadcast instead. Remember the simple barrier (one phase rather than two), on the left, and then the condition variable on the right:</p>
<p><span>2</span></p>
<pre><code>    1. wait( mutex )
    2. count++
    3. if count == n
    4.     post( barrier )
    5. end if
    6. post( mutex )
    7. wait( barrier )
    8. post( barrier )</code></pre>
<pre><code>    1. wait( mutex )
    2. count++
    3. if count &lt; n
    4.     cond_wait( barrier, mutex )
    5. else 
    6.     cond_broadcast( barrier )
    7. end if
    8. post( mutex )</code></pre>
<p>The <code>wait</code> takes place before the post on <code>mutex</code>. That looks strange, doesn’t it? What’s important to remember is that we give up the mutex <code>lock</code> when we wait on the condition variable so the fact that we don’t get to the unlock statement first does not cause a problem. So we are alright. The last thread doesn’t wait on the condition at all because there’s no need to: it knows that it is last and there’s nothing to wait for so it should proceed.</p>
<p>Okay, let’s think about how to put that to use in an actual code example. Assume that <code>count</code>, <code>lock</code> and <code>cv</code> are initialized correctly as they should be.</p>
<div class="sourceCode" id="cb176" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb176-1" title="1"><span class="dt">int</span> count;</a>
<a class="sourceLine" id="cb176-2" title="2">pthread_mutex_t lock;</a>
<a class="sourceLine" id="cb176-3" title="3">pthread_cond_t cv; </a>
<a class="sourceLine" id="cb176-4" title="4"></a>
<a class="sourceLine" id="cb176-5" title="5"><span class="dt">void</span> barrier( ) {</a>
<a class="sourceLine" id="cb176-6" title="6">  pthread_mutex_lock( &amp;lock );</a>
<a class="sourceLine" id="cb176-7" title="7">  count++;</a>
<a class="sourceLine" id="cb176-8" title="8">  <span class="cf">if</span> ( count &lt; NUM_THREADS ) {</a>
<a class="sourceLine" id="cb176-9" title="9">    pthread_cond_wait( &amp;cv, &amp;lock );</a>
<a class="sourceLine" id="cb176-10" title="10">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb176-11" title="11">    pthread_cond_broadcast( &amp;cv );</a>
<a class="sourceLine" id="cb176-12" title="12">  }</a>
<a class="sourceLine" id="cb176-13" title="13">  pthread_mutex_unlock( &amp;lock );</a>
<a class="sourceLine" id="cb176-14" title="14">}</a></code></pre></div>
<p>If every thread calls <code>barrier()</code> before going on to whatever is next, they will wait until the last thread arrives – as they should. Broadcast wakes up all the other threads. It’s possible to use a for loop to signal on the condition variable <span class="math inline">n</span> times but that mostly defeats the purpose of using the condition variable instead of a regular semaphore, doesn’t it?</p>
<h3 id="monitors" class="unnumbered">Monitors</h3>
<p>A condition variable can be used to create a <em>monitor</em>, a higher level synchronization construct. Just as in object-oriented programming we package up data and functions inside a class to make errors less likely and to improve the design, when we use a monitor we are packaging up the shared data and operations on that data to avoid problems of synchronization and concurrency.</p>
<p>The objective of the monitor is to make it so that programmers do not need to code the synchronization part directly, making it less likely a programmer makes an error. There are numerous steps where you can get it wrong in a typical program. Look at:</p>
<div class="sourceCode" id="cb177" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb177-1" title="1"><span class="dt">void</span> foo( ) {</a>
<a class="sourceLine" id="cb177-2" title="2">  pthread_mutex_lock( &amp;l );</a>
<a class="sourceLine" id="cb177-3" title="3">  <span class="co">/* Read some data */</span></a>
<a class="sourceLine" id="cb177-4" title="4">  <span class="cf">if</span> ( condition ) {</a>
<a class="sourceLine" id="cb177-5" title="5">    printf( <span class="st">&quot;Cannot continue due to reasons...</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb177-6" title="6">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb177-7" title="7">  }</a>
<a class="sourceLine" id="cb177-8" title="8">  <span class="co">/* More stuff */</span></a>
<a class="sourceLine" id="cb177-9" title="9">   </a>
<a class="sourceLine" id="cb177-10" title="10">  pthread_mutex_unlock( &amp;l );</a>
<a class="sourceLine" id="cb177-11" title="11">}</a></code></pre></div>
<p>In this case, there is control flow that could lead to exiting this function <code>foo</code> without unlocking the mutex <code>l</code>. Sure, when I cut the remaining code out and just replace it with some comments so the control flow that causes the problem here is obvious, but in a real code example the function in question is likely to be in the hundreds of lines and it’s easy to overlook something.</p>
<p>The idea of monitors should be familiar to you if you have used Java synchronization constructs, notably the <code>synchronized</code> keyword. In Java we can declare a method to be <code>synchronized</code>, adding it after the access modifier keyword (public, private, etc) in the function definition, and then there is a lock created around that method. Only one thread can be inside that method at a time; if a second would like to call that method on the same instance, it will be placed in the entry set for the lock: a set of threads waiting for the lock to become available <span class="citation" data-cites="osc"></span>.</p>
<div class="sourceCode" id="cb178" data-language="Java"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb178-1" title="1"><span class="kw">public</span> <span class="kw">synchronized</span> <span class="dt">void</span> <span class="fu">doSomething</span>() {</a>
<a class="sourceLine" id="cb178-2" title="2">    <span class="co">// Synchronized area</span></a>
<a class="sourceLine" id="cb178-3" title="3">}</a></code></pre></div>
<p>Note that in Java we can make a method <code>synchronized</code> or define a block as synchronized:</p>
<div class="sourceCode" id="cb179" data-language="Java"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb179-1" title="1"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">exampleMethod</span>() {</a>
<a class="sourceLine" id="cb179-2" title="2">    <span class="kw">synchronized</span>( object ) { <span class="co">// Lock must be acquired to enter this block</span></a>
<a class="sourceLine" id="cb179-3" title="3">           <span class="co">// Critical section </span></a>
<a class="sourceLine" id="cb179-4" title="4">    } <span class="co">// Lock is automatically released.</span></a>
<a class="sourceLine" id="cb179-5" title="5">}</a></code></pre></div>
<p>This sort of “automatic” locking and releasing is intended to simplify the process of writing multithreaded code and abstract away some of the details of mutual exclusion.</p>
<p>Monitors don’t have to be written in Java (or a similar language) but they very commonly appear in object-oriented programming languages because of the goal of packaging up your data with the associated synchronization constructs looks a lot like Object-Oriented Programming: package up the data with its associated functions. Moreover, in an object-oriented language thanks to things like encapsulation (i.e., <code>private</code> variables), it’s somewhat easier to “force” all access to be through the appropriate monitor.</p>
<h3 id="atomic-types" class="unnumbered">Atomic Types</h3>
<p>Frequently we have a code pattern that looks something like this:</p>
<div class="sourceCode" id="cb180" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb180-1" title="1">pthread_mutex_lock( lock );</a>
<a class="sourceLine" id="cb180-2" title="2">shared_var++;</a>
<a class="sourceLine" id="cb180-3" title="3">pthread_mutex_unlock( lock );</a></code></pre></div>
<p>While is is fully correct, if this happens frequently there is a lot of locking and unlocking on the same mutex, just to do the increment. So there’s a fair amount of overhead on this. Thinking back to the “test and set” type of instruction from earlier, wouldn’t it be nice if we could do that sort of thing for something like incrementing a variable? We can!</p>
<p>The GNU (Linux) standard C library (<code>glibc</code>) provides operations that are guaranteed to execute atomically, to avoid simple race conditions. Where possible, the compiler will try to turn these into uninterruptible hardware instructions; otherwise a function that has locking will be used to implement the atomic nature.</p>
<p>The kernel itself contains an atomic type, <code>atomic_t</code>, but this is not intended for use outside of the kernel.</p>
<p>The following function listings are an overview of the atomic operations, from <span class="citation" data-cites="gccatomic"></span>. These are, however, <code>glibc</code> specific, and not necessarily available in a general system. In the C11 (2011) standard, atomic types were finally introduced as part of the language specification itself. But before this we just had implementation-specific options. In the specification, we see <code>type</code> as the type, but that’s of course not a real type. In its place you would use an <code>int</code> for an integer. A valid type is one that 1, 2, 4, or 8 bytes in length, if it’s an integral type or a pointer.</p>
<p>The following function is used to assign a new value, and returns the old value. However, the name is unfortunate, because it conflicts with the hardware instruction test-and-set which we discussed earlier. But this atomically sets the value of the variable as expected:</p>
<div class="sourceCode" id="cb181" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb181-1" title="1">type __sync_lock_test_and_set( type *ptr, type value );</a></code></pre></div>
<p>The following functions are used to swap two values, only if the old value matches the expected (i.e., what was provided as the second argument):</p>
<div class="sourceCode" id="cb182" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb182-1" title="1"><span class="dt">bool</span> __sync_bool_compare_and_swap( type *ptr, type oldval, type newval );</a>
<a class="sourceLine" id="cb182-2" title="2">type __sync_val_compare_and_swap( type *ptr, type oldval, type newval );</a></code></pre></div>
<p>The following functions perform the operation and return the <em>old</em> value:</p>
<div class="sourceCode" id="cb183" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb183-1" title="1">type __sync_fetch_and_add( type *ptr, type value );</a>
<a class="sourceLine" id="cb183-2" title="2">type __sync_fetch_and_sub( type *ptr, type value );</a>
<a class="sourceLine" id="cb183-3" title="3">type __sync_fetch_and_or( type *ptr, type value );</a>
<a class="sourceLine" id="cb183-4" title="4">type __sync_fetch_and_and( type *ptr, type value );</a>
<a class="sourceLine" id="cb183-5" title="5">type __sync_fetch_and_xor( type *ptr, type value );</a>
<a class="sourceLine" id="cb183-6" title="6">type __sync_fetch_and_nand( type *ptr, type value );</a></code></pre></div>
<p>The following functions perform the operation and return the <em>new</em> value:</p>
<div class="sourceCode" id="cb184" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb184-1" title="1">type __sync_add_and_fetch( type *ptr, type value );</a>
<a class="sourceLine" id="cb184-2" title="2">type __sync_sub_and_fetch( type *ptr, type value );</a>
<a class="sourceLine" id="cb184-3" title="3">type __sync_or_and_fetch( type *ptr, type value );</a>
<a class="sourceLine" id="cb184-4" title="4">type __sync_and_and_fetch( type *ptr, type value );</a>
<a class="sourceLine" id="cb184-5" title="5">type __sync_xor_and_fetch( type *ptr, type value );</a>
<a class="sourceLine" id="cb184-6" title="6">type __sync_nand_and_fetch( type *ptr, type value );</a></code></pre></div>
<p>Interestingly, for x86 there is no atomic read operation. The (normal) read itself is atomic for 32-bit-aligned data. This behaviour is specific to x86 and we have mostly tried to avoid relying on anything that is implementation-specific behaviour... If we do rely on this, however, we could get an out-of-date value. If you want to really be sure you did get the latest, you can use one of the above functions and add or subtract 0. And that would be a bit more portable as well. But for true portability you will need to use C11 or a semaphore/mutex.</p>
<p>Atomic operations are helpful for scenarios like a single variable being modified and read. But atomic operations are not always ideal. Consider this:</p>
<div class="sourceCode" id="cb185" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb185-1" title="1"><span class="kw">struct</span> point {</a>
<a class="sourceLine" id="cb185-2" title="2">  <span class="dt">volatile</span> <span class="dt">int</span> x;</a>
<a class="sourceLine" id="cb185-3" title="3">  <span class="dt">volatile</span> <span class="dt">int</span> y;</a>
<a class="sourceLine" id="cb185-4" title="4">};</a>
<a class="sourceLine" id="cb185-5" title="5">__sync_lock_test_and_set( p1-&gt;x, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb185-6" title="6">__sync_lock_test_and_set( p1-&gt;y, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb185-7" title="7"></a>
<a class="sourceLine" id="cb185-8" title="8"><span class="co">/* Somewhere else in the program */</span></a>
<a class="sourceLine" id="cb185-9" title="9">__sync_lock_test_and_set( p1-&gt;x, <span class="dv">25</span> );</a>
<a class="sourceLine" id="cb185-10" title="10">__sync_lock_test_and_set( p1-&gt;y, <span class="dv">30</span> );</a></code></pre></div>
<p>Although the set of each of <code>x</code> and <code>y</code> is atomic, the operation as a whole is not. The write of <code>x</code> could succeed and then a read of both in a different thread could take place before the write of <code>y</code>, meaning that a reader would see (25, 0) when that’s probably not valid. Similarly, the state could be totally corrupted if another thread did atomic writes of (10, 15) in between the two, leading to a final state of (10, 30).</p>
<p>When a number of writes need to take place as a “package”, then a mutex type is the appropriate choice.</p>
<h5 id="spinlocks.">Spinlocks.</h5>
<p>Another common technique for protecting a critical section in Linux is the <em>spinlock</em>. This is a handy way to implement constant checking to acquire a lock. Unlike semaphores where the process is blocked if it fails to acquire the lock, a thread will constantly try to acquire the lock. The implementation is an integer that is checked by a thread; if the value is 0, the thread can lock it (set the value to 1) and continue; if it is nonzero, it constantly checks the value until the value becomes 0. As you know, this is very inefficient; it would be better to let another thread execute, except in the circumstances where the amount of time waiting on the lock might be less than it would take to block the process, switch to another, and unblock it when the value changes <span class="citation" data-cites="osi"></span>.</p>
<div class="sourceCode" id="cb186" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb186-1" title="1">spin_lock( &amp;lock )</a>
<a class="sourceLine" id="cb186-2" title="2">    <span class="co">/* Critical Section */</span></a>
<a class="sourceLine" id="cb186-3" title="3">spin_unlock( &amp;lock )</a></code></pre></div>
<p>In addition to the regular spinlock, there are <em>reader-writer-spinlocks</em>. Like the readers-writers problem discussed earlier, the goal is to allow multiple readers but give exclusive access to a writer. This is implemented as a 24-bit reader counter and an unlock flag, with the meaning defined as follows <span class="citation" data-cites="osi"></span>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Counter</strong></th>
<th style="text-align: left;"><strong>Flag</strong></th>
<th style="text-align: left;"><strong>Interpretation</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">0</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">The spinlock is released and available.</td>
</tr>
<tr class="even">
<td style="text-align: left;">0</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">The spinlock has been acquired for writing.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">n</span> (<span class="math inline">n &gt; 0</span>)</td>
<td style="text-align: left;">0</td>
<td style="text-align: left;">The spin lock has been acquired for reading by <span class="math inline">n</span> threads.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">n</span> (<span class="math inline">n &gt; 0</span>)</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Invalid state.</td>
</tr>
</tbody>
</table>
<p>There are further additional details related to use of spinlocks, which can of course be explored by reading the Linux kernel documentation.</p>
<h1 id="of-asgard-hel" class="unnumbered">24 — Of Asgard &amp; Hel</h1>
<h2 id="norse-mythology" class="unnumbered">Norse Mythology</h2>
<p>Everything came into creation in the gap between fire and ice, and the World Tree (Yggdrasil) connects the nine worlds. Asgard is the home of the Æsir, the Norse gods. Helheim, or simply Hel, is the underworld where the dead go upon their death. In Hel or Asgard (it’s not entirely clear), there is Valhalla, hall of the honoured dead. Those who die in battle and are judged worthy will be carried to Valhalla by the Valkyries. There they will reside until they are called upon to aid in Odin’s fight with the wolf Fenrir in Ragnarök<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>, the doom of the gods<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a>. For the curious, humans live in the “middle realm”, Midgård, surrounded by the serpent Jormungand, who will fight against Thor in Ragnarök. Thor will kill the serpent, but the serpent’s poison will also finish off Thor<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a>.</p>
<p>Aside from my obvious passion about the subject, why are we talking about Norse Mythology? We’re going to examine some very useful tools for programming called Valgrind and Helgrind (also Cachegrind). Note that the -grind endings on those are pronounced like “grinned”. Where do they take their names from? Valgrind is the gateway to Valhalla; a gate that only the worthy can pass. Helgrind is the gateway to, well, Hel. Which despite being the source of the English word “Hell”, is not the place where sinners go. It’s just the place where the dead go.</p>
<p>But all of these, in program form, are analysis tools for your (usually) C and C++ programs. They are absolute murder on performance, but they are wonderful for finding errors in your program. To use them you will start the tool of your choice and instruct it to invoke your program. The target program then runs under the “supervision” of the tool. This results in running dramatically slower than normal, but you get additional checks and monitoring of the program. It’s important to enable debugging symbols in your compile (<code>-g</code> option if using <code>gcc</code>) if you want stack traces to be useful.</p>
<h3 id="valgrind-or-memcheck" class="unnumbered">Valgrind (or Memcheck) </h3>
<p>Valgrind is the base name of the project and by default what it’s going to do is run the memcheck tool. The purpose of memcheck is to look into all memory reads, writes, and to intercept and analyze every call to <code>malloc</code>/<code>free</code> and <code>new</code>/<code>delete</code>. Thus, memcheck will check all memory accesses and allocations/deallocations, and can find problems like:</p>
<ul>
<li><p>Accessing uninitialized memory</p></li>
<li><p>Reading off the end of an array</p></li>
<li><p>Memory leaks (failing to free allocated memory)</p></li>
<li><p>Incorrect freeing of memory (double free calls or a mismatch)</p></li>
<li><p>Incorrect use of C standard functions like <code>memcpy</code></p></li>
<li><p>Using memory after it’s been freed.</p></li>
<li><p>Asking for an invalid number of bytes in an allocation (negative)</p></li>
</ul>
<p>These errors will be reported to the console when they occur. Ideally, this will help you find the source of the problem.</p>
<p>I decided to run Valgrind with memcheck against the solution I wrote to the ECE 254 S15 exam question for searching an array using pthreads. I am happy to report that memcheck reports that the official solution has no memory leaks. If you do things right, you get something that looks like the example below.</p>
<pre><code>jz@Loki:~/ece254$ valgrind ./search
==8476== Memcheck, a memory error detector
==8476== Copyright (C) 2002-2013, and GNU GPL&#39;d, by Julian Seward et al.
==8476== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==8476== Command: /usr/local/bin/search
==8476== 
usage: search [arguments] [options]
arguments:
         for text
         in directory
options:
         -c | --case-sensitive
         -s | --show-filenames-only
==8476== 
==8476== HEAP SUMMARY:
==8476==     in use at exit: 0 bytes in 0 blocks
==8476==   total heap usage: 0 allocs, 0 frees, 0 bytes allocated
==8476== 
==8476== All heap blocks were freed -- no leaks are possible
==8476== 
==8476== For counts of detected and suppressed errors, rerun with: -v
==8476== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>
<p>Okay, everything going perfectly is unlikely in anything other than a small program. The exam question I used this on is something like 62 lines (including blanks). So it’s a trivial program. But I’ll sabotage it a bit so we get a more interesting result. Suppose I delete from the code two of the <code>free()</code> calls.</p>
<pre><code>jz@Loki:~/ece254$ valgrind ./search 
==8678== Memcheck, a memory error detector
==8678== Copyright (C) 2002-2013, and GNU GPL&#39;d, by Julian Seward et al.
==8678== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==8678== Command: ./search
==8678== 
Found at 11 by thread 1 
Found at 22 by thread 3 
==8678== 
==8678== HEAP SUMMARY:
==8678==     in use at exit: 1,614 bytes in 4 blocks
==8678==   total heap usage: 17 allocs, 13 frees, 2,822 bytes allocated
==8678== 
==8678== LEAK SUMMARY:
==8678==    definitely lost: 0 bytes in 0 blocks
==8678==    indirectly lost: 0 bytes in 0 blocks
==8678==      possibly lost: 0 bytes in 0 blocks
==8678==    still reachable: 1,614 bytes in 4 blocks
==8678==         suppressed: 0 bytes in 0 blocks
==8678== Rerun with --leak-check=full to see details of leaked memory
==8678== 
==8678== For counts of detected and suppressed errors, rerun with: -v
==8678== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code></pre>
<p>If you take the program’s suggestion to use <code>--leak-check=full</code> then you end up with a bit more detail about where you made the mistake. Of course, it’s important to know where to look; in the example below, lines 49 and 24 in the file <code>search.c</code> are the locations of the <code>malloc</code> calls that lack a matching call to <code>free</code>. It can’t tell you where the call to <code>free</code> should go, only where the memory that isn’t freed was allocated.</p>
<pre><code>==8553== 16 bytes in 4 blocks are definitely lost in loss record 1 of 2
==8553==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8553==    by 0x40084D: search (search.c:49)
==8553==    by 0x4E3F181: start_thread (pthread_create.c:312)
==8553==    by 0x514F47C: clone (clone.S:111)
==8553== 
==8553== 48 bytes in 4 blocks are definitely lost in loss record 2 of 2
==8553==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8553==    by 0x40074E: main (search.c:24)
</code></pre>
<p>But it’s also important to learn what to ignore (or what’s out of our hands). I decided to deploy Valgrind on the solution to the producer-consumer problem from ECE 254 and I ended up with a result that says:</p>
<pre><code>==8734==      possibly lost: 544 bytes in 2 blocks</code></pre>
<p>Hmm. Let’s dig into that with the <code>--leak-check=full</code> option:</p>
<pre><code>==8734== 272 bytes in 1 blocks are possibly lost in loss record 1 of 2
==8734==    at 0x4C2CC70: calloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==8734==    by 0x4012E54: _dl_allocate_tls (dl-tls.c:296)
==8734==    by 0x4E3FDA0: pthread_create@@GLIBC_2.2.5 (allocatestack.c:589)
==8734==    by 0x400A57: main (mutex.c:64)</code></pre>
<p>Looking in the file, at that line, we see a call to <code>pthread_create</code> and this is therefore probably nothing we need to do anything about. Or is it? In-class example will tell...</p>
<p>From the Valgrind FAQ, how to read the leak summary:</p>
<ul>
<li><p><strong>Definitely lost</strong>: a clear memory leak. Fix it.</p></li>
<li><p><strong>Indirectly lost</strong>: a problem with a pointer based structure (e.g., you’ve lost the head of the linked list, but the rest of the list is indirectly lost.) Generally, fixing the definitely lost items should be enough to clear up the indirectly lost stuff.</p></li>
<li><p><strong>Possibly lost</strong>: the program is leaking memory unless weird things are going on with pointers where you’re pointing them to the middle of an allocated block.</p></li>
<li><p><strong>Still reachable</strong>: this is memory that was still allocated that might otherwise have been freed, but references to it exist so it at least wasn’t lost.</p></li>
<li><p><strong>Suppressed</strong>: you can configure the tool to ignore things and those will appear in the suppressed category.</p></li>
</ul>
<h3 id="helgrind" class="unnumbered">Helgrind</h3>
<p>The purpose of Helgrind is to detect errors in the use of POSIX pthreads. In a way, Helgrind is a pretty neat tool for improving performance, even though it doesn’t actually directly speed anything up. When we take a single-threaded program and split it off into a multithreaded program, we may introduce a lot of errors (or at least, introduce the possibility of a lot of errors). Truthfully, humans are not very good at parallel thinking; we are very much sequential. But a program that is fast and wrong is probably less useful than one that is slow and correct. Can we make it faster and still have it be correct? That’s the goal of Helgrind: after you parallelize your code, it will do some automatic checking of the code to determine where, if anywhere, there are concurrency problems. It can’t prove that your program is correct (if only) but it can at least catch some of the common problems you might introduce when writing a parallel program. Helgrind classifies errors into three basic categories:</p>
<ol>
<li><p>Misuses of the pthreads API;</p></li>
<li><p>Lock ordering problems; and</p></li>
<li><p>Data races.</p></li>
</ol>
<p>The first category does not require much explanation. These are just some programming errors related to the pthread API calls. Some examples from <span class="citation" data-cites="helgrind"></span>:</p>
<ul>
<li><p>Unlocking a mutex that is unlocked;</p></li>
<li><p>Deallocation of memory with a locked mutex in it; or</p></li>
<li><p>Thread exit while holding a lock.</p></li>
</ul>
<p>…and many more.</p>
<p>A quick example of an error message from Helgrind, also from <span class="citation" data-cites="helgrind"></span>:</p>
<pre><code>Thread #1 unlocked a not-locked lock at 0x7FEFFFA90
   at 0x4C2408D: pthread_mutex_unlock (hg_intercepts.c:492)
   by 0x40073A: nearly_main (tc09_bad_unlock.c:27)
   by 0x40079B: main (tc09_bad_unlock.c:50)
  Lock at 0x7FEFFFA90 was first observed
   at 0x4C25D01: pthread_mutex_init (hg_intercepts.c:326)
   by 0x40071F: nearly_main (tc09_bad_unlock.c:23)
   by 0x40079B: main (tc09_bad_unlock.c:50)</code></pre>
<p>The second category of errors should be familiar to you from earlier as a source of potential deadlock.</p>
<p><span>2</span>
<strong>Thread P</strong></p>
<pre><code>     1. wait( a ) 
     2. wait( b )
     3. [critical section]
     4. signal( a )
     5. signal( b )</code></pre>
<p><strong>Thread Q</strong></p>
<pre><code>     1. wait( b ) 
     2. wait( a )
     3. [critical section]
     4. signal( b )
     5. signal( a )</code></pre>
<p>In this case, if the interleaving of these happens to work out in a couple of particular ways, then we get deadlock because thread P holds mutex <code>a</code> and thread Q holds mutex <code>b</code> and each waits for the mutex that the other one has. The example is slightly silly, of course, because it’s super easy to see; in normal code they would probably be separated by some number of lines, and the mutexes will probably not be called <code>a</code> and <code>b</code> (isn’t using meaningful variable names one of those things you were supposed to learn to do in introductory programming) and there therefore will not necessarily be an obvious (alphabetical) order.</p>
<p>Helgrind builds a directed graph of lock acquisitions. When a thread acquires a lock, Helgrind checks to see whether a cycle exists. If so, then there is potential for a deadlock <span class="citation" data-cites="helgrind"></span>. Helgrind will report as an error the initial order (the first order seen is the one viewed as “correct”) and the “incorrect” order that is the source of the potential problem. Really, though, all that matters is consistency—following the same order. You may change either of the acquisition orders to match the other. See the example below <span class="citation" data-cites="helgrind"></span>:</p>
<pre><code>Thread #1: lock order &quot;0x7FF0006D0 before 0x7FF0006A0&quot; violated

Observed (incorrect) order is: acquisition of lock at 0x7FF0006A0
   at 0x4C2BC62: pthread_mutex_lock (hg_intercepts.c:494)
   by 0x400825: main (tc13_laog1.c:23)

 followed by a later acquisition of lock at 0x7FF0006D0
   at 0x4C2BC62: pthread_mutex_lock (hg_intercepts.c:494)
   by 0x400853: main (tc13_laog1.c:24)

Required order was established by acquisition of lock at 0x7FF0006D0
   at 0x4C2BC62: pthread_mutex_lock (hg_intercepts.c:494)
   by 0x40076D: main (tc13_laog1.c:17)

 followed by a later acquisition of lock at 0x7FF0006A0
   at 0x4C2BC62: pthread_mutex_lock (hg_intercepts.c:494)
   by 0x40079B: main (tc13_laog1.c:18)</code></pre>
<p>The third category we have discussed already. Recall the earlier definition of a race condition. This is a difficult problem to find sometimes; what Helgrind will do is examine where multiple threads are accessing shared memory without the use of locks. Let’s cut to the chase and see it in action:</p>
<pre><code>jz@Loki:~/ece459$ valgrind --tool=helgrind ./datarace
==10389== Helgrind, a thread error detector
==10389== Copyright (C) 2007-2013, and GNU GPL&#39;d, by OpenWorks LLP et al.
==10389== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==10389== Command: ./datarace
==10389== 
==10389== ---Thread-Announcement------------------------------------------
==10389== 
==10389== Thread #1 is the program&#39;s root thread
==10389== 
==10389== ---Thread-Announcement------------------------------------------
==10389== 
==10389== Thread #2 was created
==10389==    at 0x515543E: clone (clone.S:74)
==10389==    by 0x4E44199: do_clone.constprop.3 (createthread.c:75)
==10389==    by 0x4E458BA: pthread_create@@GLIBC_2.2.5 (createthread.c:245)
==10389==    by 0x4C30C90: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so)
==10389==    by 0x40068D: main (datarace.c:12)
==10389== 
==10389== ----------------------------------------------------------------
==10389== 
==10389== Possible data race during read of size 4 at 0x60104C by thread #1
==10389== Locks held: none
==10389==    at 0x40068E: main (datarace.c:13)
==10389== 
==10389== This conflicts with a previous write of size 4 by thread #2
==10389== Locks held: none
==10389==    at 0x40065E: child_fn (datarace.c:6)
==10389==    by 0x4C30E26: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so)
==10389==    by 0x4E45181: start_thread (pthread_create.c:312)
==10389==    by 0x515547C: clone (clone.S:111)
==10389== 
==10389== ----------------------------------------------------------------
==10389== 
==10389== Possible data race during write of size 4 at 0x60104C by thread #1
==10389== Locks held: none
==10389==    at 0x400697: main (datarace.c:13)
==10389== 
==10389== This conflicts with a previous write of size 4 by thread #2
==10389== Locks held: none
==10389==    at 0x40065E: child_fn (datarace.c:6)
==10389==    by 0x4C30E26: ??? (in /usr/lib/valgrind/vgpreload_helgrind-amd64-linux.so)
==10389==    by 0x4E45181: start_thread (pthread_create.c:312)
==10389==    by 0x515547C: clone (clone.S:111)
==10389== 
==10389== 
==10389== For counts of detected and suppressed errors, rerun with: -v
==10389== Use --history-level=approx or =none to gain increased speed, at
==10389== the cost of reduced accuracy of conflicting-access information
==10389== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</code></pre>
<p>Note that we get two stack traces here: we have a read after write, and a write after write. Why? Because the operation in question is <code>var++</code> which necessitates fetching the current value of <code>var</code> (reading it) and incrementing it (then writing it back).</p>
<p>How does Helgrind work? It examines the use of the standard threading primitives—lock, unlock, signal/post, wait, etc. Anything that implies there might be an ordering between events is taken and added to a directed acyclic graph that represents these dependencies. If memory is accessed from two different threads and there is no path through this directed acyclic graph that indicates an ordering, then Helgrind reports a race <span class="citation" data-cites="helgrind"></span>. Obviously, at least one of these accesses must be a write. (Recall: there is no read after read dependency).</p>
<p>Also cool: you can ask Helgrind to try to tell you about variable names (if it can) with the command line option <code>–read-var-info=yes</code>. Then it will tell you something interesting like:</p>
<pre><code>==10454== Location 0x60104c is 0 bytes inside global var &quot;var&quot;
==10454== declared at datarace.c:3</code></pre>
<p>These will give you indications of where you need to introduce synchronization of some kind (semaphore, mutex, condition variable, etc). The authors of Helgrind assume that if it tells you where the problem is, you will figure out what variables are affected and how to properly prevent data races. You might find this frustrating, in the sense of a serial complainer who thinks that he or she can just moan about what’s wrong without bringing forward any suggestions about how to fix the problems.</p>
<h1 id="the-time-war" class="unnumbered">25 — The Time War</h1>
<h2 id="in-class-exercise-gallifrey-stands" class="unnumbered">In Class Exercise: Gallifrey Stands!</h2>
<h5 id="background.-2">Background.</h5>
<p>It is the last day of the Time War. The Daleks have launched their final assault on the Time Lords’ home planet of Gallifrey. Ten million Dalek ships surround the planet and are bombarding it from orbit and sending landing parties. The War Doctor has stolen an ancient weapon called The Moment. It will wipe out the Daleks – but also Gallifrey, and everyone on it.</p>
<p>But there’s another way. Through hundreds and hundreds of years’ worth of calculations The Doctor can use stasis technology to freeze the whole planet of Gallifrey in a parallel pocket universe. The Daleks will be obliterated in the crossfire and it would look like they wiped each other out. This takes hundreds and hundreds of years of calculations and the power of every one of the thirteen incarnations’ TARDISes.</p>
<p>This won’t be easy – the timing has to be just right and the Doctors have to coordinate their actions and timing and work together to save Gallifrey. If their timing is wrong or if things are out of sync or important steps are skipped, the Doctors will fail and Gallifrey falls. If you can find and correct the problems in the program, then Gallifrey stands!</p>
<h5 id="primary-objective.-2">Primary Objective.</h5>
<p>The primary objective of this exercise is to identify and solve memory management and concurrency problems in the provided code.</p>
<h5 id="secondary-objectives.-2">Secondary Objective(s).</h5>
<p>This is an additional opportunity to practice concurrency and synchronization techniques. You may also improve your ability to work with version control (git) and gitlab.</p>
<h5 id="starter-code.-2">Starter Code.</h5>
<p>The starter code can be found at <a href="https://git.uwaterloo.ca/ece252-1195/ece252-e3">https://git.uwaterloo.ca/ece252-1195/ece252-e3</a> – fork this repository to your own space. Set permissions for this repository to be private, but add the course instructor with developer access so your code can be evaluated.</p>
<h5 id="submitting-your-code.-2">Submitting Your Code.</h5>
<p>When you’re done, use the command <code>git commit -a</code> to add all files to your commit and enter a commit message. Then <code>git push</code> to upload your changes to your repository. You can commit and push as many times as you like; we’ll look at whatever was last pushed. And check that you gave the course instructor permissions!</p>
<h5 id="grading.-2">Grading.</h5>
<p>Binary grading: 1 if you have made a meaningful attempt at implementing the code; 0 otherwise.</p>
<h5 id="description-of-behaviour.-2">Description of Behaviour.</h5>
<p>The goal is to analyze and correct the program so that there are no longer any errors (that you can fix in your program) reported by Helgrind, and also no memory leaks/issues (that you can fix in your program) reported by Valgrind.</p>
<p>When you compile and run the starter code, the program may crash or hang when executed. Those are just two of the symptoms of problems present. There are a total of nine (9) different problems in the code to be resolved. Some will be found by the memcheck tool of Valgrind; others will be found by the Helgrind tool. If you read the error messages carefully, you will be able to identify the causes of the problems and fix them.</p>
<p>There will be some things reported by both tools that are beyond your ability to fix (because they are in libraries) or otherwise misreported. You’ll need to examine the messages carefully and decide if it is something you can fix or not. If not, just leave it be. Generally speaking, errors reported by memcheck need to be fixed; those reported by Helgrind need to be examined more carefully.</p>
<p>If something is wrong, you may see "Gallifrey falls" as an output message at the end of your program. If everything goes well you will see the message "Gallifrey Stands!" at the end of the program, but just seeing that that is not enough. You also need a clean bill of health from Valgrind and Helgrind.</p>
<h5 id="hints-debugging-guidance.-2">Hints &amp; Debugging Guidance.</h5>
<p>Some general guidance is below. If you’re having trouble, try running through these steps and it may resolve your problem. If you’re still stuck you can ask a neighbour or the course instructor.</p>
<ul>
<li><p>Check the documentation for how functions work if you are unfamiliar with them (google is your friend!)</p></li>
<li><p>See the docs for Valgrind <span class="citation" data-cites="valgrind:tools"></span>.</p></li>
<li><p>Read the valgrind error messages carefully: they usually tell you which function (i.e., which doctor) the problem occurs in. This helps you narrow it down</p></li>
<li><p>It may be helpful to put <code>printf()</code> statements to follow along what the program is doing and it may help you narrow down where the issue is.</p></li>
<li><p>Don’t be shy about asking for help; the TAs and instructor are here to help you get it done and will help you as much as is reasonable.</p></li>
</ul>
<h1 id="the-byzantine-generals-problem" class="unnumbered">26 — The Byzantine Generals Problem</h1>
<h2 id="istanbul-was-constantinople" class="unnumbered">Istanbul was Constantinople</h2>
<p>Byzantium was an ancient Greek city, rebuilt by Constantine the Great under the name of Constantinople. It is now modern day Turkey. The word Byzantine refers to things relating to the empire based there, but in English has also come to mean a thing that is excessively complicated. But it’s the last “extra” meaning that we want to talk about: characterized by deviousness. The Byzantine Empire was characterized by deviousness, alright: it was a place where generals and leaders would vie for power in underhanded ways, backstabbing and sabotaging others when they thought it was to their advantage. I guess it was very <em>Game of Thrones</em>, now that I think of it.</p>
<p>Where this crosses over into the realm of programming is in dealing with the unreliable nature of systems. It’s not that we think that somewhere out there one of the processes in the system is malicious and trying to make the system fail... although that could happen... but our normal expectation is that the systems interacting may be faulty or have errors or bugs, not malicious intent.</p>
<p>However we get here, though, we still need a way to deal with the fact that not everyone agrees and sometimes messages get mixed up. And that is a communication problem, yes, but also a coordination problem as well. And if you’ve tried to get a group of five people to agree on where to go to lunch you may have found it unexpectedly difficult... now imagine that one person is (unintentionally or otherwise) trying to sabotage the planning so organizing lunch will fail.</p>
<p>The generic form of the Byzantine Generals problem looks something like this. There is a <em>General</em> who is giving the orders. There are also <span class="math inline">n</span> <em>Lieutenants</em> who each are commanding a group of the Empire’s troops. The individual troops just do what they’re told so there’s no further concern for their actions. The lieutenants can communicate with one another through messages, and they get their orders from the general. All of the lieutenants have to work together for their plan to be a success, otherwise there is chaos.</p>
<p>No problem, you might imagine. The general tells the lieutenants what to do and they do it! And if one of the lieutenants does the wrong thing, that lieutenant is a traitor. But it’s not so simple, because the general can be disloyal too. Horrible Bosses: Byzantium!</p>
<p>Suppose you are a disloyal general. Your Emperor has commanded you to attack, but you want the attack to fail, but also seem like it’s not your fault. What do you do? You can issue different orders to different lieutenants, they will be all confused and uncoordinated, and oh gee darn, I guess the attack didn’t go as planned! And you can blame the lieutenants who are now dead for going too early, or something, because it’s not like they can defend themselves now...</p>
<p>So a loyal general sends the same message to all lieutenants and a disloyal one sends different messages to different lieutenants. It’s key to remember that “loyal” really means “functioning” and “disloyal” means “faulty” <span class="citation" data-cites="mte241"></span>. It’s fun to make it seem like human actors are doing things for their own evil-villainy-related reasons, but it is just computer interaction that presumably has no actual malicious intent. It’s also worth noting that being in one state or the other is not permanent: a functioning unit can be damaged, a malfunctioning one can be repaired, or a problem can be transient (i.e., some electromagnetic interference flipped a bit here or there) and resolve itself with no further action.</p>
<p>One of the key decisions is about how much disloyalty your system can tolerate. Given enough bad actors, things will go wrong. If everyone is disloyal, utter chaos will result. But is it enough to tolerate one disloyal participant? Two? The line will have to be drawn somewhere... But at the very least we don’t want to let one disloyal individual ruin things for everyone, even if that disloyal individual is the boss.</p>
<h3 id="should-i-stay-or-should-i-go-now" class="unnumbered">Should I Stay or Should I Go Now?</h3>
<p>In the examples that we will discuss there are two kinds of command: attack and retreat. In a real system the options don’t have to be quite so binary (we could give any orders) but for the purpose of demonstration and coming to grips with this problem we’ll use the binary example. Attack or retreat.</p>
<p>It is possible that our system produces a tie (no matter how many participants or possible actions we have). This usually necessitates a default action be selected. So if we cannot come to a decision, we take the default choice. Usually we say that the default choice is to retreat.</p>
<p>Consider the diagram below where we have a disloyal general, and two loyal lieutenants. In our examples in this section we’ll use G for generals, L for lieutenants, and we’ll make disloyal participants red and loyal ones grey.</p>
<p>What are lieutenants to do? In the imperfect world of Byzantium the lieutenants can try to figure out if they’re about to be mismanaged to literal death by communicating with one another. If they are all on the same page then they can do what they’re supposed to do; if they’re not, then they will fall back on the default option.</p>
<p>Unfortunately, though, letting the lieutenants communicate is not a complete solution. Because lieutenants can lie, even if the general doesn’t.</p>
<p>In general if there are <span class="math inline">d</span> disloyal participants, we will need there to be more than <span class="math inline">3d</span> participants for the loyal lieutenants to agree on what to do. If the general is loyal, then at least <span class="math inline">2d</span> loyal lieutenants are needed to obey the orders; if the general is disloyal then <span class="math inline">2d+1</span> loyal lieutenants are needed so they can come up with a course of action <span class="citation" data-cites="mte241"></span>.</p>
<p>Let’s imagine that there is at most one disloyal participant. If that’s the case then all lieutenants should compare notes and decide on the majority course of action. Each lieutenant compiles a little table (or array or vector, whatever) of the data received and then decide on what the majority cause of action is. It might be simpler to just count the total number of votes, but it would make it harder to figure out later who the traitor is (if there is one).</p>
<p>What if we can have two disloyal participants? Each lieutenant sending its messages and using a majority-wins vote isn’t necessarily going to work here. It can happen that the general is disloyal and one of the lieutenants is a collaborator. Consider this scenario below from <span class="citation" data-cites="mte241"></span> where the general is disloyal and sends mixed instructions. What can the collaborating lieutenant do to make sure that the other lieutenants don’t come to an agreement?</p>
<p>The lieutenants all send one another their instructions. Each of the loyal lieutenants sends its received command and received the honest answer from three other lieutenants. The score is 3 attack and 3 retreat. The disloyal lieutenant sends one message to half the other participants, and a different message to the other half.</p>
<p>Now we’re in trouble because half the participants think the majority action is attack and half the participants think the majority action is retreat. Summing up what we heard is not sufficient. Lieutenants should also talk about what they heard from one another. After the general issues instructions, each lieutenant should then communicate with every other to hear what the general said to them. Then by reviewing this information, they can decide what to do.</p>
<p>Consider a simple example where the general is loyal and we have two traitorous lieutenants with a total of seven participants. The general issued an order to attack.</p>
<p>So each lieutenant constructs the following vector. We’re not sure if the general is a traitor, but we’ll take notes from every other participant, and see what they report. The general form is as follows, where <span class="math inline">v_{x}</span> is the forwarded order we received from lieutenant <span class="math inline">x</span>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6}</span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>So if we are lieutenant 1, we complete the table as below. The value for L1 is what we received from the general, but we get the remaining values from the other lieutenants.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Then the lieutenants just compare notes on this subject as well! They send to one another their vectors and assemble them into a table. Whatever lieutenant <span class="math inline">x</span> received in the first round forms row <span class="math inline">x</span> of the table, and the other rows are added from this second round of communication. In the table each value <span class="math inline">v_{i,j}</span> is interpreted as “Lieutenant <span class="math inline">i</span> says that Lieutenant <span class="math inline">j</span> reports the general said <span class="math inline">v</span>”. The entries on the diagonal are redundant because of course each lieutenant agrees with itself:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{1,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{1,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{1,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{1,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{1,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{1,6}</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{2,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{2,6}</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{3,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{3,6}</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{4,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{4,6}</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{5,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{5,6}</span></td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;"><span class="math inline">v_{6,1}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6,2}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6,3}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6,4}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6,5}</span></td>
<td style="text-align: left;"><span class="math inline">v_{6,6}</span></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Those “redundant” entries (the ones on the diagonal) need to be removed from the table. From the point of view of lieutenant 1, let’s imagine the table looks like this (filling in for the sake of the example that L5 and L6 always say retreat).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>One the thing we can do, however, is fill in the first column: lieutenant 1 does not care what other people THINK they said; so the whole column can be replaced with what was actually said:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>Then we’ll try to figure out the majority vote for each <span class="math inline">j</span> in the table. So sum up each column:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<p>And we have four lieutenants who think the general said attack and two who think the general said retreat. The majority wins and the attack proceeds. Onward to victory, brothers and sisters!</p>
<p>If there was one less loyal lieutenant, though, we could have a tie here which would result in picking the default value. If the general ordered something other than the default value (e.g., default is retreat and the order was attack) the general will not be happy about this...</p>
<p>You may have figured out that since disloyal participants can lie at any step of the equation, we can’t rely on their data at all. That’s true! In the examples in the course we know that two participants are traitors and I’ve said they are L5 and L6. Therefore we could replace whatever they say with a question mark in the able rather than any particular answer, because they are liars. In real life though, <em>some</em> message is received – attack or retreat – and it’s only later we could identify which participants are the traitors.</p>
<p>Let’s go back to the example of having eight participants: one general and seven lieutenants. So if we are lieutenant 1, we complete the table as below. The value for L1 is what we received from the general, but we get the remaining values from the other lieutenants.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;">L7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
</tbody>
</table>
<p>However, if we are lieutenant 7 our vector looks like this instead:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;">L7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
</tbody>
</table>
<p>From the point of view of lieutenant 1 the table is formed then as follows:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;">L7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
</tr>
</tbody>
</table>
<p>The fourth row is shown as all question marks. Why? Lieutenant 4 is the traitor and could also lie about what the other lieutenants said. Then replace the first column.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;">L7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">?</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
<tr class="even">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
<td style="text-align: left;">R</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;"> </td>
</tr>
</tbody>
</table>
<p>Sum up each column:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">General</th>
<th style="text-align: left;">L1</th>
<th style="text-align: left;">L2</th>
<th style="text-align: left;">L3</th>
<th style="text-align: left;">L4</th>
<th style="text-align: left;">L5</th>
<th style="text-align: left;">L6</th>
<th style="text-align: left;">L7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">A</td>
<td style="text-align: left;">?</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
<td style="text-align: left;">R</td>
</tr>
</tbody>
</table>
<p>Each of the lieutenants figures out that we have a draw and we then choose the default choice. Well, that’s grim, but it makes sense: the general issued contradictory orders and the collaborating lieutenant did the same. But now instead of half the lieutenants charging in and dying while the others hang back and watch, everyone takes the same action, even if it’s not the one that helps the Empire the most.</p>
<p>If there three disloyal participants can exist in the system there’s another round of data exchange that needs to take place. Each lieutenant sends the table formed in the second round to all other lieutenants. The more disloyalty there could be in the system, the more rounds the process will go on. As you may have identified, for <span class="math inline">n</span> participants the communication grows at <span class="math inline">n^{2}</span> (well, actually worst case <span class="math inline">dn^{2}</span> <span class="citation" data-cites="mte241"></span>) and even worse than that, as the number of participants and rounds increases, the amount of data to be sent also increases. For this reason it is somewhat impractical to tolerate a large number of disloyal participants.</p>
<p>That is, however, still a design decision...</p>
<p>Part of the difficulty comes from the fact that lieutenants can lie about what the general said. In the time of Byzantium, wax seals were used (hot wax is poured and then a stamp or ring was used to make an imprint on it). In modern times messages can be signed using public-key cryptography. Then participants can check whether the received message was genuine. An order that does not appear genuine can be disregarded, reducing the ability of disloyal lieutenants to cause confusion.</p>
<p>The Byzantine Generals Problem has applicability in all kinds of systems, from space flight to cryptocurrency. Whenever we have multiple “agents” of some sort that come to their own conclusions about what to do, we can face this issue. As long as we know this, we can design our system with this in mind, because pretending it’s not going to happen is not a real solution...</p>
<h1 id="concurrency-in-file-systems" class="unnumbered">27 — Concurrency in File Systems</h1>
<h2 id="concurrency-in-file-systems-1" class="unnumbered">Concurrency in File Systems</h2>
<p>To understand the idea of concurrency in file systems, we need to peel back the interface a bit and have at least a high-level understanding of their implementation. File can be of arbitrary size (although in a particular file system there may be a limit), so they have to be allocated on disk according to some strategy.</p>
<p>The contiguous allocation strategy means that a file occupies a set of contiguous blocks on disk. So a file is allocated, starting at block <span class="math inline">b</span> and is <span class="math inline">n</span> blocks in size, the file takes up blocks <span class="math inline">b, b+1, b+2, ..., b+(n-1)</span>. But for a sufficiently large file, it might be difficult to find a place to put it. And we also don’t know how to predict the size of a file, so how much space do we leave for where to put it?</p>
<p>Linked allocation is a solution to the problems of contiguous allocation: instead of a file being all in consecutive blocks, we maintain a linked list of the blocks, and the blocks themselves may be located anywhere on the disk. The directory listing just has a pointer to the first and last blocks (head and tail of the linked list). Unfortunately, however, accessing block <span class="math inline">i</span> of a file is no longer as simple as computing an offset from the first block; it requires following <span class="math inline">i</span> pointers (a pain). If we want to go to the middle of a file, why do we have to load every block on the way there?</p>
<p>There’s a compromise approach: indexed allocation. The idea of indexed allocation is to take all the pointers and put them into one location: an index block. So, the first block of the file contains a whole bunch of pointers. To get to block <span class="math inline">i</span>, just go to index <span class="math inline">i</span> of the index block and we can get the location of block <span class="math inline">i</span> much more efficiently than we could in linked allocation. All pointers to blocks start as null, and when we add a new block, add its corresponding entry into the index block <span class="citation" data-cites="osc"></span>. See the diagram below:</p>
<ol>
<li><p><strong>Linked Scheme</strong>: An index block is a disk block, and we can link together several index blocks. The last entry in the index block is either null or a pointer to the next index block.</p></li>
<li><p><strong>Multilevel Index</strong>: A variant of the linked scheme that has multiple levels. The first level block points to the second level block; the second level block points to the actual file data. This can go to as many levels are necessary based on the maximum file size. If a block is 4 KB, we can have 1024 4-byte pointers, so two levels would allow a maximum file size of up to 4 GB.</p></li>
<li><p><strong>Combined Scheme</strong>: The all-of-the-above option. This is used in UNIX. Keep the first 15 pointers of the index block in the inode structure; 12 of them point directly to file data. The next three pointers refer to indirect blocks. The 13th is an index block containing the addresses of blocks with data. The 14th points to a double indirect block (addresses of blocks containing addresses of blocks). The 15th points to a triple indirect block<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.</p></li>
</ol>
<p>With that out of the way, we can show a visual representation of an inode. This is just another sort of data structure, except it is stored in persistent storage. It will be helpful to keep this in mind. When we lock a file, implicitly we need to know which inode we are locking.</p>
<p><img src="images/unix-inode.png" alt="image" style="width:60.0%" /><br />
The UNIX inode. Triple indirection is left to the reader’s imagination <span class="citation" data-cites="osc"></span>.</p>
<p>We already discussed the use of <code>flock()</code> to lock a file, and this locks the entire file. There exists another way to lock a file, using <code>fcntl</code>, in which case we can lock only a part of a file, specifically a byte range of that file. This is referred to as <em>record locking</em>.</p>
<p>Locking just a part of the file allows for more concurrency: if a process is writing the beginning of the file, another one can be writing the end of the file and these don’t overlap so the second write does not need to wait. Let’s see how to do that. The function is found in the header <code>fcntl.h</code>. Here’s the function signature:</p>
<div class="sourceCode" id="cb198" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb198-1" title="1"><span class="dt">int</span> fcntl( <span class="dt">int</span> file_descriptor, <span class="dt">int</span> command, ... <span class="co">/* struct flock * flockptr */</span> )</a></code></pre></div>
<p>This one looks strange! It turns out that <code>fcntl</code> can do a lot of things, and only sometimes the third argument is needed. So it is a <code>...</code> (list of args) but we would only fill it with one <code>struct flock</code> if we need to based on the value of <code>command</code>. They could have just overloaded this function, but, well, here we are.</p>
<p>The <code>struct flock</code> has the following definition <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb199" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb199-1" title="1"><span class="kw">struct</span> flock {</a>
<a class="sourceLine" id="cb199-2" title="2">  <span class="dt">short</span>  l_type;   <span class="co">/* F_RDLCK, F_WRLCK, or F_UNLCK */</span></a>
<a class="sourceLine" id="cb199-3" title="3">  <span class="dt">short</span>  l_whence; <span class="co">/* SEEK_SET, SEEK_CUR, or SEEK_</span><span class="re">END</span><span class="co"> */</span></a>
<a class="sourceLine" id="cb199-4" title="4">  off_t  l_start;  <span class="co">/* offset in bytes, relative to l_whence */</span></a>
<a class="sourceLine" id="cb199-5" title="5">  off_t  l_len;    <span class="co">/* length, in bytes; 0 means lock to EOF */</span></a>
<a class="sourceLine" id="cb199-6" title="6">  pid_t  l_pid;    <span class="co">/* returned with F_GETLK */</span></a>
<a class="sourceLine" id="cb199-7" title="7">};</a></code></pre></div>
<p>Much like the readers-writers locks, the types of locks are read and write. The compatibility matrix is exactly what you would expect: read locks are compatible with other read locks; write locks are not compatible with any other lock. And finally, to unlock, you still use the set-lock functionality, but with type <code>F_UNLCK</code>. This sort of locking scheme is vulnerable to deadlock, as it’s possible for a process to lock file 1 and need file 2 while another process has a lock on file 2 and needs the lock on file 1.</p>
<p>The value of <code>l_whence</code> is going to be one of the three constants named in the comment above. This refers to where the offset begins. <code>SEEK_SET</code> means at the start of the file. So if you specify <code>SEEK_SET</code> and an offset of <code>1000</code> it means the locked region begins 1000 bytes after the start of the file. <code>SEEK_END</code> means the relative point is the end of the file. Finally, <code>SEEK_CUR</code> means based on the current position in the file (if you’ve positioned within the file using <code>seek()</code> this makes sense).</p>
<p>It is possible for a locked region to extend past the end of the file. This is used when appending to the file, so you don’t have to know in advance how much you plan to append to the file. If 0 is given for the length that does include anything appended to the file as well.</p>
<p>For <code>command</code>, our choices are <span class="citation" data-cites="apunix"></span>:</p>
<ul>
<li><p><code>F_GETLK</code> – Determine if the lock described by <code>flockptr</code> is blocked by some other lock. If a lock exists, the content of <code>flockptr</code> is overwritten with the data of the lock; if no lock exists then the <code>l_type</code> field is set to <code>F_UNLCK</code>.</p></li>
<li><p><code>F_SETLK</code> – Set the lock as described by <code>flockptr</code>. If the lock cannot be acquired then the return value of the function returns an error and <code>errno</code> are set. This is “trylock”-behaviour and can be used to avoid the possibility of a deadlock.</p></li>
<li><p><code>F_SETLKW</code> – A blocking version of the <code>F_SETLK</code> command. If the region we want to lock is currently in use then the caller gets blocked.</p></li>
</ul>
<p>When unlocking a region, just as for locking, you can specify what part of the file you would like to unlock. Partial unlocking is unusual, but why not? The system will combine or split locks as appropriate, based on what is to be locked or unlocked.</p>
<p>Let’s do some examples on how to use this structure and system call. The first example is how to lock a file and then how to unlock it:</p>
<div class="sourceCode" id="cb200" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb200-1" title="1"><span class="dt">int</span> write_lock_file( <span class="dt">int</span> file_descriptor ) {</a>
<a class="sourceLine" id="cb200-2" title="2"></a>
<a class="sourceLine" id="cb200-3" title="3">  <span class="kw">struct</span> flock fl;</a>
<a class="sourceLine" id="cb200-4" title="4">  fl.l_type = F_WRLOCK;</a>
<a class="sourceLine" id="cb200-5" title="5">  fl.l_start = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb200-6" title="6">  fl.l_whence = SEEK_SET;</a>
<a class="sourceLine" id="cb200-7" title="7">  fl.l_len = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb200-8" title="8">  </a>
<a class="sourceLine" id="cb200-9" title="9">  <span class="cf">return</span> fcntl( fd, F_SETLK, &amp;fl );</a>
<a class="sourceLine" id="cb200-10" title="10">}</a>
<a class="sourceLine" id="cb200-11" title="11"></a>
<a class="sourceLine" id="cb200-12" title="12"><span class="dt">int</span> unlock_file( <span class="dt">int</span> file_descriptor ) {</a>
<a class="sourceLine" id="cb200-13" title="13"></a>
<a class="sourceLine" id="cb200-14" title="14">  <span class="kw">struct</span> flock fl;</a>
<a class="sourceLine" id="cb200-15" title="15">  fl.l_type = F_UNLCK;</a>
<a class="sourceLine" id="cb200-16" title="16">  fl.l_start = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb200-17" title="17">  fl.l_whence = SEEK_SET;</a>
<a class="sourceLine" id="cb200-18" title="18">  fl.l_len = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb200-19" title="19">  </a>
<a class="sourceLine" id="cb200-20" title="20">  <span class="cf">return</span> fcntl( fd, F_SETLK, &amp;fl );</a>
<a class="sourceLine" id="cb200-21" title="21">}</a></code></pre></div>
<p>Obviously if you wished to have a different type of lock or to only lock a specific range, then you would need different values in the structure. Now for checking if a given part of a file is locked:</p>
<div class="sourceCode" id="cb201" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb201-1" title="1"><span class="dt">int</span> fd = open ( <span class="st">&quot;example.txt&quot;</span>, O_RDONLY );</a>
<a class="sourceLine" id="cb201-2" title="2"><span class="kw">struct</span> flock lock;</a>
<a class="sourceLine" id="cb201-3" title="3"></a>
<a class="sourceLine" id="cb201-4" title="4">lock.l_type = F_RDLOCK;</a>
<a class="sourceLine" id="cb201-5" title="5">lock.l_start = <span class="dv">1024</span>;</a>
<a class="sourceLine" id="cb201-6" title="6">lock.l_whence = SEEK_SET;</a>
<a class="sourceLine" id="cb201-7" title="7">lock.l_len = <span class="dv">256</span>;</a>
<a class="sourceLine" id="cb201-8" title="8"></a>
<a class="sourceLine" id="cb201-9" title="9">fcntl( fd, F_GETLK, &amp;lock );</a>
<a class="sourceLine" id="cb201-10" title="10"><span class="cf">if</span> ( lock.l_type == F_UNLCK ) {</a>
<a class="sourceLine" id="cb201-11" title="11">    <span class="co">/* Lock is unlocked; we may proceed */</span></a>
<a class="sourceLine" id="cb201-12" title="12">} <span class="cf">else</span> <span class="cf">if</span> ( lock.l_type = F_WRLOCK ) {</a>
<a class="sourceLine" id="cb201-13" title="13">  <span class="co">/* File is write locked by a different process */</span></a>
<a class="sourceLine" id="cb201-14" title="14">  printf( <span class="st">&quot;File locked by process ID %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, lock.l_pid );</a>
<a class="sourceLine" id="cb201-15" title="15">  <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb201-16" title="16">}</a></code></pre></div>
<p>Checking on things with <code>F_GETLK</code> is really for information purposes only: you should not make decisions about whether to proceed based on this, because of course the sequence of “read of the value and then whatever operation you’d like to do next” is not atomic. Instead, use the command <code>F_SETLK</code> and actually try to set the lock. If <code>-1</code> is returned then locking was not successful. Or, if the plan is to wait, use <code>F_SETLKW</code> as one would expect.</p>
<p>It’s important to remember that <code>fcntl</code> changes some values of the <code>struct lock</code> so if you wanted to re-use it you need to make sure to reset it as appropriate. You can use the same <code>struct lock</code> later to unlock the thing that you locked, just do so carefully.</p>
<p>I’ll also take a minute to mention <code>lockf</code>: it is a simplified way of locking a file. While <code>fcntl</code> is more flexible, sometimes all we need is the simple version. According to the documentation:</p>
<div class="sourceCode" id="cb202" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb202-1" title="1"><span class="dt">int</span> lockf( <span class="dt">int</span> file_descriptor, <span class="dt">int</span> command, off_t length );</a></code></pre></div>
<p>The command options can be:</p>
<ul>
<li><p><code>F_LOCK</code> – Acquire an exclusive lock on the (section of the) file.</p></li>
<li><p><code>F_TLOCK</code> – Try to acquire an exclusive lock (try-lock behaviour).</p></li>
<li><p><code>F_ULOCK</code> – Unlock the indicated section of the file.</p></li>
<li><p><code>F_TEST</code> – Check if (a section of) the file is locked; 0 if it is unlocked and -1 if the file is locked.</p></li>
</ul>
<p>The length is an offset, and is based off the current position in the file. If zero is provided then it locks the whole file.</p>
<p>Two further notes: The file is automatically unlocked when the file descriptor is closed. And, on some systems <code>lockf</code> just calls <code>fcntl</code> but on some others they use different mechanisms. So don’t mix and match. If you lock a file with one function, unlock it with the matching one.</p>
<p>It is noteworthy that both kinds of lock are “advisory” only. That is, like the use of a semaphore or mutex, it only is really effective if everyone involved in accessing the shared resource follows the proper protocol and checks if access is permitted or not. Mandatory locks do exist, but are hard to use and are not recommended. Did you really want to know about mandatory locking? Well, check out this kernel.org documentation as to why you shouldn’t, but also how it works if you must: <a href="https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt">https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt</a>.</p>
<h3 id="using-a-file-as-a-lock" class="unnumbered">Using A File as a Lock</h3>
<p>We can use the very existence of a file as a way of controlling concurrency. For example, <code>git</code> places a file <code>index.lock</code> in a particular directory to indicate that an operation is in progress so two different <code>git</code> clients do not operate on the same repository at the same time. So that is one strategy: check if the file is present; if it is, the resource is “locked”, if no such file is present then it is “unlocked”.</p>
<p>If we want to check, we just try to <code>open()</code> the file, but unless we are careful this can lead to a problem if two processes want to create the file: if they both call <code>open</code>, they both might succeed. To get around this, we need to use the <code>flags</code> parameter of the call to open the file. See below.</p>
<div class="sourceCode" id="cb203" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb203-1" title="1"><span class="dt">int</span> open(<span class="dt">const</span> <span class="dt">char</span> *filename, <span class="dt">int</span> flags);  <span class="co">/* Returns a file descriptor if successful, -1 on error */</span></a>
<a class="sourceLine" id="cb203-2" title="2"><span class="dt">int</span> rename(<span class="dt">const</span> <span class="dt">char</span> *old_filename, <span class="dt">const</span> <span class="dt">char</span> *new_filename); <span class="co">/* Returns 0 on success , operates atomically */</span></a>
<a class="sourceLine" id="cb203-3" title="3"><span class="dt">int</span> remove(<span class="dt">const</span> <span class="dt">char</span> *filename) ; <span class="co">/* Deletes a file or directory, returns 0 on success, operates atomically */</span> </a></code></pre></div>
<p>When opening a file the following flags may be used for the <code>flags</code> parameter (and can be combined with bitwise OR, the <code>|</code> operator):</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Value</strong></th>
<th style="text-align: left;"><strong>Meaning</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>O_RDONLY</code></td>
<td style="text-align: left;">Open the file read-only</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>O_WRONLY</code></td>
<td style="text-align: left;">Open the file write-only</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>O_RDWR</code></td>
<td style="text-align: left;">Open the file for both reading and writing</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>O_APPEND</code></td>
<td style="text-align: left;">Append information to the end of the file</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>O_TRUNC</code></td>
<td style="text-align: left;">Initially clear all data from the file</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>O_CREAT</code></td>
<td style="text-align: left;">Create the file</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>O_EXCL</code></td>
<td style="text-align: left;">If used with <code>O_CREAT</code>, the caller MUST create the file; if the file exists it will fail</td>
</tr>
</tbody>
</table>
<p>We can combine the use of <code>open</code> with <code>rename</code> to get lock-like behaviour between different programs that share nothing except a common file system. The <code>open</code> call should be used to create the lock file, and fail if the file already exists. If we want we can use <code>remove</code> to delete the lock file if we want to let the next process try, but there’s an alternative option: <code>rename</code>.</p>
<p>Because the <code>rename</code> function is also atomic, we can use it too, and just rename the existing lock file rather than creating it and deleting it every time. Then programs that want their turn should use <code>rename</code>; if a process or thread does succeed in renaming the file it is that process or thread’s turn; otherwise, they have to wait. To unlock, just change the name back. Consider this simple example that uses threads (rather than processes):</p>
<div class="sourceCode" id="cb204" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb204-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb204-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb204-3" title="3"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb204-4" title="4"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb204-5" title="5"><span class="pp">#include </span><span class="im">&lt;sys/stat.h&gt;</span></a>
<a class="sourceLine" id="cb204-6" title="6"><span class="pp">#include </span><span class="im">&lt;sys/types.h&gt;</span></a>
<a class="sourceLine" id="cb204-7" title="7"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb204-8" title="8"></a>
<a class="sourceLine" id="cb204-9" title="9"><span class="pp">#define NUM_THREADS 10</span></a>
<a class="sourceLine" id="cb204-10" title="10"></a>
<a class="sourceLine" id="cb204-11" title="11"><span class="dt">int</span> lock_fd;</a>
<a class="sourceLine" id="cb204-12" title="12"><span class="dt">int</span> shared = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb204-13" title="13"></a>
<a class="sourceLine" id="cb204-14" title="14"><span class="dt">void</span>* run( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb204-15" title="15">  <span class="dt">int</span>* id = (<span class="dt">int</span>*) arg;</a>
<a class="sourceLine" id="cb204-16" title="16">  <span class="cf">while</span>( rename( <span class="st">&quot;file.lock&quot;</span>, <span class="st">&quot;file.locked&quot;</span> ) == -<span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb204-17" title="17">    printf(<span class="st">&quot;Thread %d waiting.</span><span class="sc">\n</span><span class="st">&quot;</span>, *id); </a>
<a class="sourceLine" id="cb204-18" title="18">  }</a>
<a class="sourceLine" id="cb204-19" title="19"></a>
<a class="sourceLine" id="cb204-20" title="20">  printf(<span class="st">&quot;Thread %d in critical section.</span><span class="sc">\n</span><span class="st">&quot;</span>, *id);</a>
<a class="sourceLine" id="cb204-21" title="21">  printf(<span class="st">&quot;Shared incremented from %d&quot;</span>, shared);</a>
<a class="sourceLine" id="cb204-22" title="22">  shared++;</a>
<a class="sourceLine" id="cb204-23" title="23">  printf(<span class="st">&quot; to %d.</span><span class="sc">\n</span><span class="st">&quot;</span>, shared);</a>
<a class="sourceLine" id="cb204-24" title="24">  rename(<span class="st">&quot;file.locked&quot;</span>, <span class="st">&quot;file.lock&quot;</span>); <span class="co">/* Unlock */</span></a>
<a class="sourceLine" id="cb204-25" title="25"></a>
<a class="sourceLine" id="cb204-26" title="26">  free( arg );</a>
<a class="sourceLine" id="cb204-27" title="27">  pthread_exit(NULL);</a>
<a class="sourceLine" id="cb204-28" title="28">}</a>
<a class="sourceLine" id="cb204-29" title="29"></a>
<a class="sourceLine" id="cb204-30" title="30"><span class="dt">void</span>* writer( <span class="dt">void</span>* arg ) {</a>
<a class="sourceLine" id="cb204-31" title="31">  <span class="co">/* Write data implementation not shown */</span></a>
<a class="sourceLine" id="cb204-32" title="32">  pthread_exit(NULL);</a>
<a class="sourceLine" id="cb204-33" title="33">}</a>
<a class="sourceLine" id="cb204-34" title="34"></a>
<a class="sourceLine" id="cb204-35" title="35"></a>
<a class="sourceLine" id="cb204-36" title="36"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb204-37" title="37">  lock_fd = open( <span class="st">&quot;file.lock&quot;</span>, O_CREAT | O_EXCL );  </a>
<a class="sourceLine" id="cb204-38" title="38">  <span class="cf">if</span> (lock_fd == -<span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb204-39" title="39">   printf( <span class="st">&quot;File creation failed.</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb204-40" title="40">   <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb204-41" title="41">  }</a>
<a class="sourceLine" id="cb204-42" title="42"></a>
<a class="sourceLine" id="cb204-43" title="43">  pthread_t threads[NUM_THREADS];</a>
<a class="sourceLine" id="cb204-44" title="44">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NUM_THREADS; i++) {</a>
<a class="sourceLine" id="cb204-45" title="45">    <span class="dt">int</span> * id = malloc( <span class="kw">sizeof</span>( <span class="dt">int</span> ) );</a>
<a class="sourceLine" id="cb204-46" title="46">    *id = i;</a>
<a class="sourceLine" id="cb204-47" title="47">    pthread_create( &amp;threads[i], NULL, run, id );</a>
<a class="sourceLine" id="cb204-48" title="48">  }</a>
<a class="sourceLine" id="cb204-49" title="49">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; NUM_THREADS; i++) {</a>
<a class="sourceLine" id="cb204-50" title="50">    pthread_join( threads[i], NULL );</a>
<a class="sourceLine" id="cb204-51" title="51">  }</a>
<a class="sourceLine" id="cb204-52" title="52">  close( lock_fd );</a>
<a class="sourceLine" id="cb204-53" title="53">  remove( <span class="st">&quot;file.lock&quot;</span> );</a>
<a class="sourceLine" id="cb204-54" title="54"></a>
<a class="sourceLine" id="cb204-55" title="55">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb204-56" title="56">}</a></code></pre></div>
<h1 id="more-concurrency-in-file-systems" class="unnumbered">28 — More Concurrency in File Systems</h1>
<h2 id="concurrency-in-file-systems-continued" class="unnumbered">Concurrency in File Systems, Continued</h2>
<h3 id="copy-modify-merge" class="unnumbered">Copy-Modify-Merge</h3>
<p>Thus far when we talk about modification of shared data we follow a model that could be described as “Lock-Modify-Unlock”. But you’ve also used <code>git</code> or some other version control system (<code>svn</code>) that uses a different model: Copy-Modify-Merge. Let’s take a minute to talk about that.</p>
<p>Using <code>git</code> or something else, you and your lab partner check out a repository. You make changes and then try to merge those changes. When changes are being applied, we want to make sure that all changes in a particular grouping (in version control, a commit) either succeed as a group or fail as a group and nothing is left half-done.</p>
<p>A <em>transaction</em> is a grouping of operations that belong together and should be treated as an indivisible unit. You will recall from a great deal of discussion on the subject of concurrency that bad things can happen when an intermediate state of a multiple-step operation becomes inadvertently visible. Most of the examples looked at things like <code>x++;</code> being a read, addition, and a write and how concurrent accesses to <code>x</code> could result in the wrong value being read or written. The solution is usually mutual exclusion: forcing other accesses to <code>x</code> to wait while some operation was in progress. And this of course also scales up so you could change <code>x, y, z, a, b, c</code> all in one go. But in the copy-modify-merge scenario, people can make their changes separately and then we try to put them all together.</p>
<p>A transaction has some sort of begin transaction statement at the beginning, then the operations to take place in the transaction, and finally an end transaction statement. Execution looks something like writing down the transaction into a log, doing the operations in the transaction, and when the last one is complete, if all went well, marking the transaction as successful.</p>
<p>In the case of version control, if there are merge conflicts then we are notified that the merge cannot take place until conflicts are resolved. But in file systems, the last write wins.</p>
<h3 id="you-have-15-unread-notifications..." class="unnumbered">You Have 15 Unread Notifications...</h3>
<p>Another way that we can use the file system (in Linux only!) for synchronization or concurrency control is through the use of <code>inotify</code>. Using this API, you can register your program as being interested in the events in the file system. We’ll come back to a definition of what an event is soon. But in short, you say you want to watch a file or directory, and when an event occurs, then your program is informed. Note that this is not a portable thing: it is Linux only.</p>
<p>The key steps are <span class="citation" data-cites="lpi"></span>:</p>
<ol>
<li><p>Use an initialization function to create the management structure (and get a file descriptor back to refer to it).</p></li>
<li><p>Then you tell the kernel what files you are interested in by adding them to the structure (you can also remove them).</p></li>
<li><p>To collect an event, use <code>read</code> on the file descriptor. Each call returns one or more event structures.</p></li>
<li><p>If you’re done, close the file descriptor representing the management structure, which conveniently cleans everything up for you.</p></li>
</ol>
<p>It is noteworthy that the mechanism is not recursive: so if you add a directory, that covers the files in that directory, but not subdirectories.</p>
<p>The API calls:</p>
<div class="sourceCode" id="cb205" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb205-1" title="1"><span class="dt">int</span> inotify_init( ); <span class="co">/* Returns file descriptor referring to the struct */</span></a>
<a class="sourceLine" id="cb205-2" title="2"><span class="dt">int</span> inotify_add_watch( <span class="dt">int</span> fd, <span class="dt">const</span> <span class="dt">char</span>* pathname, <span class="dt">uint32_t</span> mask );</a>
<a class="sourceLine" id="cb205-3" title="3"><span class="dt">int</span> inotify_rm_watch( <span class="dt">int</span> fd, <span class="dt">uint32_t</span> wd );</a></code></pre></div>
<p>Initialization doesn’t require any arguments, so that’s quite convenient.</p>
<p>Adding an item to the watch takes as an argument the inotify structure to add it to, the name of the file to add, and a mask. You must have at least read permission on the file to be able to watch it. The mask is how we specify details about the events that we are interested in (we’ll come back to that). If the file is already being watched, then calling add with a different mask will replace the mask with the new one.</p>
<p>We have to save the return value of the add function if we want to use the remove function, because it takes that return value as an argument. The remove function says remove the given watch item from the list.</p>
<p>When we’re completely done, just call close on the file descriptor representing the inotify.</p>
<p>There are about 23 different events that you can watch for using the bit mask. Some of them are a bit obscure, but here are some that are highlighted in the spec:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Bit Value</strong></th>
<th style="text-align: left;"><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>IN_ACCESS</code></td>
<td style="text-align: left;">File accessed (read/execute)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IN_ATTRIB</code></td>
<td style="text-align: left;">Metadata changed, such as permissions</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IN_CLOSE_WRITE</code></td>
<td style="text-align: left;">File opened for writing was closed</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IN_CLOSE_NOWRITE</code></td>
<td style="text-align: left;">File not opened for writing was closed</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IN_CREATE</code></td>
<td style="text-align: left;">File or directory created in watched directory</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IN_DELETE</code></td>
<td style="text-align: left;">File or directory deleted from watched directory</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IN_DELETE_SELF</code></td>
<td style="text-align: left;">Watched file or directory deleted</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IN_MODIFY</code></td>
<td style="text-align: left;">File modified (write, for example)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>IN_OPEN</code></td>
<td style="text-align: left;">File opened</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IN_ALL_EVENTS</code></td>
<td style="text-align: left;">Watch for all of the above (and a few more)</td>
</tr>
</tbody>
</table>
<p>Great, so imagine we have set up some files that we would like to watch. When you’re ready for such an event, use <code>read</code> on the file descriptor for the inotify. If an event occurred, you get back a structure <code>inotify_event</code> that looks like this (as described in the official docs):</p>
<div class="sourceCode" id="cb206" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb206-1" title="1"><span class="kw">struct</span> inotify_event {</a>
<a class="sourceLine" id="cb206-2" title="2">  <span class="dt">int</span>      wd;       <span class="co">/* Watch descriptor */</span></a>
<a class="sourceLine" id="cb206-3" title="3">  <span class="dt">uint32_t</span> mask;     <span class="co">/* Mask describing event */</span></a>
<a class="sourceLine" id="cb206-4" title="4">  <span class="dt">uint32_t</span> cookie;   <span class="co">/* Unique cookie associating related events (for rename(2)) */</span>  </a>
<a class="sourceLine" id="cb206-5" title="5">  <span class="dt">uint32_t</span> len;      <span class="co">/* Size of name field */</span></a>
<a class="sourceLine" id="cb206-6" title="6">  <span class="dt">char</span>     name[];   <span class="co">/* Optional null-terminated name */</span></a>
<a class="sourceLine" id="cb206-7" title="7">};</a></code></pre></div>
<p>The first returned value is which file descriptor it was the event happened on, as we’d expect. The second says what kind of event occurred. The third parameter is a delicious, delicious cookie: it allows you to identify a rename operation (if a file is renamed in the directory, this shows up as two events and the cookie is used to link the two). The length field tells you how long the name array is, and then there is of course the name array. That means memory size of an inotify event is thus the structure size plus the length of the array, i.e.: <code>sizeof( struct inotify_event) + len</code> <span class="citation" data-cites="lpi"></span>.</p>
<p>This is something somewhat rare – usually when we do a read we need to know how many bytes we’d like to read. If we’re reading a struct, we know the size of the struct, but now it depends on the length of the data you get back. Your standard clairvoyance problem. One approach is to just make the buffer really big: much bigger than it needs to be. The length of the largest filename plus one (for the null terminator) would work. If your buffer isn’t big enough the read call will fail.</p>
<p>Alternatively, <code>ioctl</code> can tell you what you want to know: <code>ioctl( fd, FIONREAD, &amp;numbytes )</code> updates <code>numbytes</code> with the number of bytes currently available to read from the inotify instance <span class="citation" data-cites="lpi"></span>. If multiple events occurred you can get multiple structures back (if your buffer is big enough).</p>
<p>A relatively simple example then: we’d like to observe when a lock file is deleted, so that we can try to take some action that occurs afterwards. We can demonstrate this program working when we start it and the lock file already exists.</p>
<div class="sourceCode" id="cb207" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb207-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb207-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb207-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/inotify.h&gt;</span></a>
<a class="sourceLine" id="cb207-4" title="4"><span class="pp">#include </span><span class="im">&lt;stdbool.h&gt;</span></a>
<a class="sourceLine" id="cb207-5" title="5"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb207-6" title="6"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb207-7" title="7"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb207-8" title="8"></a>
<a class="sourceLine" id="cb207-9" title="9"><span class="dt">const</span> <span class="dt">char</span> filename[] = <span class="st">&quot;file.lock&quot;</span>;</a>
<a class="sourceLine" id="cb207-10" title="10"></a>
<a class="sourceLine" id="cb207-11" title="11"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb207-12" title="12">    <span class="dt">int</span> lockFD;</a>
<a class="sourceLine" id="cb207-13" title="13">    <span class="dt">bool</span> our_turn = false;</a>
<a class="sourceLine" id="cb207-14" title="14">    </a>
<a class="sourceLine" id="cb207-15" title="15">    <span class="cf">while</span>( !our_turn ) {</a>
<a class="sourceLine" id="cb207-16" title="16">        lockFD = open( filename, O_CREAT | O_EXCL | O_TRUNC );</a>
<a class="sourceLine" id="cb207-17" title="17">        <span class="cf">if</span> ( lockFD == -<span class="dv">1</span> ) {</a>
<a class="sourceLine" id="cb207-18" title="18">            printf( <span class="st">&quot;The lock file exists and process %ld will wait its turn...</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid() ); </a>
<a class="sourceLine" id="cb207-19" title="19">            <span class="dt">int</span> notifyFD = inotify_init( );</a>
<a class="sourceLine" id="cb207-20" title="20">            <span class="dt">uint32_t</span> watched = inotify_add_watch( notifyFD, filename, IN_DELETE_SELF );</a>
<a class="sourceLine" id="cb207-21" title="21">            </a>
<a class="sourceLine" id="cb207-22" title="22">            <span class="co">/* Read the file descriptor for the notify -- we get blocked here</span></a>
<a class="sourceLine" id="cb207-23" title="23"><span class="co">               until there&#39;s an event that we want */</span></a>
<a class="sourceLine" id="cb207-24" title="24">            <span class="dt">int</span> buffer_size = <span class="kw">sizeof</span>( <span class="kw">struct</span> inotify_event ) + strlen( filename ) + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb207-25" title="25">            <span class="dt">char</span>* event_buffer = malloc( buffer_size );</a>
<a class="sourceLine" id="cb207-26" title="26">            printf(<span class="st">&quot;Setup complete, waiting for event...</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb207-27" title="27">            read( notifyFD, event_buffer, buffer_size );</a>
<a class="sourceLine" id="cb207-28" title="28"></a>
<a class="sourceLine" id="cb207-29" title="29">            <span class="kw">struct</span> inotify_event* event = (<span class="kw">struct</span> inotify_event*) event_buffer;</a>
<a class="sourceLine" id="cb207-30" title="30">            <span class="co">/* Here we can look and see what arrived and decide what to do.</span></a>
<a class="sourceLine" id="cb207-31" title="31"><span class="co">               In this example, we&#39;re only watching one file and one type</span></a>
<a class="sourceLine" id="cb207-32" title="32"><span class="co">               of event, so we don&#39;t need to make any decisions now */</span></a>
<a class="sourceLine" id="cb207-33" title="33"></a>
<a class="sourceLine" id="cb207-34" title="34">            printf(<span class="st">&quot;Event occurred!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb207-35" title="35"></a>
<a class="sourceLine" id="cb207-36" title="36">            free( event_buffer );</a>
<a class="sourceLine" id="cb207-37" title="37">            inotify_rm_watch( lockFD, watched );</a>
<a class="sourceLine" id="cb207-38" title="38">            close( notifyFD );</a>
<a class="sourceLine" id="cb207-39" title="39">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb207-40" title="40">            <span class="dt">char</span>* pid = malloc( <span class="dv">32</span> );</a>
<a class="sourceLine" id="cb207-41" title="41">            memset( pid, <span class="dv">0</span>, <span class="dv">32</span> );</a>
<a class="sourceLine" id="cb207-42" title="42">            <span class="dt">int</span> bytes_of_pid = sprintf( pid, <span class="st">&quot;%ld&quot;</span>, getpid() );</a>
<a class="sourceLine" id="cb207-43" title="43"></a>
<a class="sourceLine" id="cb207-44" title="44">            write( lockFD, pid, bytes_of_pid ); </a>
<a class="sourceLine" id="cb207-45" title="45">            free ( pid );</a>
<a class="sourceLine" id="cb207-46" title="46">            close( lockFD );</a>
<a class="sourceLine" id="cb207-47" title="47">            our_turn = true; </a>
<a class="sourceLine" id="cb207-48" title="48">        }</a>
<a class="sourceLine" id="cb207-49" title="49">    } </a>
<a class="sourceLine" id="cb207-50" title="50"></a>
<a class="sourceLine" id="cb207-51" title="51">    printf(<span class="st">&quot;Process %ld is in the area protected by file lock.</span><span class="sc">\n</span><span class="st">&quot;</span>, getpid());</a>
<a class="sourceLine" id="cb207-52" title="52">    remove( filename );</a>
<a class="sourceLine" id="cb207-53" title="53">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb207-54" title="54">}</a></code></pre></div>
<h2 id="consistency-journalling" class="unnumbered">Consistency: Journalling</h2>
<p>Unfortunately, an error, crash, or power failure may result in a loss of data or inconsistent data in the file system. The directory structures, pointers, inodes, et cetera are all data structures and if they become corrupted it may lead to serious problems.</p>
<p>We could check for inconsistent data periodically (e.g., on system boot up) and many operating systems do so. This is, of course, an operation that will consume a very large amount of time while the whole disk is scanned. The UNIX tool for this is <code>fsck</code> (... not exactly something you want to say out loud) and the Windows tool is <code>chkdsk</code> (check disk). These tools will look for inconsistent states (e.g., a file that claims to be 12 blocks but the linked list contains only 5) and will attempt to repair the data structures. Its level of success depends on the nature of the problem and the implementation of the file system.</p>
<p>Obviously we would like to prevent the problem, if we can. The solution is to use transactions, just as we do in version control. Either a change takes place in its entirety or it is as if it never happened.</p>
<h3 id="zfs-sunoracle-file-system" class="unnumbered">ZFS (Sun/Oracle File System)</h3>
<p>Let’s consider ZFS (as I understand it, pronounced “Zee Eff Ess”), which is intended for scalability and has some interesting features. The primary source for this section is the official documentation <span class="citation" data-cites="zfs"></span>. Because what better place than from the source?</p>
<p>ZFS uses the idea of transactions, making sure that the state is always consistent on disk. Much like the copy-modify-merge model, data is copied, then changed, then rewritten. Blocks are never overwritten with new data. Instead, a transaction writes all data and metadata to new blocks. Only when the transaction is complete, any references to the old blocks are replaced with the location of the new blocks. Then the old pointers and blocks can be cleaned up (reused or disposed of).</p>
<p>This does have an interesting weakness: if the disk becomes completely and totally full it is not possible to delete anything and make space, because there’s no place to allocate new blocks. That’s a problem. And not just a hypothetical: it happened to a friend of mine when he tried to put too much data in his NAS (network attached storage). He was mad. But he was going to buy a new one anyway, I guess...</p>
<h3 id="apfs-apple-file-system" class="unnumbered">APFS (Apple File System)</h3>
<p>Like some version control systems, APFS brings the ability to take snapshots of the file system: freeze the state of the file system and from there any additional changes are “diffs” against that base state, meaning only new things take up space. This is potentially quite helpful for taking backups (you do take backups, right?) <span class="citation" data-cites="apfs"></span>.</p>
<p>Speedier backups can result: the performance of your system can be degraded while backups are being taken because you need to compute the difference between the last backup copy and the current. This is faster! But it is also a way to avoid corruption: you can replay changes as needed to get the file back to <em>a</em> consistent state (of some sort).</p>
<p>The APFS does potentially harm the most common “backup” system of non-technical users: take a copy of the file and put it in a different folder. If you copy a file to the same volume (and make no changes) then APFS will not copy the data and instead just have two references to the same underlying location. It sounds like they’re doing you a favour if you think of this as just reducing wasted space, but is actually a negative from the perspective of redundancy: if that part of the disk is damaged then all copies are lost <span class="citation" data-cites="apfs"></span>.</p>
<p>Somewhat like ZFS, the APFS approach to avoiding inconsistent data amidst a crash is something like copy-on-write, though in typical Apple fashion they were pretty vague about what this means in a practical sense; the APFS lead developer Dominic Giampaolo just says it’s a “novel copy-on-write metadata scheme” but also somehow not exactly the same as ZFS’s single-atomic-update approach <span class="citation" data-cites="apfs"></span>.</p>
<h3 id="ntfs-windows-file-system" class="unnumbered">NTFS (Windows File System)</h3>
<p>Though UNIX and similar systems have often been a focus of the examples, in this case, we will instead examine NTFS, the default file system for Windows since Windows NT and used in 2000, XP, Vista, 7, 8, 10... NTFS supports large disks and large files, and uses journalling.</p>
<p>A volume is laid out as follows:</p>
<p><img src="images/ntfs-volume.png" alt="image" style="width:60.0%" /><br />
Standard layout of an NTFS volume <span class="citation" data-cites="osi"></span>.</p>
<p>The Master File Table (MFT) contains information about all the files and folders. Following the that, a block is allocated to system files that contain some important system information <span class="citation" data-cites="osi"></span>:</p>
<ol>
<li><p><strong>MFT2</strong>: Mirror of the first few rows of the MFT (in case the original is damaged).</p></li>
<li><p><strong>Log File</strong>: The journalling transaction log.</p></li>
<li><p><strong>Cluster Bitmap</strong>: Bitmap showing which of the clusters are in use.</p></li>
<li><p><strong>Attribute Definition Table</strong>: Attribute types supported on this volume.</p></li>
</ol>
<p>NTFS uses journalling to ensure that the file system will be in a consistent state at all times, even after a crash or restart. There is a service responsible for maintaining a log file that will be used to recover in the event that things go wrong. Note that the goal of recovery is to make sure the system-maintained metadata is in a consistent state; user data can still get lost. This was a decision on the part of Microsoft to make the recovery operations significantly simpler and faster.</p>
<p>All metadata changes are written sequentially to a log file; once the changes are written to the log, control may return to the program that requested the operation. Meanwhile, the log entries are actually carried out. As changes are made, a pointer is updated to indicate which of the log entries have really happened and which have not. When an entire transaction is completed, it is removed from the log file. If the system crashes, the log file will contain zero or more transactions. If there are zero there is no problem: nothing was in progress at the time of the crash. If there are some, then the transactions were not completed and the operations should still be carried out. If a transaction was aborted (not committed), we walk backwards through the log entries to undo any completed operations and go back to the state before the start of the transaction <span class="citation" data-cites="osc"></span>.</p>
<p>Even though a particular write may not have taken place because of a crash, resulting in some data loss, at least the system will always remain in a consistent state. As a side benefit, we can sometimes re-order the writes to get better performance (e.g., schedule them in such a way that we get better disk utilization).</p>
<p>The actual implementation of journalling works as follows <span class="citation" data-cites="russ"></span>:</p>
<ol>
<li><p>Record the change(s) in the log file in the cache.</p></li>
<li><p>Modify the volume in the cache.</p></li>
<li><p>The cache manager flushes the log file to disk.</p></li>
<li><p>Only after the log file is flushed to disk, the cache manager flushes the volume changes.</p></li>
</ol>
<p>What’s really interesting about this is that the changes are carried out in the background, that is to say, asynchronously. A program can say that it wants to write some data, and not have to wait for the data to be written before going on to the next thing. How interesting! Can we get that behaviour in our (regular) program? Yes we can...</p>
<h1 id="asynchronous-io-with-select-poll" class="unnumbered">29 — Asynchronous I/O with select, poll</h1>
<h2 id="asynchronous-non-blocking-io" class="unnumbered">Asynchronous (non-blocking) I/O</h2>
<p>Consider some of the usual file read code:</p>
<div class="sourceCode" id="cb208" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb208-1" title="1"><span class="dt">int</span> fd = open( <span class="st">&quot;example.txt&quot;</span>, O_RDONLY );</a>
<a class="sourceLine" id="cb208-2" title="2"><span class="dt">int</span> bytes_read = read( fd, buffer, num_bytes );</a>
<a class="sourceLine" id="cb208-3" title="3">close( fd );</a></code></pre></div>
<p>As we discussed much earlier, the <code>read</code> call is blocking, as expected. So, your program waits for the I/O operation to be complete before continuing on to the next statements (whatever they are). This is sometimes, but not always, sensible. If you need the data in the next statement, you can’t go on until the data is present.</p>
<p>If you are waiting for the bus, do you stare off blankly into space while waiting for it to arrive? Probably not. More likely you pull out your phone and start to use it for something. Whether that is productive or not (e.g., answering a project e-mail or liking posts on Facebook) is up to you, but you are doing something and making use of the time.</p>
<p>Our main solution until now is threads: if one thread gets blocked on the I/O the other ones can continue and is fine. But maybe you don’t want to use threads, or maybe you can’t due to: race conditions, thread stack size overhead, or limitations on the maximum number of threads. The last one might seem ridiculous, but in some embedded system you may not have the option to make new threads (or at least not as many as you want).</p>
<p>Sometimes, also, your programming language (e.g., Javascript) doesn’t allow you to make multiple threads and you really have no choice but to use asynchronous I/O. It’s a useful tool to have in the toolbox so let’s get into it.</p>
<p>The simplest example:</p>
<div class="sourceCode" id="cb209" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb209-1" title="1"><span class="dt">int</span> fd = open( <span class="st">&quot;example.txt&quot;</span>, O_RDONLY | O_NONBLOCK );</a>
<a class="sourceLine" id="cb209-2" title="2"><span class="dt">int</span> bytes_read = read( fd, buffer, num_bytes ); <span class="co">/* Returns instantly! */</span></a>
<a class="sourceLine" id="cb209-3" title="3">close( fd );</a></code></pre></div>
<p>If we opened the file in non-blocking, the <code>read</code> call returns instantly. Whether or not results are ready. Unfortunately, this doesn’t work here. The <code>O_NONBLOCK</code> option is not helpful, because this call says we should not wait for data when there is no data available. But a file <em>always</em> has data available. It might take a long time to load it up from disk, but the data is there. Do we know any scenarios where we don’t have data always available?</p>
<p>Sure! Sockets. If we haven’t received something, we would get blocked waiting for some data to arrive. But we can change that behaviour on a socket if we wish, by setting the socket to be nonblocking <span class="citation" data-cites="getaddrinfo"></span>:</p>
<div class="sourceCode" id="cb210" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb210-1" title="1">sockfd = socket( PF_INET, SOCK_STREAM, <span class="dv">0</span> );</a>
<a class="sourceLine" id="cb210-2" title="2">fcntl( sockfd, F_SETFL, O_NONBLOCK );</a></code></pre></div>
<p>This means that calls to <code>accept()</code>, <code>recv()</code>, or <code>recvfrom()</code> would not block. If you call those and there’s no data to receive, you get back a return value of <code>-1</code> and <code>errno</code> is going to be either <code>EAGAIN</code> or <code>EWOULDBLOCK</code>. Sadly, the specification does not say which it would be, so the fully correct approach is to check for both. Not great, but it’s how we are sure.</p>
<p>Suppose that you are writing a server application that’s going to listen on several sockets. This is a common enough scenario. You could have different threads listening on their individual sockets but – see the reasoning above as to why we might not have that option. And we no longer have to!</p>
<p>But if we are a server and there aren’t any incoming requests, what exactly are we supposed to do with our time? If we just poll each socket using, for example, <code>accept()</code>, this amounts to tight polling and is CPU intensive and wastes the CPU’s time. But we don’t want to get blocked on a particular socket either, because what if it’s not the one where the next packet arrives? What we need is a third option.</p>
<h3 id="third-option-select" class="unnumbered">Third option: <code>select()</code></h3>
<p>Our wish is granted. The third option is called <code>select()</code> – it allows us to monitor a group of sockets, telling us about the state of each of them. A socket could be ready for a read, ready for a write (of small size – you can’t write a huge chunk to a socket without getting blocked at some point), or whether an exception has occurred. So actually, select works on three sets of sockets:</p>
<div class="sourceCode" id="cb211" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb211-1" title="1"> <span class="dt">int</span> select( <span class="dt">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="kw">struct</span> timeval *timeout );</a></code></pre></div>
<p>If we call this function, we’ll get blocked until something happens on one of the sockets so that it becomes “ready” – data is available to read, space is available to write, etc. or until we reach a timeout. While blocked, we could also get interrupted by something (e.g., a signal).</p>
<p>The first parameter, <code>nfds</code>, is supposed to be the value of the highest number file descriptor in any of the three sets plus 1. So. It has come to this. One of the problems with <code>select()</code> is that it is pretty... arcane. According to the documentation, the reason why it is this, is because <code>select()</code> will scan through all the file descriptors from 0 up to <code>nfds-1</code> to figure out if we care about them.</p>
<p>What’s this about? Well, the <code>fd_set</code> structure can have up to 1024 file descriptors, and is actually implemented as a bitfield; by specifying the highest file descriptor that we are interested in, the kernel can stop looking once we reached the last one (and the <code>fd_set</code> structure doesn’t have to be a linked list or array or anything large!) <span class="citation" data-cites="apunix"></span>.</p>
<p>Well, we were going to have to figure out what the <code>fd_set</code> means anyway. It represents a set of file descriptors, just as the name says. There are then four functions for manipulating a set:</p>
<pre><code>void FD_ZERO( fd_set *set ); /* Clear the set */
void FD_SET( int fd, fd_set *set ); /* Add fd to the set */
void FD_CLR( int fd, fd_set *set ); /* Remove fd from the set */
int  FD_ISSET( int fd, fd_set *set); /* Tests if fd is a part of the set */ </code></pre>
<p>When we create a new set, we should first initialize it with a <code>FD_ZERO</code> call. That could also be used to reset it, if desired, at some later point. Then we can add file descriptors that we want to have. To add one, use <code>FD_SET</code> with the file descriptor to add; to remove one that has been added, use <code>FD_CLR</code> with the file descriptor to remove.</p>
<p>But that last one, <code>FD_ISSET</code>, is a little different. It’s not as if we would forget whether we put a file descriptor in the set. It’s really for us to see what happens after <code>select()</code> is called – we can find out whether a given file descriptor is in a particular set or not.</p>
<p>The <code>readfds</code> are obviously sockets we are interested in reading from and <code>writefds</code> are accordingly those we are interested in writing from. But what about the <code>exceptfds</code> – this isn’t Java, it’s not like we’re going to get a <code>SocketDoesNotFeelLikeDoingWorkRightNowException</code>. No, this is for sockets that are in an exceptional state, which usually means there is Out-Of-Band (OOB) data on a TCP socket. We didn’t cover this earlier in network communication and we will also not be going into this subject now. But you can find out if a socket is in that state if you have a reason.</p>
<p>We don’t have to use all three of <code>readfds</code>, <code>writefds</code>, and <code>exceptfds</code> in a call to <code>select()</code> if we do not need them all. If we have only read sockets, we put them all in the <code>readfds</code> set and can just give <code>NULL</code> or empty <code>fd_set</code>s in for the other parameters <span class="citation" data-cites="getaddrinfo"></span>.</p>
<p>Finally, there is a timeout parameter: we can specify a maximum amount of time we are willing to wait. If nothing happens before the timeout amount of time occurs, then <code>select()</code> returns. The format of this is a fairly simple structure <code>struct timeval</code>:</p>
<div class="sourceCode" id="cb213" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb213-1" title="1"><span class="kw">struct</span> timeval {</a>
<a class="sourceLine" id="cb213-2" title="2">  <span class="dt">long</span> tv_sec; <span class="co">/* seconds */</span></a>
<a class="sourceLine" id="cb213-3" title="3">  <span class="dt">long</span> tv_usec; <span class="co">/* microseconds */</span></a>
<a class="sourceLine" id="cb213-4" title="4">};</a></code></pre></div>
<p>If both fields of the <code>struct timeval</code> are zero, then <code>select()</code> returns immediately; if the pointer to it is <code>NULL</code> then there is no timeout and we will wait as long as it takes for something – anything – to happen.</p>
<p>When <code>select()</code> returns, however that happened, some if not all of the parameters other than <code>nfds</code> got updated (argh). The file descriptors passed in are modified in-place to see if they changed status. And the <code>struct timeval</code> parameter may (but also may not) be updated to reflect how much time was left before the timeout. Because different systems may or may not change this value, it is not safe to re-use and should be overwritten if you plan to use that structure again.</p>
<p>After select has returned, then we check the file descriptors in our sets. All of them. Yes, really. The function returns when there is something to do – but we aren’t told what socket is ready. So we would need to check each socket to see if, for example, it’s ready for reading (if that’s the plan). To do that we check <code>FD_ISSET</code> with the socket and the set to see if it’s in the desired state.</p>
<p>Because the sets of file descriptors may have been modified, you probably need to rebuild them after each call, if you plan to use them again. If you were waiting, for example, three sockets, not all of them necessarily became ready at the same time. So if you want to go on waiting for those three, you will need to put them in a set again.</p>
<p>Let’s imagine a brief example where we have a server that is going to listen on some different sockets for different services, imaginatively called service1, service2, and service3.</p>
<div class="sourceCode" id="cb214" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb214-1" title="1"><span class="dt">void</span> listen_for_connections( <span class="dt">int</span> service1_sock, <span class="dt">int</span> service2_sock, <span class="dt">int</span> service3_sock ) {</a>
<a class="sourceLine" id="cb214-2" title="2">  <span class="dt">int</span> nfds = <span class="dv">1</span> + (service1_sock &gt; service<span class="dv">2</span><span class="er">_sock</span></a>
<a class="sourceLine" id="cb214-3" title="3">    ? service1_sock &gt; service3_sock ? service1_sock : service<span class="dv">3</span><span class="er">_sock</span></a>
<a class="sourceLine" id="cb214-4" title="4">    : service2_sock &gt; service3_sock ? service2_sock : service3_sock);</a>
<a class="sourceLine" id="cb214-5" title="5">    </a>
<a class="sourceLine" id="cb214-6" title="6">  fd_set s;</a>
<a class="sourceLine" id="cb214-7" title="7">  <span class="kw">struct</span> timeval tv;</a>
<a class="sourceLine" id="cb214-8" title="8">  printf( <span class="st">&quot;Going to start listening for socket events.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb214-9" title="9">  </a>
<a class="sourceLine" id="cb214-10" title="10">  <span class="cf">while</span>( !quit ) {</a>
<a class="sourceLine" id="cb214-11" title="11">  </a>
<a class="sourceLine" id="cb214-12" title="12">    FD_ZERO( &amp;s );</a>
<a class="sourceLine" id="cb214-13" title="13">    FD_SET( service1_sock, &amp;s );</a>
<a class="sourceLine" id="cb214-14" title="14">    FD_SET( service2_sock, &amp;s );</a>
<a class="sourceLine" id="cb214-15" title="15">    FD_SET( service3_sock, &amp;s );</a>
<a class="sourceLine" id="cb214-16" title="16">    </a>
<a class="sourceLine" id="cb214-17" title="17">    tv.tv_sec = <span class="dv">30</span>;</a>
<a class="sourceLine" id="cb214-18" title="18">    tv.tv_usec = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb214-19" title="19">  </a>
<a class="sourceLine" id="cb214-20" title="20">    <span class="dt">int</span> res = select( nfds, &amp;s, NULL, NULL, &amp;tv );</a>
<a class="sourceLine" id="cb214-21" title="21">    <span class="cf">if</span> ( res == -<span class="dv">1</span> ) { <span class="co">/* An error occurred */</span></a>
<a class="sourceLine" id="cb214-22" title="22">      printf( <span class="st">&quot;An error occurred in select(): %s.</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror( errno ) );</a>
<a class="sourceLine" id="cb214-23" title="23">      quit = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb214-24" title="24">    } <span class="cf">else</span> <span class="cf">if</span> ( res == <span class="dv">0</span> ) { <span class="co">/* 0 sockets had events occur */</span></a>
<a class="sourceLine" id="cb214-25" title="25">      printf( <span class="st">&quot;Still waiting; nothing occurred recently.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb214-26" title="26">    } <span class="cf">else</span> { <span class="co">/* Things happened */</span></a>
<a class="sourceLine" id="cb214-27" title="27">      <span class="cf">if</span> ( FD_ISSET( service1_sock, &amp;s ) {</a>
<a class="sourceLine" id="cb214-28" title="28">        service1_activate( ); </a>
<a class="sourceLine" id="cb214-29" title="29">      }</a>
<a class="sourceLine" id="cb214-30" title="30">      <span class="cf">if</span> ( FD_ISSET( service2_sock, &amp;s ) {</a>
<a class="sourceLine" id="cb214-31" title="31">        service2_activate( ); </a>
<a class="sourceLine" id="cb214-32" title="32">      }</a>
<a class="sourceLine" id="cb214-33" title="33">      <span class="cf">if</span> ( FD_ISSET( service3_sock, &amp;s ) {</a>
<a class="sourceLine" id="cb214-34" title="34">        service3_activate( ); </a>
<a class="sourceLine" id="cb214-35" title="35">      }</a>
<a class="sourceLine" id="cb214-36" title="36">  }</a>
<a class="sourceLine" id="cb214-37" title="37">}</a></code></pre></div>
<p>You’ll notice that we check each of the sockets individually – more than one of them could become ready at once. Now, the <code>activate()</code> calls there could take some nontrivial time, and if sockets receive data in the meantime then on the next iteration of the loop then <code>select()</code> will return immediately because data is waiting.</p>
<p>This represents a fairly simple scenario, though, where we are just waiting for <code>accept()</code> on the three services where we send back as simple response and that’s the end of it. But if the connections we were looking at are supposed to stay open for some period of time, such as when there is occasional communication, then we would also have to add and remove sockets from the sets as connections were opened and closed. Managing the set of sockets in such a scenario is non-trivial, because each call to <code>select</code> can (and usually does) change the sets.</p>
<h5 id="chat-server.">Chat Server.</h5>
<p>The more complicated example in <span class="citation" data-cites="getaddrinfo"></span> is about a chat program (if you ever used IRC you have a pretty good idea of how this would work). When people want to join the chat room they send a message to a server. The server accepts and opens the connection and adds the client to the chat room. But people don’t always talk. So if nothing is happening right now there’s nothing to send. So the server can use <code>select()</code> to keep an eye open for when someone has said something. Either way, we would wait for something to happen, either on one of the sockets from a current client, or the socket for accepting incoming connections.</p>
<p>If it’s the socket for accepting incoming connections that activated then accept the incoming connection, and add the new socket to the list that we are going to listen to. A chat server might choose to send a notification to other clients to let them know that a new person has joined the chat. That would be a write to the sockets that represent connected clients.</p>
<p>If another socket activated, most likely someone had something to say. So we can read from the socket that is ready to read and pass on the message that we received to all the other clients. Except, sometimes there isn’t one! A socket will show up as being ready for reading if it has closed. But the call to read will return 0 (or a negative number) if the socket has closed (i.e., the client has disconnected). If the connection has been closed, then we should remove that socket from the list that we are interested in. And also we sometimes send a message telling other clients that a person has left the chat.</p>
<p>And when a message is received from a client, then of course the thing for the server to do is to send it on to the other clients, by writing to their sockets so the message is transmitted to them. The clients are waiting to receive messages and will then show them to the user when someone says something. And then look at that: you’re talking to other people on the internet! Just remember not to give out your personal information to strangers.</p>
<p>Obviously there are some other considerations that come with managing a chat server. There might be periodic connection-keep-alive kind of messages so that clients remain connected even if nobody is talking right now. And you might want the ability to kick out people who are spammers and perhaps even ban them, amongst other things. But the goal of this explanation wasn’t really to learn how to write a chat server in great detail – just to give an example of how you could use <code>select</code> to write something useful.</p>
<h5 id="slightly-different-mostly-the-same-pselect.">Slightly different, mostly the same: <code>pselect</code>.</h5>
<p>There is also <code>pselect()</code> which has the signature:</p>
<div class="sourceCode" id="cb215" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb215-1" title="1"><span class="dt">int</span> pselect( <span class="dt">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </a>
<a class="sourceLine" id="cb215-2" title="2">            <span class="dt">const</span> <span class="kw">struct</span> timespec *timeout, <span class="dt">const</span> sigset_t *sigmask );</a></code></pre></div>
<p>The signature is different in two ways. The first is that instead of <code>struct timeval</code> it is a <code>struct timespec</code>, which is slightly different in its meaning, and also will never be modified by the call to <code>pselect</code>:</p>
<div class="sourceCode" id="cb216" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb216-1" title="1"><span class="kw">struct</span> timespec {</a>
<a class="sourceLine" id="cb216-2" title="2">  <span class="dt">long</span> tv_sec; <span class="co">/* seconds */</span></a>
<a class="sourceLine" id="cb216-3" title="3">  <span class="dt">long</span> tv_nsec; <span class="co">/* nanoseconds */</span></a>
<a class="sourceLine" id="cb216-4" title="4">};</a></code></pre></div>
<p>Yes, the only real difference is that it is seconds and nanoseconds, rather than seconds and milliseconds. The other parameter is about setting up a signal mask. We discussed the signal mask much earlier on when we talked about signals for interprocess communication. This is the same, but it allows us to change the signal mask atomically in the same step as the call to select, so we can choose what signals are allowed to wake us up while we are waiting for something to happen. Given appropriate allocation and initialization of the values, the call:</p>
<div class="sourceCode" id="cb217" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb217-1" title="1">ready = pselect( nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout, &amp;sigmask );</a></code></pre></div>
<p>is equivalent to an atomic operation that does all of:</p>
<div class="sourceCode" id="cb218" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb218-1" title="1">sigset_t origmask;</a>
<a class="sourceLine" id="cb218-2" title="2">pthread_sigmask( SIG_SETMASK, &amp;sigmask, &amp;origmask );</a>
<a class="sourceLine" id="cb218-3" title="3">ready = select( nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout );</a>
<a class="sourceLine" id="cb218-4" title="4">pthread_sigmask( SIG_SETMASK, &amp;origmask, NULL );</a></code></pre></div>
<p>If we had tried to do the multi-step sequence then there is always the possibility that something (e.g., a signal!) could happen in between changing the signal mask and the call to <code>select</code>. The syntax here for changing the signal mask is slightly different than what we have seen before, but this is the POSIX specification implementation of the <code>sigprocmask()</code> call. So, it works the same as we have seen earlier.</p>
<h5 id="i-only-wanted-a-nap...">I only wanted a nap...</h5>
<p>It is possible to “misuse” a call to <code>select</code> or <code>pselect</code> as a way to make a very portable call to put the current thread to sleep. Some of the calls to sleep functions don’t translate well to other UNIX-like systems, especially if you want a very short sleep – but <code>select</code> is in the standard! So you can do this by calling <code>select</code> with all three sets empty and <code>nfds</code> at zero and whatever timeout you wish. Clever!</p>
<h3 id="alternative-poll" class="unnumbered">Alternative: <code>poll()</code></h3>
<p>There’s a slightly different function that is very much like <code>select()</code> and it is called <code>poll()</code>. Like its cousin, it is used to watch file descriptors and see if any of them are ready for an I/O operation. The signature is:</p>
<div class="sourceCode" id="cb219" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb219-1" title="1"><span class="dt">int</span> poll( <span class="kw">struct</span> pollfd *fds, nfds_t nfds, <span class="dt">int</span> timeout );</a></code></pre></div>
<p>The signature is a lot simpler, that’s for sure. The first argument is an array of <code>struct pollfd</code>, which is our structure for passing in the sockets we wish to monitor. The second parameter is <code>ndfs</code> which is just the number of items in the array. Finally, <code>timeout</code> is the number of milliseconds to wait before returning with zero meaning don’t wait at all, and a negative number meaning wait infinitely.</p>
<p>Alright, let’s look at the structure:</p>
<div class="sourceCode" id="cb220" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb220-1" title="1"><span class="kw">struct</span> pollfd {</a>
<a class="sourceLine" id="cb220-2" title="2">  <span class="dt">int</span> fd;        <span class="co">/* file descriptor */</span></a>
<a class="sourceLine" id="cb220-3" title="3">  <span class="dt">short</span> events;  <span class="co">/* requested events */</span></a>
<a class="sourceLine" id="cb220-4" title="4">  <span class="dt">short</span> revents; <span class="co">/* returned events */</span></a>
<a class="sourceLine" id="cb220-5" title="5">};</a></code></pre></div>
<p>Someone found a use for a <code>short</code> after all! Just kidding, hardware people.</p>
<p>The first parameter is obviously the file descriptor to watch. The second is where we specify what events we want to wait for on this file descriptor, and the third parameter is set by the kernel so we can find out what happened.</p>
<p>What can we add? You can look for data that’s ready to read with <code>POLLIN</code>, a socket where you can write without blocking with <code>POLLOUT</code>, and an exception (as above) with <code>POLLPRI</code>. These can be combined with the bitwise OR operator if you want more than one.</p>
<p>The return value will be constructed as a bitwise OR of the fields as well, with the possibility that you could have one of these other return values: <code>POLLERR</code> if an error occurred, <code>POLLHUP</code> if the other side ended the connection, or <code>POLLNVAL</code> if there’s a problem with the socket (e.g., uninitialized) <span class="citation" data-cites="getaddrinfo"></span>.</p>
<p>As with <code>select</code>, when <code>poll</code> returns we have to check which file descriptors have had an event occur and then decide what to do with them. Let’s rewrite the <code>select</code> example with three services to see its <code>poll</code> equivalent:</p>
<div class="sourceCode" id="cb221" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb221-1" title="1"><span class="dt">void</span> listen_for_connections( <span class="dt">int</span> service1_sock, <span class="dt">int</span> service2_sock, <span class="dt">int</span> service3_sock ) {</a>
<a class="sourceLine" id="cb221-2" title="2">  <span class="kw">struct</span> pollfd fds[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb221-3" title="3">  fds[<span class="dv">0</span>].fd = service1_sock;</a>
<a class="sourceLine" id="cb221-4" title="4">  fds[<span class="dv">0</span>].events = POLLIN;</a>
<a class="sourceLine" id="cb221-5" title="5">  fds[<span class="dv">1</span>].fd = service2_sock;</a>
<a class="sourceLine" id="cb221-6" title="6">  fds[<span class="dv">1</span>].events = POLLIN;</a>
<a class="sourceLine" id="cb221-7" title="7">  fds[<span class="dv">2</span>].fd = service3_sock;</a>
<a class="sourceLine" id="cb221-8" title="8">  fds[<span class="dv">2</span>].events = POLLIN;</a>
<a class="sourceLine" id="cb221-9" title="9"> </a>
<a class="sourceLine" id="cb221-10" title="10">  <span class="dt">int</span> timeout = <span class="dv">30</span> * <span class="dv">1000</span>; <span class="co">/* 30 seconds in ms */</span> </a>
<a class="sourceLine" id="cb221-11" title="11">  printf( <span class="st">&quot;Going to start listening for socket events.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb221-12" title="12">  </a>
<a class="sourceLine" id="cb221-13" title="13">  <span class="cf">while</span>( !quit ) {</a>
<a class="sourceLine" id="cb221-14" title="14">    </a>
<a class="sourceLine" id="cb221-15" title="15">    <span class="dt">int</span> res = poll( &amp;fds, <span class="dv">3</span>, timeout );</a>
<a class="sourceLine" id="cb221-16" title="16">    <span class="cf">if</span> ( res == -<span class="dv">1</span> ) { <span class="co">/* An error occurred */</span></a>
<a class="sourceLine" id="cb221-17" title="17">      printf( <span class="st">&quot;An error occurred in select(): %s.</span><span class="sc">\n</span><span class="st">&quot;</span>, strerror( errno ) );</a>
<a class="sourceLine" id="cb221-18" title="18">      quit = <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb221-19" title="19">    } <span class="cf">else</span> <span class="cf">if</span> ( res == <span class="dv">0</span> ) { <span class="co">/* 0 sockets had events occur */</span></a>
<a class="sourceLine" id="cb221-20" title="20">      printf( <span class="st">&quot;Still waiting; nothing occurred recently.</span><span class="sc">\n</span><span class="st">&quot;</span> );</a>
<a class="sourceLine" id="cb221-21" title="21">    } <span class="cf">else</span> { <span class="co">/* Things happened */</span></a>
<a class="sourceLine" id="cb221-22" title="22">      <span class="cf">if</span> ( fds[<span class="dv">0</span>].revents &amp; POLLIN ) {</a>
<a class="sourceLine" id="cb221-23" title="23">        service1_activate( ); </a>
<a class="sourceLine" id="cb221-24" title="24">      }</a>
<a class="sourceLine" id="cb221-25" title="25">      <span class="cf">if</span> ( fds[<span class="dv">1</span>].revents &amp; POLLIN ) {</a>
<a class="sourceLine" id="cb221-26" title="26">        service2_activate( ); </a>
<a class="sourceLine" id="cb221-27" title="27">      }</a>
<a class="sourceLine" id="cb221-28" title="28">      <span class="cf">if</span> ( fds[<span class="dv">2</span>].revents &amp; POLLIN ) {</a>
<a class="sourceLine" id="cb221-29" title="29">        service3_activate( ); </a>
<a class="sourceLine" id="cb221-30" title="30">      }</a>
<a class="sourceLine" id="cb221-31" title="31">  }</a>
<a class="sourceLine" id="cb221-32" title="32">}</a></code></pre></div>
<h5 id="comparing-the-two.">Comparing the two.</h5>
<p>Ultimately both functions do the same job; it is only the specifics of the API call that make the difference. You might find one or the other to be better, and in particular it is nice that <code>poll</code> doesn’t ask you to find the maximum file descriptor or manage three sets or have to rebuild the sets on each iteration of the loop.</p>
<p>Both <code>select</code> and <code>poll</code> are slow, unfortunately. They have linear characteristics: the more file descriptors you give them the slower they get; if you get up to a hundred file descriptors, roughly, then you end up actually spending significant CPU time trying to figure out which of the sockets changed <span class="citation" data-cites="pollvselect"></span>.</p>
<p>If we want to do things more efficiently we will want to use a different tool, specifically <code>libevent</code>, but we aren’t quite done with network communication. After sockets, we learned about cURL, and it turns out we can use nonblocking I/O there as well!</p>
<h1 id="asynchronous-io-with-curl" class="unnumbered">30 — Asynchronous I/O with cURL</h1>
<h2 id="using-curl-asynchronously" class="unnumbered">Using cURL Asynchronously</h2>
<p>We’ve already seen that network communication is a great example of a way that you could use asynchronous I/O. You can start a network request and move on to creating more without waiting for the results of the first one. For requests to different recipients, it certainly makes sense to do this. And yet, we’ve seen that while socket programming is important and necessary, for a lot of situations we prefer to use cURL. And we can use this in an asynchronous way as well.</p>
<p>The cURL multi interface has a lot of similarities with the regular cURL interface. It’s been a little while since we went over it, so let’s recap what we did before. Remember from earlier the example we did that was modified from <a href="https://curl.haxx.se/libcurl/c/https.html">https://curl.haxx.se/libcurl/c/https.html</a> (i.e., the official docs):</p>
<div class="sourceCode" id="cb222" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb222-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb222-2" title="2"><span class="pp">#include </span><span class="im">&lt;curl/curl.h&gt;</span></a>
<a class="sourceLine" id="cb222-3" title="3"> </a>
<a class="sourceLine" id="cb222-4" title="4"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb222-5" title="5">  CURL *curl;</a>
<a class="sourceLine" id="cb222-6" title="6">  CURLcode res;</a>
<a class="sourceLine" id="cb222-7" title="7"> </a>
<a class="sourceLine" id="cb222-8" title="8">  curl_global_init(CURL_GLOBAL_DEFAULT);</a>
<a class="sourceLine" id="cb222-9" title="9"> </a>
<a class="sourceLine" id="cb222-10" title="10">  curl = curl_easy_init();</a>
<a class="sourceLine" id="cb222-11" title="11">  <span class="cf">if</span>( curl ) {</a>
<a class="sourceLine" id="cb222-12" title="12">    curl_easy_setopt(curl, CURLOPT_URL, <span class="st">&quot;https://example.com/&quot;</span> );</a>
<a class="sourceLine" id="cb222-13" title="13">    res = curl_easy_perform( curl );</a>
<a class="sourceLine" id="cb222-14" title="14">    </a>
<a class="sourceLine" id="cb222-15" title="15">  <span class="cf">if</span>( res != CURLE_OK ) {</a>
<a class="sourceLine" id="cb222-16" title="16">      fprintf(stderr, <span class="st">&quot;curl_easy_perform() failed: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, curl_easy_strerror(res));</a>
<a class="sourceLine" id="cb222-17" title="17">    }</a>
<a class="sourceLine" id="cb222-18" title="18">    curl_easy_cleanup(curl);</a>
<a class="sourceLine" id="cb222-19" title="19">  }</a>
<a class="sourceLine" id="cb222-20" title="20"> </a>
<a class="sourceLine" id="cb222-21" title="21">  curl_global_cleanup();</a>
<a class="sourceLine" id="cb222-22" title="22">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb222-23" title="23">}</a></code></pre></div>
<p>In the previous example, the call to <code>curl_easy_perform()</code> is blocking and we wait for the curl execution to take place. We want to change that! The tool for this is the “multi handle” - this is a structure that lets us have more than one curl easy handle. And rather than waiting, we can start them and then check on their progress.</p>
<p>There are still the global initialization and cleanup functions. The structure for the new multi-handle type is <code>CURLM</code> (instead of <code>CURL</code>) and it is initialized with the <code>curl_multi_init()</code> function.</p>
<p>Once we have a multi handle, we can add easy handles – however many we need – to the multi handle. Creation of the easy handle is the same as it is when being used alone - use <code>curl_easy_init()</code> to create it and then we can set however many options on this we need. Then, we add the easy handle to the multi handle with <code>curl_multi_add_handle( CURLM* cm, CURL* eh )</code>.</p>
<p>Once we have finished putting all the easy handles into the multi handle, we can dispatch them all at once with <code>curl_multi_perform( CURLM* cm, int* still_running )</code>. The second parameter is a pointer to an integer that is updated with the number of the easy handles in that multi handle that are still running. If it’s down to 0, then we know that they are all done. If it’s nonzero it means that some of them are still in progress.</p>
<p>This does mean that we’re going to call<code>curl_multi_perform()</code> more than once. Doing so doesn’t restart or interfere with anything that was already in progress – it just gives us an update on the status of what’s going on. We can check as often as we’d like, but the intention is of course to do something useful while the asynchronous I/O request(s) are going on. Otherwise, why not make it synchronous?</p>
<p>Suppose we’ve run out of things to do though. What then? Well, we can wait, if we want, using <code>curl_multi_wait( CURLM *multi_handle, struct curl_waitfd extra_fds[], unsigned int extra_nfds, int timeout_ms, int *numfds )</code> . This function will block the current thread until something happens (some event occurs).</p>
<p>The first parameter is the multi handle, which makes sense. The second parameter is a structure of extra file descriptors you can wait on (but we will always want this to be NULL in this course) and the third parameter is the count (the size of the provided array) which would also be zero here. Then the second-last parameter is a maximum time to wait. The last parameter is a pointer that will be updated with the actual number of “interesting” events that occurred (interesting is the word used in the specifications, and what it means is mysterious). For a simple use case you can ignore most of the parameters and just wait for something to happen and go from there.</p>
<p>In the meantime though, the perform operations are happening, and so are whatever callbacks we have set up (if any). And as the I/O operation moves through its life cycle, the state of the easy handle is updated appropriately. Each easy handle has an associated status message as well as a return code.</p>
<p>Why both? Well - one is about what the status of the request is. The message could be, for example “done”, but does that mean finished with success or finished with an error? For the second one tells us about that. We can ask about the status of the request using <code>curl_multi_info_read( CURLM* cm, int* msgs_left )</code>. This returns a pointer to information “next” easy handle, if there is one. The return value is a pointer to a struct of type <code>CURLMsg</code>. Along side this, the parameter <code>msgs_left</code> is updated to say how many messages remain (so you don’t have to remember or know in advance, really).</p>
<p>We will therefore check the <code>CURLMsg</code> message to see what happened and make sure all is well. If our message that we got back with the info read is called <code>m</code>, What we are looking for is that the <code>m-&gt;msg</code> is equal to <code>CURLMSG_DONE</code> – request completed. If not, this request is still in progress and we aren’t ready to evaluate whether it was successful or not. If there are more handles to look at, we should go on to the next. If it is done, we should look at the return code in and the result, in <code>m-&gt;data.result</code>. If it is <code>CURLE_OK</code> then everything succeeded. If it’s anything else, it indicates an error.</p>
<p>When a handle has finished, you need to remove it from the multi handle. A pointer to it is inside the <code>CURLMsg</code> under <code>m-&gt;easy_handle</code>. It is removed with <code>curl_multi_remove_handle( CURLM* cm, CURL eh )</code>. Once removed, it should be cleaned up like normal with <code>curl_easy_cleanup( CURL* eh )</code>.</p>
<p>There is of course the corresponding cleanup function <code>curl_multi_cleanup( CURLM * cm ) </code> for the multi handle when we are done with all the easy handles inside. The last step, as before, is to use the global cleanup function. After that we are done.</p>
<p>Let’s consider the following code example by Clemens Gruber <span class="citation" data-cites="curlmulti"></span>, with slight modifications for compactness, formatting, and to remember the cleanup. This example puts together all the things we talked about in one compact code segment. Here, the callback does nothing, but that’s okay – it’s just to show what you could do with it.</p>
<div class="sourceCode" id="cb223" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb223-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb223-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb223-3" title="3"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb223-4" title="4"><span class="pp">#include </span><span class="im">&lt;curl/multi.h&gt;</span></a>
<a class="sourceLine" id="cb223-5" title="5"></a>
<a class="sourceLine" id="cb223-6" title="6"><span class="pp">#define MAX_WAIT_MSECS 30*1000 </span><span class="co">/* Wait max. 30 seconds */</span></a>
<a class="sourceLine" id="cb223-7" title="7"></a>
<a class="sourceLine" id="cb223-8" title="8"><span class="dt">const</span> <span class="dt">char</span> *urls[] = {</a>
<a class="sourceLine" id="cb223-9" title="9">  <span class="st">&quot;http://www.microsoft.com&quot;</span>,</a>
<a class="sourceLine" id="cb223-10" title="10">  <span class="st">&quot;http://www.yahoo.com&quot;</span>,</a>
<a class="sourceLine" id="cb223-11" title="11">  <span class="st">&quot;http://www.wikipedia.org&quot;</span>,</a>
<a class="sourceLine" id="cb223-12" title="12">  <span class="st">&quot;http://slashdot.org&quot;</span></a>
<a class="sourceLine" id="cb223-13" title="13">};</a>
<a class="sourceLine" id="cb223-14" title="14"><span class="pp">#define CNT 4</span></a>
<a class="sourceLine" id="cb223-15" title="15"></a>
<a class="sourceLine" id="cb223-16" title="16"><span class="dt">size_t</span> cb(<span class="dt">char</span> *d, <span class="dt">size_t</span> n, <span class="dt">size_t</span> l, <span class="dt">void</span> *p) {</a>
<a class="sourceLine" id="cb223-17" title="17">  <span class="co">/* take care of the data here, ignored in this example */</span></a>
<a class="sourceLine" id="cb223-18" title="18">  <span class="cf">return</span> n*l;</a>
<a class="sourceLine" id="cb223-19" title="19">}</a>
<a class="sourceLine" id="cb223-20" title="20"></a>
<a class="sourceLine" id="cb223-21" title="21"><span class="dt">void</span> init( CURLM *cm, <span class="dt">int</span> i ) {</a>
<a class="sourceLine" id="cb223-22" title="22">  CURL *eh = curl_easy_init();</a>
<a class="sourceLine" id="cb223-23" title="23">  curl_easy_setopt( eh, CURLOPT_WRITEFUNCTION, cb );</a>
<a class="sourceLine" id="cb223-24" title="24">  curl_easy_setopt( eh, CURLOPT_HEADER, <span class="dv">0</span><span class="bu">L</span> );</a>
<a class="sourceLine" id="cb223-25" title="25">  curl_easy_setopt( eh, CURLOPT_URL, urls[i] );</a>
<a class="sourceLine" id="cb223-26" title="26">  curl_easy_setopt( eh, CURLOPT_PRIVATE, urls[i]) ;</a>
<a class="sourceLine" id="cb223-27" title="27">  curl_easy_setopt( eh, CURLOPT_VERBOSE, <span class="dv">0</span><span class="bu">L</span> );</a>
<a class="sourceLine" id="cb223-28" title="28">  curl_multi_add_handle( cm, eh );</a>
<a class="sourceLine" id="cb223-29" title="29">}</a>
<a class="sourceLine" id="cb223-30" title="30"></a>
<a class="sourceLine" id="cb223-31" title="31"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb223-32" title="32">    CURLM *cm = NULL;</a>
<a class="sourceLine" id="cb223-33" title="33">    CURL *eh = NULL;</a>
<a class="sourceLine" id="cb223-34" title="34">    CURLMsg *msg = NULL;</a>
<a class="sourceLine" id="cb223-35" title="35">    CURLcode return_code = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb223-36" title="36">    <span class="dt">int</span> still_running = <span class="dv">0</span>; </a>
<a class="sourceLine" id="cb223-37" title="37">    <span class="dt">int</span> msgs_left = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb223-38" title="38">    <span class="dt">int</span> http_status_code;</a>
<a class="sourceLine" id="cb223-39" title="39">    <span class="dt">const</span> <span class="dt">char</span> *szUrl;</a>
<a class="sourceLine" id="cb223-40" title="40"></a>
<a class="sourceLine" id="cb223-41" title="41">    curl_global_init( CURL_GLOBAL_ALL );</a>
<a class="sourceLine" id="cb223-42" title="42">    cm = curl_multi_init( );</a>
<a class="sourceLine" id="cb223-43" title="43"></a>
<a class="sourceLine" id="cb223-44" title="44">    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">0</span>; i &lt; CNT; ++i ) {</a>
<a class="sourceLine" id="cb223-45" title="45">        init( cm, i );</a>
<a class="sourceLine" id="cb223-46" title="46">    }</a>
<a class="sourceLine" id="cb223-47" title="47"></a>
<a class="sourceLine" id="cb223-48" title="48">    curl_multi_perform( cm, &amp;still_running );</a>
<a class="sourceLine" id="cb223-49" title="49"></a>
<a class="sourceLine" id="cb223-50" title="50">    <span class="cf">do</span> {</a>
<a class="sourceLine" id="cb223-51" title="51">        <span class="dt">int</span> numfds = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb223-52" title="52">        <span class="dt">int</span> res = curl_multi_wait( cm, NULL, <span class="dv">0</span>, MAX_WAIT_MSECS, &amp;numfds );</a>
<a class="sourceLine" id="cb223-53" title="53">        <span class="cf">if</span>( res != CURLM_OK ) {</a>
<a class="sourceLine" id="cb223-54" title="54">            fprintf( stderr, <span class="st">&quot;error: curl_multi_wait() returned %d</span><span class="sc">\n</span><span class="st">&quot;</span>, res );</a>
<a class="sourceLine" id="cb223-55" title="55">            <span class="cf">return</span> EXIT_FAILURE;</a>
<a class="sourceLine" id="cb223-56" title="56">        }</a>
<a class="sourceLine" id="cb223-57" title="57">        curl_multi_perform( cm, &amp;still_running );</a>
<a class="sourceLine" id="cb223-58" title="58"></a>
<a class="sourceLine" id="cb223-59" title="59">    } <span class="cf">while</span>( still_running );</a>
<a class="sourceLine" id="cb223-60" title="60"></a>
<a class="sourceLine" id="cb223-61" title="61">    <span class="cf">while</span> ( ( msg = curl_multi_info_read( cm, &amp;msgs_left ) ) ) {</a>
<a class="sourceLine" id="cb223-62" title="62">        <span class="cf">if</span> ( msg-&gt;msg == CURLMSG_DONE ) {</a>
<a class="sourceLine" id="cb223-63" title="63">            eh = msg-&gt;easy_handle;</a>
<a class="sourceLine" id="cb223-64" title="64"></a>
<a class="sourceLine" id="cb223-65" title="65">            return_code = msg-&gt;data.result;</a>
<a class="sourceLine" id="cb223-66" title="66">            <span class="cf">if</span> ( return_code != CURLE_OK ) {</a>
<a class="sourceLine" id="cb223-67" title="67">                fprintf( stderr, <span class="st">&quot;CURL error code: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, msg-&gt;data.result );</a>
<a class="sourceLine" id="cb223-68" title="68">                <span class="cf">continue</span>;</a>
<a class="sourceLine" id="cb223-69" title="69">            }</a>
<a class="sourceLine" id="cb223-70" title="70"></a>
<a class="sourceLine" id="cb223-71" title="71">            <span class="co">// Get HTTP status code</span></a>
<a class="sourceLine" id="cb223-72" title="72">            http_status_code = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb223-73" title="73">            szUrl = NULL;</a>
<a class="sourceLine" id="cb223-74" title="74"></a>
<a class="sourceLine" id="cb223-75" title="75">            curl_easy_getinfo( eh, CURLINFO_RESPONSE_CODE, &amp;http_status_code );</a>
<a class="sourceLine" id="cb223-76" title="76">            curl_easy_getinfo( eh, CURLINFO_PRIVATE, &amp;szUrl );</a>
<a class="sourceLine" id="cb223-77" title="77"></a>
<a class="sourceLine" id="cb223-78" title="78">            <span class="cf">if</span>( http_status_code == <span class="dv">200</span> ) {</a>
<a class="sourceLine" id="cb223-79" title="79">                printf( <span class="st">&quot;200 OK for %s</span><span class="sc">\n</span><span class="st">&quot;</span>, szUrl ) ;</a>
<a class="sourceLine" id="cb223-80" title="80">            } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb223-81" title="81">                fprintf( stderr, <span class="st">&quot;GET of %s returned http status code %d</span><span class="sc">\n</span><span class="st">&quot;</span>, szUrl, http_status_code );</a>
<a class="sourceLine" id="cb223-82" title="82">            }</a>
<a class="sourceLine" id="cb223-83" title="83"></a>
<a class="sourceLine" id="cb223-84" title="84">            curl_multi_remove_handle( cm, eh );</a>
<a class="sourceLine" id="cb223-85" title="85">            curl_easy_cleanup( eh );</a>
<a class="sourceLine" id="cb223-86" title="86">        } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb223-87" title="87">            fprintf( stderr, <span class="st">&quot;error: after curl_multi_info_read(), CURLMsg=%d</span><span class="sc">\n</span><span class="st">&quot;</span>, msg-&gt;msg );</a>
<a class="sourceLine" id="cb223-88" title="88">        }</a>
<a class="sourceLine" id="cb223-89" title="89">    }</a>
<a class="sourceLine" id="cb223-90" title="90">    curl_multi_cleanup( cm );</a>
<a class="sourceLine" id="cb223-91" title="91">    curl_global_cleanup();</a>
<a class="sourceLine" id="cb223-92" title="92">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb223-93" title="93">}</a></code></pre></div>
<p>You may wonder about re-using an easy handle rather than removing and destroying it and making a new one. The official docs say that you can re-use one, but you have to remove it from the multi handle and then re-add it, presumably after having changed anything that you want to change about that handle. In the example above, handles are not reused, but if we wanted to we would reset whatever parameters, if any, and then re-add it with <code>curl_multi_add_handle</code>.</p>
<p>Because a handle could be replaced with another one (or the same one), you could have a situation where there are constantly handles in progress and you might never be at a situation where there are no messages left. And that is okay.</p>
<p>In this example all requests had the same (useless) callback, but of course you could have different callbacks for different easy handles if you wanted them to do different things.</p>
<p>How well does this scale? The developer claims that you can have multiple thousands of connections in a single multi handle<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a>. And 60k ought to be enough for anyone!</p>
<h5 id="i-enjoy-pain">I enjoy pain!</h5>
<p>You can use cURL with <code>select()</code> if you wish, although it comes with an anti-recommendation: I think you shouldn’t do it. But you can if you want. In some ways, cURL does make things less painful because it does some of the grunt work for you.</p>
<p>The first part of using cURL with select is of course setting up your multi handle and adding all of the easy handles to that. Once you’ve done that, you can ask cURL to prep things for you using <code>curl_multi_fdset</code>:</p>
<div class="sourceCode" id="cb224" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb224-1" title="1">CURLMcode curl_multi_fdset( CURLM *multi_handle, fd_set *read_fd_set, fd_set *write_fd_set, fd_set *exc_fd_set, <span class="dt">int</span> *max_fd );</a></code></pre></div>
<p>It takes as arguments, first of all, the multi handle, and then pointers to the <code>fd_set</code>s. It’s the responsibility of the caller to set these to zero with <code>FD_ZERO</code> before calling this. And then finally, the function is kind enough to tell you what the maximum file descriptor is. Which is convenient! You can give in <code>NULL</code> for the sets if you like. So, a super simple example:</p>
<div class="sourceCode" id="cb225" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb225-1" title="1">fd_set fdr;</a>
<a class="sourceLine" id="cb225-2" title="2">fd_set fdw;</a>
<a class="sourceLine" id="cb225-3" title="3">fd_set fde;</a>
<a class="sourceLine" id="cb225-4" title="4">FD_ZERO( &amp;fdr );</a>
<a class="sourceLine" id="cb225-5" title="5">FD_ZERO( &amp;fdw );</a>
<a class="sourceLine" id="cb225-6" title="6">FD_ZERO( &amp;fde );</a>
<a class="sourceLine" id="cb225-7" title="7"><span class="dt">int</span> maxfd = -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb225-8" title="8"></a>
<a class="sourceLine" id="cb225-9" title="9">CURLMCode res = curl_multi_fdset( cm, &amp;fdr, &amp;fdw, &amp;fde, &amp;maxfd );</a></code></pre></div>
<p>This fills in the values of <code>dread</code> and <code>maxfd</code> for us, which is some of what, but not everything that, we need. When calling select we still have to put a <code>+1</code> on the max file descriptor, but that is no big deal. The missing element is the timeout. For that there is another function:</p>
<div class="sourceCode" id="cb226" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb226-1" title="1">CURLMcode curl_multi_timeout( CURLM *multi_handle, <span class="dt">long</span> *timeout );</a></code></pre></div>
<p>Unfortunately, though, this returns a <code>long</code> and not one of the time structures we’ve seen previously. So you have to do the math yourself. Why could this not be in the spec... or a standard function. This is certainly the sort of thing that you would want to write into a function to convert, so you don’t do it by hand every single time. See the example below of how to convert it, as written in the documentation:</p>
<div class="sourceCode" id="cb227" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb227-1" title="1"><span class="kw">struct</span> timeval timeout;</a>
<a class="sourceLine" id="cb227-2" title="2"><span class="dt">long</span> timeo;</a>
<a class="sourceLine" id="cb227-3" title="3"> </a>
<a class="sourceLine" id="cb227-4" title="4">curl_multi_timeout( cm, &amp;timeo );</a>
<a class="sourceLine" id="cb227-5" title="5"><span class="cf">if</span>(timeo &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb227-6" title="6">  <span class="co">/* no set timeout, use a default */</span></a>
<a class="sourceLine" id="cb227-7" title="7">  timeo = <span class="dv">980</span>;</a>
<a class="sourceLine" id="cb227-8" title="8">}</a>
<a class="sourceLine" id="cb227-9" title="9"> </a>
<a class="sourceLine" id="cb227-10" title="10">timeout.tv_sec = timeo / <span class="dv">1000</span>;</a>
<a class="sourceLine" id="cb227-11" title="11">timeout.tv_usec = (timeo % <span class="dv">1000</span>) * <span class="dv">1000</span>;</a></code></pre></div>
<p>But we aren’t ready to call <code>select</code> yet – we haven’t started any of the transfers that use the sockets. For that we use <code>curl_multi_perform</code> just as in the earlier example. That starts the transfers. If you follow the cURL examples, they do that step before calling any of the setup functions that prepare the arguments for <code>select</code>, because you can do this setup while the transfers are in progress. Or you can do it after the setup, but it does have to be before the call to <code>select</code>. Otherwise <code>select</code> is waiting for a thing that won’t happen: if there are no transfers in progress then data won’t become available.</p>
<p>When we wake up, it is because something happened, and we still use <code>curl_multi_info_read</code> to find out what’s going on with a given easy handle and find out its status and also find out how many are still running. As with the earlier code where we used <code>select</code> on sockets directly, we have to remember to reset (repopulate) the values that are passed to that function before the next iteration of the loop.</p>
<p>We still have to remember to clean everything up: both the cURL related stuff and anything related to <code>select</code>.</p>
<p>One of the other problems with <code>select</code> is that you are limited in the number of file descriptors because you could overflow the bitmasks. But even if you don’t, this really does not scale, so you would be better off using the regular curl multi call. As far as I can see it’s better in pretty much every way.</p>
<h5 id="maybe-not-this-much-pain...">Maybe not this much pain...</h5>
<p>Can we use cURL with <code>poll</code>? Generally, no. The lead developer of cURL himself says that the way forward here is to use <code>curl_multi_wait</code> instead of the <code>select</code> interface and that there isn’t really a <code>poll</code> interface for it<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>. Long story short: don’t.</p>
<h1 id="asynchronous-io-with-aio" class="unnumbered">31 — Asynchronous I/O with AIO</h1>
<h2 id="aio" class="unnumbered">AIO</h2>
<p>Previously we had talked about how just opening a file for non-blocking I/O doesn’t quite do what we want. There is, however, a way to do what we want using the POSIX Asynchronous I/O Interface, which we will just call AIO from here on, because it’s shorter.</p>
<p>The general approach is that you create a control block (<code>struct aiocb</code> – AIO Control Block) that specifies what operation you want to happen. You enqueue this structure by telling the operating system that you want this to happen. And you can, if you wish, set up a callback to run if the desired event occurs, or you can check periodically if the AIO has completed instead. Your choice. Whichever one depends on your application.</p>
<p>Let’s look at the structure of an AIO control block <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb228" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb228-1" title="1"><span class="kw">struct</span> aiocb {</a>
<a class="sourceLine" id="cb228-2" title="2">  <span class="dt">int</span> aio_fildes;               <span class="co">/* File descriptor */</span></a>
<a class="sourceLine" id="cb228-3" title="3">  off_t aio_offset;             <span class="co">/* Offset for I/O */</span></a>
<a class="sourceLine" id="cb228-4" title="4">  <span class="dt">volatile</span> <span class="dt">void</span>* aio_buf;       <span class="co">/* Buffer */</span></a>
<a class="sourceLine" id="cb228-5" title="5">  <span class="dt">size_t</span> aio_nbytes;            <span class="co">/* Number of bytes to transfer */</span></a>
<a class="sourceLine" id="cb228-6" title="6">  <span class="dt">int</span> aio_reqprio;              <span class="co">/* Request priority */</span></a>
<a class="sourceLine" id="cb228-7" title="7">  <span class="kw">struct</span> sigevent aio_sigevent; <span class="co">/* Signal Info */</span></a>
<a class="sourceLine" id="cb228-8" title="8">  <span class="dt">int</span> aio_lio_opcode;           <span class="co">/* Operation for List I/O */</span></a>
<a class="sourceLine" id="cb228-9" title="9">};</a></code></pre></div>
<p>So, looking at the fields: the first is obviously the file descriptor of the file we would like to read or write; the offset is how far into the file we start the operation. The buffer is the source (for a write) or destination (for a read). Those cover the mandatory fields and the ones that most resemble our typical read or write operation. At this point we could skip right to the example, if we knew how to enqueue a request.</p>
<p>A couple of notes are in order. The offset does nothing if the file has been opened in “append” mode. Also, when we do a write or read the pointer to the place where we are in the file advances as per usual, but it’s not the same pointer into the file as the regular (blocking) read and write operations. If you mix the two kinds of operations you may not get the behaviour that you want.</p>
<p>The priority field is a suggestion that we can provide as to how the AIO events should be scheduled, but the operating system is free to ignore this if it wishes. We’ll just ignore the ability to set priorities for the purposes of this course. The last parameter is about list-based asynchronous I/O (a more advanced topic), but we need to look deeper at the event first. The best way to do that is to look at the structure:</p>
<div class="sourceCode" id="cb229" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb229-1" title="1"><span class="kw">struct</span> sigevent {</a>
<a class="sourceLine" id="cb229-2" title="2">  <span class="dt">int</span> sigev_notify;                              <span class="co">/* Notify Type */</span></a>
<a class="sourceLine" id="cb229-3" title="3">  <span class="dt">int</span> sigev_signo;                               <span class="co">/* Signal number */</span></a>
<a class="sourceLine" id="cb229-4" title="4">  <span class="kw">union</span> sigval sigev_value;                      <span class="co">/* Notify argument */</span></a>
<a class="sourceLine" id="cb229-5" title="5">  <span class="dt">void</span>* (*sigev_notify_function) (<span class="kw">union</span> sigval); <span class="co">/* Notify Function */</span></a>
<a class="sourceLine" id="cb229-6" title="6">  pthread_attr_t *sigev_notify_attributes;       <span class="co">/* Notify attributes */</span></a>
<a class="sourceLine" id="cb229-7" title="7">};</a></code></pre></div>
<p>(If you’re confused about a <code>union</code>: it’s defined like a structure, except where the struct is made of all of the fields in the definition, a union can be any single one of the fields of the definition at a time.) A <code>sigval</code> is either an integer or a <code>void*</code> pointer.</p>
<p>The first field is one of the following options:</p>
<ul>
<li><p><code>SIGEV_NONE</code>: Don’t do anything when the request completes.</p></li>
<li><p><code>SIGEV_SIGNAL</code>: The signal specified in the signal number field is generated when the request is complete.</p></li>
<li><p><code>SIGEV_THREAD</code>: The function specified in the notify function field is executed, in a different, detached thread. The argument to this function is the signal value. And the attributes of the thread (including whether it is detached) can be overridden using the last parameter if you wish.</p></li>
</ul>
<p>We should notice that the signature of the function is not the same as when creating pthreads: the return type is just <code>void</code> and not a void pointer; the argument is <code>union sigval</code> rather than a void pointer. The definition of the union is:</p>
<div class="sourceCode" id="cb230" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb230-1" title="1"><span class="kw">union</span> sigval {</a>
<a class="sourceLine" id="cb230-2" title="2">  <span class="dt">int</span> sival_int;</a>
<a class="sourceLine" id="cb230-3" title="3">  <span class="dt">void</span>* sival_ptr;</a>
<a class="sourceLine" id="cb230-4" title="4">};</a></code></pre></div>
<p>Using this, we can choose what we want to happen when the AIO event is complete, if anything. The thread approach is probably the one we’ll use most commonly, because it is flexible and convenient. Alright, let’s go!</p>
<p>When we’re ready to enqueue a request, the functions are:</p>
<div class="sourceCode" id="cb231" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb231-1" title="1"><span class="dt">int</span> aio_read( <span class="kw">struct</span> aiocb* aiocb );</a>
<a class="sourceLine" id="cb231-2" title="2"><span class="dt">int</span> aio_write( <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<p>These are self-explanatory, I would think. The return values are not the same as the actual I/O request return value (as we’ll see). It is important to know that once we enqueue the result we can’t change the control block or buffer while the operation is in progress, otherwise we might get inconsistent results. And so if we want to know if we are done <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb232" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb232-1" title="1"><span class="dt">int</span> aio_error( <span class="dt">const</span> <span class="kw">struct</span> aiocb* aiocb );</a>
<a class="sourceLine" id="cb232-2" title="2"><span class="dt">ssize_t</span> aio_return( <span class="dt">const</span> <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<p>The <code>aio_error</code> function should probably really be called <code>aio_status</code> instead, because it tells you what the status of the operation is. A return value of 0 means the operation has completed successfully! A return of -1 means that the call failed and <code>errno</code> tells you the actual reason. If the operation is still waiting to run or in progress the return value is <code>EINPROGRESS</code>; if we get any other value then an error occurred and the value is the error code.</p>
<p>If the operation completed successfully, <code>aio_return</code> will get the return value from the read or write operation. Calling this while the operation in still progress returns undefined results and potentially fails. We can call this only once per AIO operation; once the value has been collected then some internal structures can be deallocated, so it is polite to call it even if you do not need it.</p>
<h5 id="aio-example-read-while-you-eat.">AIO Example: Read While You Eat.</h5>
<p>Suppose we have been asked to design a program that processes a group of files. We can use asynchronous I/O to partially parallelize this: start the read for file <span class="math inline">n+1</span> and process file <span class="math inline">n</span> in the meantime. This doesn’t work for the first file, so a blocking read takes place first. The maximum size of any file we will read is <code>MAX_SIZE</code>, so always use this size as the length of a read (even though we may read less, that’s okay). We need two buffers: one for the file being processed and one where the next read is taking place.</p>
<p>A list of files to read will be provided as arguments on the commandline to the program. To make the code a bit more compact, we’ll assume that errors won’t occur and therefore we do not need to check for them (i.e., memory allocation, enqueuing an asynchronous read, actually reading the data, et cetera, will always succeed).</p>
<p>In this example, rather than set up a callback, we’ll just do the thing where we check to see if the enqueued AIO has occurred and sleep if it’s not ready. We could consider changing this to create a thread instead, but using threads is something we may save for a future exercise.</p>
<div class="sourceCode" id="cb233" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb233-1" title="1"><span class="dt">void</span> process( <span class="dt">char</span>* buffer ); <span class="co">/* Implementation not shown */</span></a>
<a class="sourceLine" id="cb233-2" title="2"></a>
<a class="sourceLine" id="cb233-3" title="3"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb233-4" title="4">  <span class="dt">char</span>* buffer1 = malloc( MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb233-5" title="5">  <span class="dt">char</span>* buffer2 = malloc( MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb233-6" title="6">  </a>
<a class="sourceLine" id="cb233-7" title="7">  <span class="dt">int</span> fd = open( argv[<span class="dv">1</span>], O_RDONLY );</a>
<a class="sourceLine" id="cb233-8" title="8">  memset( buffer1, <span class="dv">0</span>, MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb233-9" title="9">  read( fd, buffer1, MAX_SIZE );</a>
<a class="sourceLine" id="cb233-10" title="10">  close( fd );</a>
<a class="sourceLine" id="cb233-11" title="11">  </a>
<a class="sourceLine" id="cb233-12" title="12">  <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">2</span>; i &lt; argc; i++ ) {</a>
<a class="sourceLine" id="cb233-13" title="13">    <span class="dt">int</span> nextFD = open( argv[i], O_RDONLY );</a>
<a class="sourceLine" id="cb233-14" title="14">    </a>
<a class="sourceLine" id="cb233-15" title="15">    <span class="kw">struct</span> aiocb cb;</a>
<a class="sourceLine" id="cb233-16" title="16">    memset( &amp;cb, <span class="dv">0</span>, <span class="kw">sizeof</span>( <span class="kw">struct</span> aiocb ));</a>
<a class="sourceLine" id="cb233-17" title="17">    </a>
<a class="sourceLine" id="cb233-18" title="18">    cb.aio_nbytes = MAX_SIZE;</a>
<a class="sourceLine" id="cb233-19" title="19">    cb.aio_fildes = nextFD;</a>
<a class="sourceLine" id="cb233-20" title="20">    cb.aio_offset = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb233-21" title="21">    memset( buffer2, <span class="dv">0</span>, MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb233-22" title="22">    cb.aio_buf = buffer2;</a>
<a class="sourceLine" id="cb233-23" title="23">    aio_read( &amp;cb );</a>
<a class="sourceLine" id="cb233-24" title="24"> </a>
<a class="sourceLine" id="cb233-25" title="25">    process( buffer1 );</a>
<a class="sourceLine" id="cb233-26" title="26">    </a>
<a class="sourceLine" id="cb233-27" title="27">    <span class="cf">while</span>( aio_error( &amp;cb ) == EINPROGRESS ) {</a>
<a class="sourceLine" id="cb233-28" title="28">      sleep( <span class="dv">1</span> );</a>
<a class="sourceLine" id="cb233-29" title="29">    }</a>
<a class="sourceLine" id="cb233-30" title="30">    aio_return( &amp;cb ); <span class="co">/* This frees some internal structures */</span></a>
<a class="sourceLine" id="cb233-31" title="31">    close( nextFD );</a>
<a class="sourceLine" id="cb233-32" title="32">    </a>
<a class="sourceLine" id="cb233-33" title="33">    <span class="dt">char</span>* tmp = buffer1;</a>
<a class="sourceLine" id="cb233-34" title="34">    buffer1 = buffer2;</a>
<a class="sourceLine" id="cb233-35" title="35">    buffer2 = tmp;</a>
<a class="sourceLine" id="cb233-36" title="36">  }</a>
<a class="sourceLine" id="cb233-37" title="37">  process( buffer1 );</a>
<a class="sourceLine" id="cb233-38" title="38">  free( buffer1 );</a>
<a class="sourceLine" id="cb233-39" title="39">  free( buffer2 );</a>
<a class="sourceLine" id="cb233-40" title="40"></a>
<a class="sourceLine" id="cb233-41" title="41">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb233-42" title="42">}</a></code></pre></div>
<p>It’s worth noting that we need the header <code>aio.h</code> and to compile with the <code>-lrt</code> option.</p>
<p>Is sleep really the best way to deal with this? I would argue no: if we have nothing to do we could get blocked instead. There is a function that allows us to do that <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb234" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb234-1" title="1"><span class="dt">int</span> aio_suspend( <span class="dt">const</span> <span class="kw">struct</span> aiocb *<span class="dt">const</span> list[], <span class="dt">int</span> nent, <span class="dt">const</span> <span class="kw">struct</span> timespec* timeout );</a></code></pre></div>
<p>The first argument is an array of the control blocks; the second is the size of this array; the last is a timeout. This function allows us to block until one of the AIO operations in the list is complete, or the timeout elapses. If the timeout does occur then the function returns -1; if any AIO request finishes then 0 is returned. If everything was finished already by the time this function was called, the function does not block.</p>
<h5 id="callback-when-aio-is-complete.">Callback when AIO is complete.</h5>
<p>Let’s also look at setting up a callback that makes a function run when the AIO is completed:</p>
<div class="sourceCode" id="cb235" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb235-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb235-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb235-3" title="3"><span class="pp">#include </span><span class="im">&lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb235-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb235-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb235-6" title="6"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb235-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb235-8" title="8"><span class="pp">#include </span><span class="im">&lt;pthread.h&gt;</span></a>
<a class="sourceLine" id="cb235-9" title="9"></a>
<a class="sourceLine" id="cb235-10" title="10"><span class="pp">#define MAX_SIZE 512</span></a>
<a class="sourceLine" id="cb235-11" title="11"></a>
<a class="sourceLine" id="cb235-12" title="12"><span class="dt">void</span> worker( <span class="kw">union</span> sigval argument) {</a>
<a class="sourceLine" id="cb235-13" title="13">    <span class="dt">char</span>* buffer = (<span class="dt">char</span>*) argument.sival_ptr;</a>
<a class="sourceLine" id="cb235-14" title="14">    printf(<span class="st">&quot;Worker thread here. Buffer contains: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, buffer);</a>
<a class="sourceLine" id="cb235-15" title="15">    free( buffer );</a>
<a class="sourceLine" id="cb235-16" title="16">}</a>
<a class="sourceLine" id="cb235-17" title="17"></a>
<a class="sourceLine" id="cb235-18" title="18"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb235-19" title="19">    <span class="dt">char</span>* buffer = malloc( MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb235-20" title="20"></a>
<a class="sourceLine" id="cb235-21" title="21">    <span class="dt">int</span> fd = open( <span class="st">&quot;example.txt&quot;</span>, O_RDONLY );</a>
<a class="sourceLine" id="cb235-22" title="22">    memset( buffer, <span class="dv">0</span>, MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb235-23" title="23">    <span class="kw">struct</span> aiocb cb;</a>
<a class="sourceLine" id="cb235-24" title="24">    memset( &amp;cb, <span class="dv">0</span>, <span class="kw">sizeof</span>( <span class="kw">struct</span> aiocb ));</a>
<a class="sourceLine" id="cb235-25" title="25"></a>
<a class="sourceLine" id="cb235-26" title="26">    cb.aio_nbytes = MAX_SIZE;</a>
<a class="sourceLine" id="cb235-27" title="27">    cb.aio_fildes = fd;</a>
<a class="sourceLine" id="cb235-28" title="28">    cb.aio_offset = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb235-29" title="29">    cb.aio_buf = buffer;</a>
<a class="sourceLine" id="cb235-30" title="30">    cb.aio_sigevent.sigev_notify = SIGEV_THREAD;</a>
<a class="sourceLine" id="cb235-31" title="31">    cb.aio_sigevent.sigev_notify_function = worker;</a>
<a class="sourceLine" id="cb235-32" title="32">    cb.aio_sigevent.sigev_value.sival_ptr = buffer;</a>
<a class="sourceLine" id="cb235-33" title="33"></a>
<a class="sourceLine" id="cb235-34" title="34">    aio_read( &amp;cb );</a>
<a class="sourceLine" id="cb235-35" title="35">    </a>
<a class="sourceLine" id="cb235-36" title="36">    pthread_exit( NULL );</a>
<a class="sourceLine" id="cb235-37" title="37">}</a></code></pre></div>
<p>If an AIO request is no longer needed, it can be cancelled <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb236" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb236-1" title="1"><span class="dt">int</span> aio_cancel( <span class="dt">int</span> fd, <span class="kw">struct</span> aiocb* aiocb );</a></code></pre></div>
<p>We specify the file descriptor with the AIO operations and the specific request we wish to cancel. If <code>NULL</code> is given as the control block argument, then it tries to cancel all outstanding asynchronous I/O requests for that file.</p>
<p>Ah, you noticed that I said “tries” to cancel. This function returns one of four values:</p>
<ul>
<li><p><code>AIO_CANCELLED</code>: The requested operation(s) have been cancelled.</p></li>
<li><p><code>AIO_NOTCANCELLED</code>: At least one operation could not be cancelled.</p></li>
<li><p>-1: Something went wrong in cancelling; <code>errno</code> set.</p></li>
<li><p><code>AIO_ALLDONE</code>: All operations finished before they could be cancelled.</p></li>
</ul>
<p>Here, a silly but complete example of creating a request and then immediately cancelling it:</p>
<div class="sourceCode" id="cb237" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb237-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb237-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb237-3" title="3"><span class="pp">#include </span><span class="im">&lt;aio.h&gt;</span></a>
<a class="sourceLine" id="cb237-4" title="4"><span class="pp">#include </span><span class="im">&lt;fcntl.h&gt;</span></a>
<a class="sourceLine" id="cb237-5" title="5"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb237-6" title="6"><span class="pp">#include </span><span class="im">&lt;errno.h&gt;</span></a>
<a class="sourceLine" id="cb237-7" title="7"><span class="pp">#include </span><span class="im">&lt;unistd.h&gt;</span></a>
<a class="sourceLine" id="cb237-8" title="8"></a>
<a class="sourceLine" id="cb237-9" title="9"><span class="pp">#define MAX_SIZE 512</span></a>
<a class="sourceLine" id="cb237-10" title="10"></a>
<a class="sourceLine" id="cb237-11" title="11"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) {</a>
<a class="sourceLine" id="cb237-12" title="12">    <span class="dt">char</span>* buffer = malloc( MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb237-13" title="13"></a>
<a class="sourceLine" id="cb237-14" title="14">    <span class="dt">int</span> fd = open( <span class="st">&quot;example.txt&quot;</span>, O_RDONLY );</a>
<a class="sourceLine" id="cb237-15" title="15">    memset( buffer, <span class="dv">0</span>, MAX_SIZE * <span class="kw">sizeof</span>( <span class="dt">char</span> ));</a>
<a class="sourceLine" id="cb237-16" title="16"></a>
<a class="sourceLine" id="cb237-17" title="17">    <span class="kw">struct</span> aiocb cb;</a>
<a class="sourceLine" id="cb237-18" title="18">    memset( &amp;cb, <span class="dv">0</span>, <span class="kw">sizeof</span>( <span class="kw">struct</span> aiocb ));</a>
<a class="sourceLine" id="cb237-19" title="19"></a>
<a class="sourceLine" id="cb237-20" title="20">    cb.aio_nbytes = MAX_SIZE;</a>
<a class="sourceLine" id="cb237-21" title="21">    cb.aio_fildes = fd;</a>
<a class="sourceLine" id="cb237-22" title="22">    cb.aio_offset = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb237-23" title="23">    cb.aio_buf = buffer;</a>
<a class="sourceLine" id="cb237-24" title="24">    aio_read( &amp;cb );</a>
<a class="sourceLine" id="cb237-25" title="25">    </a>
<a class="sourceLine" id="cb237-26" title="26">    <span class="co">/* Do something */</span></a>
<a class="sourceLine" id="cb237-27" title="27">    </a>
<a class="sourceLine" id="cb237-28" title="28">    aio_cancel( fd, &amp; cb );</a>
<a class="sourceLine" id="cb237-29" title="29"></a>
<a class="sourceLine" id="cb237-30" title="30">    sleep( <span class="dv">5</span> );</a>
<a class="sourceLine" id="cb237-31" title="31"></a>
<a class="sourceLine" id="cb237-32" title="32">    close( fd );</a>
<a class="sourceLine" id="cb237-33" title="33">    free( buffer );</a>
<a class="sourceLine" id="cb237-34" title="34"></a>
<a class="sourceLine" id="cb237-35" title="35">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb237-36" title="36">}</a></code></pre></div>
<h5 id="one-last-thing-the-list.">One last thing: the list.</h5>
<p>In the AIO control block there was one more parameter that we did not cover but said that we would come back to: <code>aio_lio_opcode</code>. What’s this for? Well, we can submit a group of AIO requests in a single operation. Rather than calling read or write individually on each control block, the following function allows us to enqueue a list of requests all in one go <span class="citation" data-cites="apunix"></span>:</p>
<div class="sourceCode" id="cb238" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb238-1" title="1"><span class="dt">int</span> lio_listio( <span class="dt">int</span> mode, <span class="kw">struct</span> aiocb * <span class="dt">const</span> list[ ], <span class="dt">int</span> nent, </a>
<a class="sourceLine" id="cb238-2" title="2">    <span class="kw">struct</span> sigevent* sigev );</a></code></pre></div>
<p>The first argument <code>mode</code> is a choice of either <code>LIO_WAIT</code> or <code>LIO_NOWAIT</code>. If we choose the wait option, then the function doesn’t return until all the operations are complete. If that’s the case, the last argument is ignored. If we choose no-wait, then as soon as the I/O requests are queued the function returns and we can go on.</p>
<p>The next parameters are the list (array) of control blocks and the number of entries in that list (array); not surprising at all. If it’s going into the <code>lio_listio</code> function, in the AIO block you specify the <code>aio_lio_opcode</code> (operation code) as either <code>LIO_READ</code>, <code>LIO_WRITE</code>, or <code>LIO_NOP</code> (this one means do nothing).</p>
<p>The last parameter is an event that will fire once all operations are complete. You can pass in <code>NULL</code> if you don’t want anything. This is separate from the individual callbacks that you can register in the control blocks; those can still fire if they are set up, either signals or threads – but this is an extra one that’s available if we want it.</p>
<h5 id="aio-is-hard">AIO is HARD!</h5>
<p>There’s a funny (and sad) note in <span class="citation" data-cites="lpi"></span> and <span class="citation" data-cites="linuxaio"></span> about what actually happens in Linux when it comes to the POSIX Asynchronous I/O approach: it’s actually implemented internally using threads that do blocking reads (ouch). Work continues on the subject, but the current state of affairs is that for a long time people have been working on a properly in-the-kernel implementation of the AIO behaviour as specified above. The current implementation does not scale very well.</p>
<p>Does this affect your program? No – what we covered here does still work and is the POSIX-compliant portable way of writing your code. But should you wish to create a very large number of asynchronous I/O requests then you will want to consider an alternative approach for reading your data, such as libevent.</p>
<h1 id="event-driven-io-with-libevent" class="unnumbered">32 — Event-Driven I/O with libevent</h1>
<h2 id="event-driven-io-with-libevent-1" class="unnumbered">Event-Driven I/O with libevent</h2>
<p>We’ve now looked at a few different kinds of asynchronous I/O, including select/poll, cURL, and POSIX AIO. All of these seem to have some drawbacks, though. The libevent library is meant for high performance applications and scalable network servers. Instead of focusing now on whether an operation is blocking or not, we’ll try to think about I/O as events: when something happens, take some action.</p>
<h5 id="getting-ready.">Getting ready.</h5>
<p>The library supports a lot of different configuration options. Most of them are too advanced for consideration in this class, such as telling it how you want to handle fatal errors or override default memory allocation and deallocation behaviour. But the most important setup thing is that we need to configure it to use the pthreads library and functions. For this, the function is <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb239" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb239-1" title="1"><span class="dt">int</span> evthread_use_pthreads( )</a></code></pre></div>
<p>It returns 0 on success and -1 on failure. There exists a matching Windows function, but obviously that doesn’t work if running under Linux... This function is a composite of several configurations about locks and condition variables and threads, so there’s no need to use the smaller ones. Just use this top level function and we’re ready to go.</p>
<h5 id="all-your-base...">All your base...</h5>
<p>Our goal is to handle events of some sort. Each event is associated with an <code>event_base</code> structure, which is a container for a set of events and has some associated configuration. If locking is enabled, it’s safe to use in multiple threads, though its loop can only be in one thread. So we might need multiple bases for multiple thread operations.</p>
<p>We can choose what method we would like the event base to use check what events are ready. There are many, but the ones we are most familiar with are already here: select and poll. Other options include epoll, kqueue, dnvpoll, evport, win32 <span class="citation" data-cites="libevent"></span>.</p>
<p>To create an event base, we can do it in one of two ways:</p>
<div class="sourceCode" id="cb240" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb240-1" title="1"><span class="kw">struct</span> event_base* event_base_new( ); <span class="co">/* Create an event_base with default settings */</span></a>
<a class="sourceLine" id="cb240-2" title="2"><span class="kw">struct</span> event_base* event_base_new_with_config( <span class="dt">const</span> <span class="kw">struct</span> event_config* cfg ); <span class="co">/* Create with configuration */</span></a>
<a class="sourceLine" id="cb240-3" title="3"><span class="kw">struct</span> event_config* event_config_new( );</a>
<a class="sourceLine" id="cb240-4" title="4"><span class="dt">void</span> event_config_free( <span class="kw">struct</span> event_config* cfg );</a></code></pre></div>
<p>Like with pthreads, the use of a configuration structure is optional. If we do want one, there are separate functions to allocate and to clean them up. The options allow us to say that we would like to avoid certain methods for checking on events and configure arcane options. We’ll say that for the purposes of this course that default options are fine.</p>
<p>To deallocate an event base, the (self-explanatory) function for that is:</p>
<div class="sourceCode" id="cb241" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb241-1" title="1"><span class="dt">void</span> event_base_free( <span class="kw">struct</span> event_base* base );</a></code></pre></div>
<p>Let’s consider a brief example, then, in which we can ask on one of our servers what is available <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb242" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb242-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb242-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb242-3" title="3"><span class="pp">#include </span><span class="im">&lt;event2/event.h&gt;</span></a>
<a class="sourceLine" id="cb242-4" title="4"></a>
<a class="sourceLine" id="cb242-5" title="5"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb242-6" title="6"></a>
<a class="sourceLine" id="cb242-7" title="7">    <span class="dt">int</span> i;</a>
<a class="sourceLine" id="cb242-8" title="8">    <span class="dt">const</span> <span class="dt">char</span> **methods = event_get_supported_methods();</a>
<a class="sourceLine" id="cb242-9" title="9">    printf(<span class="st">&quot;Starting Libevent %s.  Available methods are:</span><span class="sc">\n</span><span class="st">&quot;</span>,</a>
<a class="sourceLine" id="cb242-10" title="10">            event_get_version());</a>
<a class="sourceLine" id="cb242-11" title="11">    <span class="cf">for</span> (i=<span class="dv">0</span>; methods[i] != NULL; ++i) {</a>
<a class="sourceLine" id="cb242-12" title="12">        printf(<span class="st">&quot;    %s</span><span class="sc">\n</span><span class="st">&quot;</span>, methods[i]);</a>
<a class="sourceLine" id="cb242-13" title="13">    }   </a>
<a class="sourceLine" id="cb242-14" title="14">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb242-15" title="15">}</a></code></pre></div>
<p>This produces as output on <code>ecetesla0</code> (at the time of writing):</p>
<pre><code>jzarnett@ecetesla0:~/ece252$ gcc -std=c99 -g -levent -o le1 le1.c
jzarnett@ecetesla0:~/ece252$ ./le1 
Starting Libevent 2.1.8-stable.  Available methods are:
    epoll
    poll
    select</code></pre>
<p>If you actually want to know what method will be used internally <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb244" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb244-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb244-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb244-3" title="3"><span class="pp">#include </span><span class="im">&lt;event2/event.h&gt;</span></a>
<a class="sourceLine" id="cb244-4" title="4"></a>
<a class="sourceLine" id="cb244-5" title="5"><span class="dt">int</span> main( <span class="dt">int</span> argc, <span class="dt">char</span>** argv ) { </a>
<a class="sourceLine" id="cb244-6" title="6">    <span class="kw">struct</span> event_base *base;</a>
<a class="sourceLine" id="cb244-7" title="7">    <span class="kw">enum</span> event_method_feature f;</a>
<a class="sourceLine" id="cb244-8" title="8"></a>
<a class="sourceLine" id="cb244-9" title="9">    base = event_base_new();</a>
<a class="sourceLine" id="cb244-10" title="10">    <span class="cf">if</span> (!base) {</a>
<a class="sourceLine" id="cb244-11" title="11">        puts(<span class="st">&quot;Couldn&#39;t get an event_base!&quot;</span>);</a>
<a class="sourceLine" id="cb244-12" title="12">    } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb244-13" title="13">        printf(<span class="st">&quot;Using Libevent with backend method %s.&quot;</span>,</a>
<a class="sourceLine" id="cb244-14" title="14">                event_base_get_method(base));</a>
<a class="sourceLine" id="cb244-15" title="15">        f = event_base_get_features(base);</a>
<a class="sourceLine" id="cb244-16" title="16">        <span class="cf">if</span> ((f &amp; EV_FEATURE_ET))</a>
<a class="sourceLine" id="cb244-17" title="17">            printf(<span class="st">&quot;  Edge-triggered events are supported.&quot;</span>);</a>
<a class="sourceLine" id="cb244-18" title="18">        <span class="cf">if</span> ((f &amp; EV_FEATURE_O1))</a>
<a class="sourceLine" id="cb244-19" title="19">            printf(<span class="st">&quot;  O(1) event notification is supported.&quot;</span>);</a>
<a class="sourceLine" id="cb244-20" title="20">        <span class="cf">if</span> ((f &amp; EV_FEATURE_FDS))</a>
<a class="sourceLine" id="cb244-21" title="21">            printf(<span class="st">&quot;  All FD types are supported.&quot;</span>);</a>
<a class="sourceLine" id="cb244-22" title="22">        puts(<span class="st">&quot;&quot;</span>);</a>
<a class="sourceLine" id="cb244-23" title="23">    }   </a>
<a class="sourceLine" id="cb244-24" title="24">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb244-25" title="25">}</a></code></pre></div>
<p>Running this produces:</p>
<pre><code>jzarnett@ecetesla0:~/ece252$ ./le2
Using Libevent with backend method epoll.  
 Edge-triggered events are supported.  
 O(1) event notification is supported.</code></pre>
<p>Wait, we didn’t learn about epoll... Do we need to? Well, no – the great thing about libevent is that we don’t have to think about the details of the backend – whatever implementation is used is not really our concern.</p>
<h5 id="event-notification.">Event notification.</h5>
<p>The goal is to watch for some events, and for that we need a definition of an event. An event happens on a file descriptor, as with all the other I/O methods we have discussed.</p>
<p>An event has a lifecycle: it is created; when it becomes associated with an event base it is said to be initialized. When you add it, it is pending, which is to say that we are waiting for the event to happen. If the event that we’re looking for does occur when the event is pending, then a user-defined callback runs. If we don’t want to wait for an event anymore we can use delete to make an event non-pending; a non-pending event can be re-added if desired <span class="citation" data-cites="libevent"></span>.</p>
<p>To create and destroy an event:</p>
<div class="sourceCode" id="cb246" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb246-1" title="1"><span class="kw">typedef</span> <span class="dt">void</span> (*event_callback_fn)( evutil_socket_t fd, <span class="dt">short</span> what, <span class="dt">void</span>* arg )</a>
<a class="sourceLine" id="cb246-2" title="2"><span class="kw">struct</span> event* event_new( <span class="kw">struct</span> event_base* base, evutil_socket_t fd, <span class="dt">short</span> what, event_callback_fn cb, <span class="dt">void</span>* arg )</a>
<a class="sourceLine" id="cb246-3" title="3"><span class="dt">void</span> event_free( <span class="kw">struct</span> event* event )</a></code></pre></div>
<p>The first line in there is the definition that the callback function must take: void return type with three parameters. We should be familiar enough with this sort of thing by now.</p>
<p>The event creation function tells you everything you need to provide when creating an event. The definition of the structure is kind of unimportant to us because we don’t access its internals directly. That’s fine with us. Anyway, the first argument is the base that this event will be associated with. The second argument of type <code>evutil_socket_t</code> is really an <code>int</code> (in non-Windows system anyway) and we can just put in our regular file descriptor here. The <code>what</code> parameter is how we specify the kind of thing we want to be notified of (see below). And finally, the last two parameters are the callback function and our user-defined argument to that callback function.</p>
<p>About that <code>what</code> parameter: hey look, we found a use for <code>short</code>! Only took half your degree... Anyway, we use this to say what we’re looking for, and it’s some combination of the following options (as defined by the library):</p>
<div class="sourceCode" id="cb247" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb247-1" title="1"><span class="pp">#define EV_TIMEOUT      0x01</span></a>
<a class="sourceLine" id="cb247-2" title="2"><span class="pp">#define EV_READ         0x02</span></a>
<a class="sourceLine" id="cb247-3" title="3"><span class="pp">#define EV_WRITE        0x04</span></a>
<a class="sourceLine" id="cb247-4" title="4"><span class="pp">#define EV_SIGNAL       0x08</span></a>
<a class="sourceLine" id="cb247-5" title="5"><span class="pp">#define EV_PERSIST      0x10</span></a>
<a class="sourceLine" id="cb247-6" title="6"><span class="pp">#define EV_ET           0x20</span></a></code></pre></div>
<p>Most of them are self explanatory, but some warrant a bit of explanation. The timeout flag is ignored when setting what you are interested in, but can be returned as a result. The “ET” one indicates that the event should be edge-triggered, which matters for read and writes (i.e., a change in readiness is reported rather than readiness). The “persist” one means that when an event is triggered it’s automatically ready to trigger again immediately.</p>
<p>They can be combined, as we’ve seen previously for say, an open system call. If you’re interested in watching for a read and a write, combine them using <code>|</code> (bitwise OR) just as we’ve done for other scenarios: <code>EV_READ | EV_WRITE</code>.</p>
<p>If you want the event itself to be the <code>void*</code> argument passed to the callback function, that can be done here as well. Normally this would not work, because the event doesn’t exist yet. But there’s a workaround for that, a function <code>event_self_cbarg()</code> that does a little magic for you <span class="citation" data-cites="libevent"></span>.</p>
<p>Deallocating an event is pretty self explanatory as well. It is okay to call this even on an event that is pending or active, according to the library docs, because it checks this and will deactivate or make non-pending any event that gets freed using the <code>event_free()</code> call.</p>
<p>Alright, so we have created an event. When we’re ready to start watching we can add the event, and when we’re done watching we can remove it, with the following functions:</p>
<div class="sourceCode" id="cb248" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb248-1" title="1"><span class="dt">int</span> event_add( <span class="kw">struct</span> event* ev, <span class="dt">const</span> <span class="kw">struct</span> timeval* tv );</a>
<a class="sourceLine" id="cb248-2" title="2"><span class="dt">int</span> event_del( <span class="kw">struct</span> event* ev );</a></code></pre></div>
<p>We will see an example soon, but first we are missing one more important thing: dispatching the events!</p>
<h5 id="lets-get-started.">Let’s get started.</h5>
<p>There are two ways to dispatch events, the simple way and the hard way:</p>
<div class="sourceCode" id="cb249" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb249-1" title="1"><span class="dt">int</span> event_base_dispatch( <span class="kw">struct</span> event_base* base);</a>
<a class="sourceLine" id="cb249-2" title="2"><span class="dt">int</span> event_base_loop(<span class="kw">struct</span> event_base *base, <span class="dt">int</span> flags);</a></code></pre></div>
<p>The easy way is the same as the hard way with no flags set, so the hard way actually isn’t all that hard. The flags are <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb250" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb250-1" title="1"><span class="pp">#define EVLOOP_ONCE             0x01</span></a>
<a class="sourceLine" id="cb250-2" title="2"><span class="pp">#define EVLOOP_NONBLOCK         0x02</span></a>
<a class="sourceLine" id="cb250-3" title="3"><span class="pp">#define EVLOOP_NO_EXIT_ON_EMPTY 0x04</span></a></code></pre></div>
<p>Once means that we just wait for some events to become active, then turn active events until there are no more, then return. The non-blocking option means we won’t wait for events to trigger: we’ll check if they’re ready, run them if so, and skip them if not. And normally the behaviour is to exit from the loop when there are no more events pending or active; you can turn that off with the no-exit flag. If you plan to use that, you can manually exit the loop with one of:</p>
<div class="sourceCode" id="cb251" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb251-1" title="1"><span class="dt">int</span> event_base_loopexit(<span class="kw">struct</span> event_base* base, <span class="dt">const</span> <span class="kw">struct</span> timeval* tv);</a>
<a class="sourceLine" id="cb251-2" title="2"><span class="dt">int</span> event_base_loopbreak(<span class="kw">struct</span> event_base* base);</a></code></pre></div>
<p>The exit function says to stop after some time has elapsed; if any events are active we process them before exiting. The break function says stop as soon as we’ve finished the currently-being-processed active event but not any other ones that are active. Typically this would occur in a callback function of some sort, when we know we are done.</p>
<p>Now, that code example that was delayed <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb252" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb252-1" title="1"><span class="dt">void</span> cb_func( evutil_socket_t fd, <span class="dt">short</span> what, <span class="dt">void</span> *arg ) {</a>
<a class="sourceLine" id="cb252-2" title="2">        <span class="dt">const</span> <span class="dt">char</span> *data = arg;</a>
<a class="sourceLine" id="cb252-3" title="3">        printf(<span class="st">&quot;Got an event on socket %d:%s%s%s%s [%s]&quot;</span>,</a>
<a class="sourceLine" id="cb252-4" title="4">            (<span class="dt">int</span>) fd,</a>
<a class="sourceLine" id="cb252-5" title="5">            (what&amp;EV_TIMEOUT) ? <span class="st">&quot; timeout&quot;</span> : <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb252-6" title="6">            (what&amp;EV_READ)    ? <span class="st">&quot; read&quot;</span> : <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb252-7" title="7">            (what&amp;EV_WRITE)   ? <span class="st">&quot; write&quot;</span> : <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb252-8" title="8">            (what&amp;EV_SIGNAL)  ? <span class="st">&quot; signal&quot;</span> : <span class="st">&quot;&quot;</span>,</a>
<a class="sourceLine" id="cb252-9" title="9">            data);</a>
<a class="sourceLine" id="cb252-10" title="10">}</a>
<a class="sourceLine" id="cb252-11" title="11"></a>
<a class="sourceLine" id="cb252-12" title="12"><span class="dt">void</span> main_loop( evutil_socket_t fd1, evutil_socket_t fd2 ){</a>
<a class="sourceLine" id="cb252-13" title="13">        <span class="kw">struct</span> event *ev1, *ev2;</a>
<a class="sourceLine" id="cb252-14" title="14">        <span class="kw">struct</span> timeval five_seconds = {<span class="dv">5</span>,<span class="dv">0</span>};</a>
<a class="sourceLine" id="cb252-15" title="15">        <span class="kw">struct</span> event_base *base = event_base_new();</a>
<a class="sourceLine" id="cb252-16" title="16"></a>
<a class="sourceLine" id="cb252-17" title="17">        <span class="co">/* The caller has already set up fd1, fd2 somehow, and make them nonblocking. */</span></a>
<a class="sourceLine" id="cb252-18" title="18"></a>
<a class="sourceLine" id="cb252-19" title="19">        ev1 = event_new(base, fd1, EV_TIMEOUT|EV_READ|EV_PERSIST, cb_func,(<span class="dt">char</span>*)<span class="st">&quot;Reading event&quot;</span>);</a>
<a class="sourceLine" id="cb252-20" title="20">        ev2 = event_new(base, fd2, EV_WRITE|EV_PERSIST, cb_func, (<span class="dt">char</span>*)<span class="st">&quot;Writing event&quot;</span>);</a>
<a class="sourceLine" id="cb252-21" title="21"></a>
<a class="sourceLine" id="cb252-22" title="22">        event_add(ev1, &amp;five_seconds);</a>
<a class="sourceLine" id="cb252-23" title="23">        event_add(ev2, NULL);</a>
<a class="sourceLine" id="cb252-24" title="24">        event_base_dispatch(base);</a>
<a class="sourceLine" id="cb252-25" title="25">}</a></code></pre></div>
<p>Alright, this demonstrates how to create an event base, create some events, add them to the pending list, and begin dispatching (waiting for events to occur). Only one thread can be dispatching a given event base at a time, but this is why we can have multiple bases.</p>
<h5 id="cleaning-up.">Cleaning up.</h5>
<p>Finally, libevent has some global structures that are initialized once. When we’re all completely done with everything, there is a global cleanup function available <span class="citation" data-cites="libevent"></span>:</p>
<div class="sourceCode" id="cb253" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb253-1" title="1"><span class="dt">void</span> libevent_global_shutdown( )</a></code></pre></div>
<p>This is not meant to deallocate anything that was the return value of a libevent function; those should be cleaned up normally. This should be the last function called, once all libevent stuff is done, otherwise unpredictable behaviour may occur.</p>
<h5 id="buffered-events.">Buffered events.</h5>
<p>For a slightly more advanced scenario, we might want to wait until we have a significant chunk of data before we’re ready to process it. If we’re receiving some data one character at a time, it’s very wasteful to fire an event every time a whole character is received. Instead, it’s better to have the event happen when a condition is fulfilled, such as having enough data available.</p>
<p>The library does support this: <code>bufferevents</code>! A normal callback is triggered when the underlying transport (e.g., socket) is ready to be read or written; a buffer event takes place when enough data has been read or written. Buffer events really only work for TCP communication, so we’ll be back to sockets. This is, to some extent, expected, because our general view of files is that they’re always “ready”, even if a read takes time to be carried out.</p>
<p>Each buffer event has two buffers: the input and output buffer. There are also two callbacks, a read and a write callback. By default, the read callback happens whenever any data is received, and the write callback is called whenever enough data from the output buffer is sent <span class="citation" data-cites="libevent"></span>. These can be overridden. But you can see why this would make some sense: whenever a chunk of data is received we put it in a buffer until all the data is there; we can send data when enough data has accumulated to be sent.</p>
<p>Every buffer event has four “watermarks”, which are the levels that trigger some sort of happening <span class="citation" data-cites="libevent"></span>:</p>
<ul>
<li><p>Read low-water mark: when a read occurs that results in the buffer being at least this full, the read callback triggers. By default, it is 0, so every chunk of data received starts the callback.</p></li>
<li><p>Read high-water mark: when a read occurs that leaves the buffer at this level, no more data will be copied into the buffer until data has been taken out of the buffer to get it below the level. By default, this is unlimited so libevent will try to fill up the buffer as much as possible.</p></li>
<li><p>Write low-water mark: when a write occurs to get to this level, the write callback occurs. This defaults to 0, so the write callback only runs if the output buffer is emptied.</p></li>
<li><p>Write high-water mark: strangely, does not do what you expect. It can be used for some special meaning situations, though.</p></li>
</ul>
<p>We’ll take a look at a buffer events example for socket communication. This means we need to know how to create a buffer event, and how to use it on a socket.</p>
<div class="sourceCode" id="cb254" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb254-1" title="1"><span class="kw">struct</span> bufferevent* bufferevent_socket_new( <span class="kw">struct</span> event_base* base, evutil_socket_t fd, </a>
<a class="sourceLine" id="cb254-2" title="2">    <span class="kw">enum</span> bufferevent_options options );</a>
<a class="sourceLine" id="cb254-3" title="3"><span class="dt">void</span> bufferevent_free( <span class="kw">struct</span> bufferevent* bev );</a>
<a class="sourceLine" id="cb254-4" title="4"></a>
<a class="sourceLine" id="cb254-5" title="5"><span class="kw">typedef</span> <span class="dt">void</span> (*bufferevent_data_cb)(<span class="kw">struct</span> bufferevent* bev, <span class="dt">void</span>* ctx);</a>
<a class="sourceLine" id="cb254-6" title="6"><span class="kw">typedef</span> <span class="dt">void</span> (*bufferevent_event_cb)(<span class="kw">struct</span> bufferevent* bev, <span class="dt">short</span> events, <span class="dt">void</span>* ctx);</a>
<a class="sourceLine" id="cb254-7" title="7"><span class="dt">void</span> bufferevent_setcb(<span class="kw">struct</span> bufferevent* bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, <span class="dt">void</span>* cbarg);</a>
<a class="sourceLine" id="cb254-8" title="8"></a>
<a class="sourceLine" id="cb254-9" title="9"><span class="dt">int</span> bufferevent_socket_connect( <span class="kw">struct</span> bufferevent* bev, <span class="kw">struct</span> sockaddr* address, <span class="dt">int</span> addrlen );</a></code></pre></div>
<p>Creating a buffer event structure is fairly straightforward: specify which event base it should belong to, the file descriptor, and then you get to choose some options. There are multiple options, but the two we will consider are as follows. The first is <code>BEV_OPT_CLOSE_ON_FREE</code>: close the socket when the buffer event is deallocated. The other is <code>BEV_OPT_THREADSAFE</code>: configure the buffer event to use locks, so it can be accessed concurrently from multiple threads.</p>
<p>The deallocation function is totally self-explanatory.</p>
<p>The definitions of data callbacks and event callbacks are a bit more complex. The return type is void, and the arguments are the buffer event structure – sensible, and then there’s a divergence. The data callback takes only some argument; it’s the one provided by the user when setting up the callback (see below). The event callback has the extra parameter of events which works as it did earlier (where you say what events you are interested in).</p>
<p>Setting the callback is relatively self explanatory: specify the buffer event, the read callback (NULL if you don’t want one, or to clear one), the write callback (again, NULL if you don’t want one), and the event callback. Finally, there is the callback argument (of any type) and this argument is shared between all callbacks.</p>
<p>Then there is the connect function. This function takes the buffer event that you want to configure, and the address to connect to, as well as the size of the address. So that part is easy.</p>
<p>Let’s consider an example from <span class="citation" data-cites="libevent"></span> that shows how to use the buffer events:</p>
<div class="sourceCode" id="cb255" data-language="C"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb255-1" title="1"><span class="pp">#include </span><span class="im">&lt;event2/event.h&gt;</span></a>
<a class="sourceLine" id="cb255-2" title="2"><span class="pp">#include </span><span class="im">&lt;event2/bufferevent.h&gt;</span></a>
<a class="sourceLine" id="cb255-3" title="3"><span class="pp">#include </span><span class="im">&lt;sys/socket.h&gt;</span></a>
<a class="sourceLine" id="cb255-4" title="4"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb255-5" title="5"></a>
<a class="sourceLine" id="cb255-6" title="6"><span class="dt">void</span> eventcb(<span class="kw">struct</span> bufferevent *bev, <span class="dt">short</span> events, <span class="dt">void</span> *ptr) {</a>
<a class="sourceLine" id="cb255-7" title="7">    <span class="cf">if</span> (events &amp; BEV_EVENT_CONNECTED) {</a>
<a class="sourceLine" id="cb255-8" title="8">         <span class="co">/* We&#39;re connected to 127.0.0.1:8080.   Ordinarily we&#39;d do</span></a>
<a class="sourceLine" id="cb255-9" title="9"><span class="co">            something here, like start reading or writing. */</span></a>
<a class="sourceLine" id="cb255-10" title="10">    } <span class="cf">else</span> <span class="cf">if</span> (events &amp; BEV_EVENT_ERROR) {</a>
<a class="sourceLine" id="cb255-11" title="11">         <span class="co">/* An error occured while connecting. */</span></a>
<a class="sourceLine" id="cb255-12" title="12">    }</a>
<a class="sourceLine" id="cb255-13" title="13">}</a>
<a class="sourceLine" id="cb255-14" title="14"></a>
<a class="sourceLine" id="cb255-15" title="15"><span class="dt">int</span> main_loop( ) {</a>
<a class="sourceLine" id="cb255-16" title="16">    <span class="kw">struct</span> event_base *base;</a>
<a class="sourceLine" id="cb255-17" title="17">    <span class="kw">struct</span> bufferevent *bev;</a>
<a class="sourceLine" id="cb255-18" title="18">    <span class="kw">struct</span> sockaddr_in sin;</a>
<a class="sourceLine" id="cb255-19" title="19"></a>
<a class="sourceLine" id="cb255-20" title="20">    base = event_base_new();</a>
<a class="sourceLine" id="cb255-21" title="21"></a>
<a class="sourceLine" id="cb255-22" title="22">    memset(&amp;sin, <span class="dv">0</span>, <span class="kw">sizeof</span>(sin));</a>
<a class="sourceLine" id="cb255-23" title="23">    sin.sin_family = AF_INET;</a>
<a class="sourceLine" id="cb255-24" title="24">    sin.sin_addr.s_addr = htonl(<span class="bn">0x7f000001</span>); <span class="co">/* 127.0.0.1 */</span></a>
<a class="sourceLine" id="cb255-25" title="25">    sin.sin_port = htons(<span class="dv">8080</span>); <span class="co">/* Port 8080 */</span></a>
<a class="sourceLine" id="cb255-26" title="26"></a>
<a class="sourceLine" id="cb255-27" title="27">    bev = bufferevent_socket_new(base, -<span class="dv">1</span>, BEV_OPT_CLOSE_ON_FREE);</a>
<a class="sourceLine" id="cb255-28" title="28"></a>
<a class="sourceLine" id="cb255-29" title="29">    bufferevent_setcb(bev, NULL, NULL, eventcb, NULL);</a>
<a class="sourceLine" id="cb255-30" title="30"></a>
<a class="sourceLine" id="cb255-31" title="31">    <span class="cf">if</span> (bufferevent_socket_connect(bev,</a>
<a class="sourceLine" id="cb255-32" title="32">        (<span class="kw">struct</span> sockaddr *)&amp;sin, <span class="kw">sizeof</span>(sin)) &lt; <span class="dv">0</span>) {</a>
<a class="sourceLine" id="cb255-33" title="33">        <span class="co">/* Error starting connection */</span></a>
<a class="sourceLine" id="cb255-34" title="34">        bufferevent_free(bev);</a>
<a class="sourceLine" id="cb255-35" title="35">        <span class="cf">return</span> -<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb255-36" title="36">    }</a>
<a class="sourceLine" id="cb255-37" title="37"></a>
<a class="sourceLine" id="cb255-38" title="38">    event_base_dispatch(base);</a>
<a class="sourceLine" id="cb255-39" title="39">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb255-40" title="40">}</a></code></pre></div>
<p>This sets up a callback that doesn’t do much, but that’s fine for the purpose of the example. We set up the socket connection stuff - the address and port. Then we create the buffer event, with the file descriptor as -1. This placeholder value means that at the time the buffer event is created, the file descriptor is not yet set. That makes sense, because the socket hasn’t been opened yet. There’s no file descriptor to set yet. Then we’ll configure the callback, and launch the connect call. When the connection is established, the callback runs.</p>
<p>By no means have we covered every possible option or tool in the libevent library. It is quite powerful and quite effective at its job. But now we have an introduction to it, and we’ve seen a lot of ways to do asynchronous I/O.</p>
<h1 id="starling-city-vigilantes" class="unnumbered">33 — Starling City Vigilantes</h1>
<h2 id="in-class-exercise" class="unnumbered">In Class Exercise: </h2>
<h5 id="background.-3">Background.</h5>
<p>Your name is Oliver Queen. After five years in hell, you have come home with only one goal: to save your city. Now others have joined your crusade. To them, you’re Oliver Queen. To the rest of Starling City, you’re someone else. You are something else. You are... the Green Arrow.</p>
<p>The League of Assassins has planted an explosive device in one of the buildings around town. There are too many buildings for you to search by yourself, but you have a team of your fellow vigilantes who will help you. It’s your team, so you will need to coordinate the actions of your team members – telling them what areas they should search, and checking in with them as to whether they’ve found it. You are a hands-on individual, so you will also be searching in the meantime.</p>
<p>Either you or a member of your team will find the device eventually. Once it has been found, you can tell your team members they can stop searching. If you found the device, deal with it immediately. If someone else found it, they will tell you where it is so you can deal with it. Once it’s disabled, the city is safe for another night and you can go back to the lair.</p>
<h5 id="primary-objective.-3">Primary Objective.</h5>
<p>The primary objective of this exercise is to practice using asynchronous I/O in a program.</p>
<h5 id="secondary-objectives.-3">Secondary Objective(s).</h5>
<p>This is an additional opportunity to practice with system calls, program design, . You may also improve your ability to work with version control (git) and gitlab.</p>
<h5 id="starter-code.-3">Starter Code.</h5>
<p>The starter code can be found at <a href="https://git.uwaterloo.ca/ece252-1195/ece252-e4">https://git.uwaterloo.ca/ece252-1195/ece252-e4</a> – fork this repository to your own space. Set permissions for this repository to be private, but add the group for the course staff with read access so your code can be evaluated.</p>
<h5 id="submitting-your-code.-3">Submitting Your Code.</h5>
<p>When you’re done, use the command <code>git commit -a</code> to add all files to your commit and enter a commit message. Then <code>git push</code> to upload your changes to your repository. You can commit and push as many times as you like; we’ll look at whatever was last pushed. And check that you gave the course staff permissions!</p>
<h5 id="grading.-3">Grading.</h5>
<p>Binary grading: 1 if you have made a meaningful attempt at implementing the code; 0 otherwise.</p>
<h5 id="description-of-behaviour.-3">Description of Behaviour.</h5>
<p>The goal is to implement the program so that the following behaviour occurs:</p>
<ul>
<li><p>Each building needs to be searched. You will do some yourself as shown in the starter code (every 5th building is assigned to you). You can search one building at a time the normal way (with blocking reads), as is shown in the starter code.</p></li>
<li><p>The majority of the work should be handed out to team members using POSIX AIO. And the AIO requests can all be started up-front, before you search any buildings yourself.</p></li>
<li><p>For each building you’re not going to search yourself you should create and enqueue a POSIX AIO request.</p></li>
<li><p>For each building, you need to create an AIO control block and its associated buffer.</p></li>
<li><p>Offset should be 0 in each control block.</p></li>
<li><p>The event action when the AIO is complete should be to create a new thread; the new thread should run the function name of the team member who has been assigned that building.</p></li>
<li><p>You have four team members helping you: Diggle, Speedy, Black Canary, and Arsenal. Each of them can be in only one place at a time, so it is best to distribute the work evenly between them.</p></li>
<li><p>The argument in the event (<code>sigev_value.sival_ptr</code>) should be a pointer to the buffer representing the building (i.e., the same as the read buffer).</p></li>
<li><p>Your program should not leak memory; be sure to destroy/deallocate anything initialized/allocated.</p></li>
<li><p>There should not be any race conditions in your program either.</p></li>
</ul>
<h5 id="hints-debugging-guidance.-3">Hints &amp; Debugging Guidance.</h5>
<p>Some general guidance is below. If you’re having trouble, try running through these steps and it may resolve your problem. If you’re still stuck you can ask a neighbour or the course staff.</p>
<ul>
<li><p>If you need to catch up on how AIO works then you can look at the lecture on the subject in the course notes or <span class="citation" data-cites="apunix"></span> chapter 14.5.3.</p></li>
<li><p>If your program seems to hang, it may be because the <code>found_it</code> semaphore is never triggered.</p></li>
<li><p>If you get double <code>free</code> alerts it may be because you are re-using a buffer inappropriately.</p></li>
<li><p>To narrow down the source of a problem, you could assign all work to yourself (main) or to one team member; if the problem does not occur then concurrency may be an issue.</p></li>
<li><p>Check the documentation for how functions work if you are unfamiliar with them (google is your friend!)</p></li>
<li><p>Have you initialized all variables? It is easy to forget; <code>malloc</code> does not initialize the value...</p></li>
<li><p>Is there a missing or extra <code>*</code> (dereference) on a pointer somewhere?</p></li>
<li><p>Does every memory allocation have a matching deallocation?</p></li>
<li><p>Check whether values are stack or heap allocated (this can cause problems).</p></li>
<li><p>It may be helpful to put <code>printf()</code> statements to follow along what the program is doing and it may help you narrow down where the issue is.</p></li>
<li><p>Don’t be shy about asking for help; the TAs and instructor are here to help you get it done and will help you as much as is reasonable.</p></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Then you have failed this city...<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn2" role="doc-endnote"><p>Security advice: don’t click on links you receive by e-mail.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn3" role="doc-endnote"><p>The graphics card seems like a more obvious example, but these days there are various programs that can make use of the powerful GPU to do general purpose computation.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn4" role="doc-endnote"><p>For the record, the author drinks tea, black.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn5" role="doc-endnote"><p>In the immortal words of Bill Watterson, author of <em>Calvin and Hobbes</em>: “verbing weirds language.”<a href="#fnref5" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn6" role="doc-endnote"><p>Sadly, the specifications for C and POSIX and many other things are riddled with these “undefined behaviour” situations and it causes programmers everywhere a great deal of stress and difficulty. Another example: reading from an uninitialized variable in C produces undefined behaviour too.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn7" role="doc-endnote"><p>If this reference makes no sense to you, it’s because I’m old: https://www.youtube.com/watch?v=cgvv4wnVlFU<a href="#fnref7" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn8" role="doc-endnote"><p>Although the financial crisis of 2008 might convince you that the banker’s algorithm is “do whatever makes you rich and when you run out of money, the government will bail you out”, this is not the algorithm we are studying here.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn9" role="doc-endnote"><p>Not to digress too much to the subject of banking, but if it IS the case that everyone asks for their money all at once, this is called a “run” on the bank and is generally considered a disaster. Central banks step in with more money to fix this situation.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn10" role="doc-endnote"><p>Once again, verbing weirds language.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn11" role="doc-endnote"><p>German: Götterdämmerung - “Twilight of the gods”<a href="#fnref11" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn12" role="doc-endnote"><p>Spoiler alert: this isn’t going to end well for Odin.<a href="#fnref12" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn13" role="doc-endnote"><p>Sorry if I’ve just spoiled the plot of a Marvel movie.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn14" role="doc-endnote"><p>Yo dawg, we heard you like index blocks...<a href="#fnref14" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn15" role="doc-endnote"><p>See this post from the mailing list: <a href="https://curl.haxx.se/mail/lib-2011-11/0078.html">https://curl.haxx.se/mail/lib-2011-11/0078.html</a><a href="#fnref15" class="footnote-back" role="doc-backlink">↩</a></p></li>
<li id="fn16" role="doc-endnote"><p>See this 2013 post from the mailing list: <a href="https://curl.haxx.se/mail/lib-2013-03/0188.html">https://curl.haxx.se/mail/lib-2013-03/0188.html</a><a href="#fnref16" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
<button id='button' style="right:0; padding: 1%; display: flex; justify-content: center; margin: 0 auto 10px auto; width: 144px;" onClick="next()"; type="button">NEXT LECTURE</button>
</body>
</html>
